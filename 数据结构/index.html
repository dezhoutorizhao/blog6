<!DOCTYPE html>
<html lang="en">

<!-- Head tag -->
<head>

    <meta charset="utf-8">
    <meta http-equiv="X-UA-Compatible" content="IE=edge">
    <meta name="viewport" content="width=device-width, initial-scale=1">

    <!--Description-->
    
        <meta name="description" content="CTF web手、Golang后端开发工程师 研究多线程高并发、渗透测试      Web安全">
    

    <!--Author-->
    
        <meta name="author" content="h3110w0r1d">
    

    <!--Open Graph Title-->
    
        <meta property="og:title" content="数据结构"/>
    

    <!--Open Graph Description-->
    
        <meta property="og:description" content="CTF web手、Golang后端开发工程师 研究多线程高并发、渗透测试      Web安全" />
    

    <!--Open Graph Site Name-->
    <meta property="og:site_name" content="h3110w0r1d&#39;s Blog"/>

    <!--Type page-->
    
        <meta property="og:type" content="article" />
    

    <!--Page Cover-->
    

    
        <meta name="twitter:card" content="summary" />
    
    
    

    <!-- Title -->
    
    <title>数据结构 - h3110w0r1d&#39;s Blog</title>

    <!-- Bootstrap Core CSS -->
    <link rel="stylesheet" href="//maxcdn.bootstrapcdn.com/bootstrap/4.0.0-alpha.2/css/bootstrap.min.css" integrity="sha384-y3tfxAZXuh4HwSYylfB+J125MxIs6mR5FOHamPBG064zB+AFeWH94NdvaCBm8qnd" crossorigin="anonymous">

    <!-- Custom Fonts -->
    <link href="//maxcdn.bootstrapcdn.com/font-awesome/4.7.0/css/font-awesome.min.css" rel="stylesheet" type="text/css">

    <!-- HTML5 Shim and Respond.js IE8 support of HTML5 elements and media queries -->
    <!-- WARNING: Respond.js doesn't work if you view the page via file:// -->
    <!--[if lt IE 9]>
        <script src="//oss.maxcdn.com/libs/html5shiv/3.7.0/html5shiv.js"></script>
        <script src="//oss.maxcdn.com/libs/respond.js/1.4.2/respond.min.js"></script>
    <![endif]-->

    <!-- Gallery -->
    <link href="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.css" type="text/css" rel="stylesheet" />

    <!-- Custom CSS -->
    
<link rel="stylesheet" href="/css/style.css">


    <!-- Google Analytics -->
    


<meta name="generator" content="Hexo 5.4.0"></head>


<body>

<div class="bg-gradient"></div>
<div class="bg-pattern"></div>

<!-- Menu -->
<!--Menu Links and Overlay-->
<div class="menu-bg">
    <div class="menu-container">
        <ul>
            
            <li class="menu-item">
                <a href="/">
                    Home
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/archives">
                    Archives
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/about.html">
                    About
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/tags">
                    Tags
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/categories">
                    Categories
                </a>
            </li>
            
            <li class="menu-item">
                <a href="/contact.html">
                    Contact
                </a>
            </li>
            
        </ul>
    </div>
</div>

<!--Hamburger Icon-->
<nav>
    <a href="#menu"></a>
</nav>

<div class="container">

    <!-- Main Content -->
    <div class="row">
    <div class="col-sm-12">

        <!--Title and Logo-->
        <header>
    <div class="logo">
        <a href="/"><i class="logo-icon fa fa-cube" aria-hidden="true"></i></a>
        
    </div>
</header>

        <section class="main">
            
<div class="post">

    <div class="post-header">
        <h1 class="title">
            <a href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/">
                数据结构
            </a>
        </h1>
        <div class="post-info">
            
                <span class="date">2023-08-30</span>
            
            
                <a href="#disqus_thread" class="comments">留言</a>
            
            
                <span class="category">
                    <a href="/categories/数据结构/">数据结构</a>
                </span>
            
        </div>
    </div>

    <div class="content">

        <!-- Gallery -->
        

        <!-- Post Content -->
        <h1 id="线性表"><a href="#线性表" class="headerlink" title="线性表"></a>线性表</h1><ol>
<li><p>  声明结构体用typedef</p>
</li>
<li><p>  静态分配方式用静态数组</p>
</li>
<li><p>  length存放顺序表的当前长度</p>
</li>
<li><p>  线性表要存放 数据元素 和 顺序表当前长度</p>
</li>
<li><p>可以理解为一个数据域：数据元素   和  一个指针域：顺序表当前长度</p>
  <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct &#123;
	int data[MaxSize];
	int length;
&#125;SqList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  结构体变量作函数参数时，用引用</p>
</li>
<li><p>  初始化线性表时，第一，要把每个元素都赋值为0；第二，要把线性表的长度赋值为0</p>
</li>
<li><p>```c++<br>  void Init(SqList &amp;L) {</p>
<pre><code>  for(int i = 0;i &lt; MaxSize;i++) &#123;
      L.data[i] = 0;
  &#125;
  L.length = 0;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
9.   在main函数中的初始化

10.   &#96;&#96;&#96;c++
      int main(void) &#123;
      	SqList L; &#x2F;&#x2F;初始化一个结构体变量，用类型 名称来写，int a一样
      	InitList(L);
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  插入元素，头插法</p>
</li>
<li><p>  插入的位置后，从后往前，前一个元素往后挪一个位置，为待插入的元素留出空间</p>
</li>
<li><p>  注意下标的起始，线性表从1开始，而数组下标从0开始。操作数 i 是从1开始，存到数组中应该是从 i-1 开始</p>
</li>
<li><p>  插入元素一共要提供三个参数：<strong>插入的线性表，插入的位置，插入的元素值</strong></p>
</li>
<li><p>```c++<br>  void ListInsert(SqList &amp;L,int i,int e) {</p>
<pre><code>  for(int j = L.length;j &gt;= i;j--) &#123; 
      // 插入第i-1号位置，所以要从i到Length末尾都要后移一位
      L.data[j] = L.data[j-1];
  &#125;
  L.data[i-1] = e;
  L.length++;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
16.   插入元素应该加上对插入位置的判断

17.   合法的插入范围是1-&gt;length+1,即数组中的0-&gt;length; length+1是添加到末尾的后一个位置

18.   &#96;&#96;&#96;c++
      bool ListInsert(SqList &amp;L,int i,int e) &#123;
      	if(i &lt; 1 || i &gt; length+1) return false;
      	if(L.length &gt;&#x3D; MaxSize) return false;
      	for(int j &#x3D; L.length;j &gt;&#x3D; i;j--) &#123;
      		L.data[j] &#x3D; L.data[j-1];
      	&#125;
      	L.data[i-1] &#x3D; e;
      	L.length++;
      	return true;
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  按值查找，一个一个地比较</p>
</li>
<li><p>  一定要明确循环的是什么，这个地方循环的是数组下标,而不是线性表的实际位置，从0-&gt;length</p>
</li>
<li><p>```c++<br>  int LocateElem(SqList &amp;L,int e) {</p>
<pre><code>  for(int i = 0;i &lt; length;i++) &#123;
      if(L.data[i] == e) return i+1; // 返回的是线性表中的实际位置，数组下标+1
  &#125;
  return -1;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
22.   线性表是随机存取，不需要一个一个地比较，直接根据数组下标去寻找即可

23.   &#96;&#96;&#96;c++
      int GetElem(SeqList &amp;L,int i) &#123; &#x2F;&#x2F;传入的是线性表的位置
      	return data[i-1]; &#x2F;&#x2F;返回的是数组中的位置对应的数据，要-1
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  线性表元素删除</p>
</li>
<li><p>```c++<br>  bool ListDelete(SeqList &amp;L,int i,int &amp;e) {</p>
<pre><code>  if(i &lt; 1||i &gt; L.length) &#123; //给出的删除位置为线性表的位置1-length，而不是数组下标
      return false; // 首先判断要删除的元素是否合法
  &#125;
  e=L.data[i-1]; //将要被删除的元素赋值给e，后面返回
  for(int j = i;j &lt; L.length;j++) &#123;
      L.data[j-1] = L.data[j]; //将删除元素后面的元素，从后往前移动
  &#125;
  L.length--; //别忘记修改指针域，即length
  return true;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
26.   动态拓展内存空间

27.   初始化动态空间的线性表时，用malloc

28.   malloc返回的是一个指针，指向了多大的内存空间的地址

29.   malloc返回的内存空间指针指向线性表的数据域

30.   &#96;&#96;&#96;c++
      #define InitSize 10
      typedef struct &#123;
      	int *data; &#x2F;&#x2F;数据域用指针
      	int MaxSize;
      	int length;
      &#125;SeqList;
      
      void InitList(SeqList &amp;L) &#123;
      	L.data&#x3D;(int*)malloc(InitSize*sizeof(int)); &#x2F;&#x2F; malloc的参数是，多少个元素*每个元素的大小
          L.length &#x3D; 0;
          L.MaxSize &#x3D; InitSize;
      &#125;
      
      void IncreaseSize(SeqList &amp;L,int len) &#123; &#x2F;&#x2F; 传入两个参数，一个是哪个线性表，另一个是拓展多长的内存空间
          int *p &#x3D; L.data; &#x2F;&#x2F;扩展内存空间时，先用一个指针指向原有的指针，作为备份
          L.data  &#x3D; (int*)malloc((L.MaxSize+len) * sizeof(int));
          &#x2F;&#x2F;给L重新申请一段更大的内存空间，相当于清零
          for(int i &#x3D; 0;i &lt; L.length;i++) &#123;
              L.data[i] &#x3D; p[i]; &#x2F;&#x2F;将原有的p指针指向的内存空间元素依次赋值给新地址L
          &#125;
          L.MaxSize &#x3D; L.MaxSize + len;
          free(p);
      &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="单链表"><a href="#单链表" class="headerlink" title="单链表"></a>单链表</h1><h1 id="单链表是next指针，二叉树是左右孩子lchild和rchild"><a href="#单链表是next指针，二叉树是左右孩子lchild和rchild" class="headerlink" title="单链表是next指针，二叉树是左右孩子lchild和rchild"></a>单链表是next指针，二叉树是左右孩子lchild和rchild</h1><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230831124933.png"></p>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct LNode &#123;
	ElemType data;
	struct LNode *next;
&#125;LNode,*LinkList;
&#x2F;&#x2F;相当于typedef struct LNode&#123;&#125; LNode;与typedef struct LNode&#123;&#125; *LinkList;
typedef struct LNode LNode;
typedef struct LNode *LinkList;

typedef struct LNode &#123;
    ElemType data;
    struct LNode *next;
&#125;LNode,*LinkList;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li><p>  LNode * L 与 LinkList L效果相同，都是声明一个指向单链表第一个节点的指针</p>
</li>
<li><p>  强调这是一个单链表，用LinkList</p>
</li>
<li><p>  强调这是一个节点，用LNode *</p>
</li>
<li><p>```c++<br>  typedef struct LNode {</p>
<pre><code>  int data;
  struct LNode * next;
</code></pre>
<p>  }LNode,*LinkList;</p>
<p>  typedef struct LNode {</p>
<pre><code>  int data;
  struct LNode *next; //不要忘记在定义next指针时，用struct关键字，struct LNode *next，定义同类型内部指针时，要带struct,struct LNode* next;
</code></pre>
<p>  }LNode,*LinkList;</p>
  <pre class="line-numbers language-none"><code class="language-none">     
5.   &#96;&#96;&#96;c++
     typedef struct LNode &#123;
     	int data;
     	struct LNode *next;
     &#125;LNode,*LinkList;
     
     &#x2F;&#x2F;初始化一个单链表，带头节点
     bool InitList(LinkList &amp;L) &#123;
         L &#x3D; (LNode *)malloc(sizeof(LNode)); &#x2F;&#x2F; 分配一个头节点
         if(L &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F;如果申请后，L仍为NULL，则内存不足，申请失败
             return false;
         &#125;
         L -&gt; next &#x3D; NULL; &#x2F;&#x2F;头节点之后暂时还没有节点
         return true;
     &#125;
     
     bool Empty(LinkList L) &#123;
         if(L -&gt; next &#x3D;&#x3D; NULL) return true; &#x2F;&#x2F;头指针指向头节点，如果头指针的下一个为空，则单链表为空
         return false;
     &#125;
     
     void test() &#123;
         LinkList L;
         InitList(L);
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  malloc返回的是一个指针，需要强制类型转换为对应指针类型，传入的参数是多少个元素*每个元素的大小</p>
</li>
<li><p>  带头节点的单链表 1. 申请一个节点大小的内存空间 2.判断L是否为NULL，内存够不够 3.将头节点的下一个节点地址域指向空 4.如果申请成功，返回true</p>
</li>
<li><p>  在第i个位置插入元素e</p>
</li>
<li><p>```c++<br>  bool ListInsert(LinkList &amp;L,int i,int e) {</p>
<pre><code>  if(i &lt; 1) return false;
  LNode *p; //指针p指向当前扫描到的节点
  int j = 0; //循环变量，用来判断当前是第几个节点
  p = L; //初始状态下，L指向头节点，头节点是第0个节点
  while(p!=NULL &amp;&amp; j &lt; i-1) &#123; //p不是空，说明没循环到末尾，j&lt;i-1说明还没有循环到第i-1个位置
      p = p-&gt;next;
      j++;
  &#125;
  if(p == NULL) &#123; //循环到末尾也没有找到，返回false
      return false;
  &#125;
  LNode *s = (LNode *)malloc(sizeof(LNode)); //重新开辟一个节点的内存大小,申请的是节点的指针
  s -&gt; data = e;
  s -&gt; next = p -&gt; next;
  p -&gt; next = s;
  return true;
</code></pre>
<p>  }<br>  // 1.判断插入位置是否合法<br>  // 2.声明循环指针p指向当前扫描到的节点，循环变量j判断当前是第几个节点，这里p强调是一个节点，所以用LNode *<br>  // 3.初始状态下，循环指针p指向头指针<br>  // 4.循环指针后移，直到移动到循环变量j和i-1相等且没到末尾<br>  // 5.循环到末尾也没找到，p==NULL,返回false<br>  // 6.申请一个节点大小的内存单元s，申请的是节点的指针<br>  // 7.改变s和p指针的指向关系<br>  // 8.成功返回true</p>
<p>  //单链表的插入操作，需要一个循环变量计数和一个循环指针，去找到应该循环d</p>
  <pre class="line-numbers language-none"><code class="language-none">     
10.   p指针后移： p &#x3D; p-&gt; next; 下一个指针的地址域赋给上一个，令上一个节点后移一个单位

11.   删除节点：首先要找到第i-1个节点，将其指针指向第i+1个节点，并释放第i个节点 

12.   &#96;&#96;&#96;c++
      bool ListDelete(LinkList &amp;L,int i,ElemType e) &#123;
      	if(i &lt; 1) return false;
          LNode *p;
          int j &#x3D; 0;
          p &#x3D; L;
          while(p !&#x3D; NULL &amp;&amp; j &lt; i-1) &#123; &#x2F;&#x2F;删除第i-1后面的第i号节点的位置
              p &#x3D; p -&gt; next;
              j++;
          &#125;
          if(p &#x3D;&#x3D; NULL) &#123;
              return false;
          &#125;
          if(p -&gt; next &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F;第i-1号节点后面再无节点
              return false;
          &#125;
          LNode *q &#x3D; p -&gt; next; &#x2F;&#x2F;令指针q指向被删除节点，p循环到删除节点的上一个节点
          e &#x3D; q -&gt; data;
          p-&gt;next &#x3D; q -&gt; next;
          free(q);
          return true;
      &#125;
      &#x2F;&#x2F; 1. 找位置
      &#x2F;&#x2F; 2. 改节点，将被删除节点的上一个节点的next指针指向被删除节点的next
      &#x2F;&#x2F; 3. 释放内存，将被删除节点的内存释放掉<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  单链表求长度</p>
</li>
<li><p>```c++<br>  int length(LinkList &amp;L) {</p>
<pre><code>  int len = 0;
  LNode *p = L; //将循环指针p指向头节点L
  while(p -&gt; next != NULL) &#123; //带头节点，头节点不算入长度的话
      p = p -&gt; next;
      len ++;
  &#125;
  return len;
</code></pre>
<p>  }</p>
<p>  int length(LinkList &amp;L) {</p>
<pre><code>  int len = 0;
  LNode *p = L -&gt; next; //跳过头节点
  while(p != NULL) &#123;
      p = p -&gt; next;
  &#125;
  return len;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
15.   尾插法建立单链表

16.   &#96;&#96;&#96;c++
      LinkList List_TailInsert(LinkList &amp;L) &#123;
      	int x;
      	L &#x3D; (LinkList)malloc(sizeof(LNode));
          LNode *s,*r &#x3D; L;
          scanf(&quot;%d&quot;,&amp;x);
          while(x !&#x3D; 9999) &#123;
              s &#x3D; (LNode*)malloc(sizeof(LNode));
              s -&gt; data &#x3D; x;
              r -&gt; next &#x3D; s;
              r &#x3D; s;
              scanf(&quot;%d&quot;,&amp;x);
          &#125;
      	r -&gt; next &#x3D; NULL;
          return L;
      &#125;
      &#x2F;&#x2F; 后插操作
      &#x2F;&#x2F; 1. 将指针r指向要插入节点的上一个位置
      &#x2F;&#x2F; 2. 申请插入节点s并赋值
      &#x2F;&#x2F; 3. r的next指针指向s
      &#x2F;&#x2F; 4. r后移一步指向s，为下一步的操作做准备
      &#x2F;&#x2F; 最后将最后一个节点的nextz<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="二叉树"><a href="#二叉树" class="headerlink" title="二叉树"></a>二叉树</h1><h2 id="顺序存储"><a href="#顺序存储" class="headerlink" title="顺序存储"></a>顺序存储</h2><ol>
<li>  几个常考的基本操作</li>
<li>  i的左孩子</li>
<li>  i的右孩子</li>
<li>  i的父节点</li>
<li>  i所在的层次</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230831152119.png"></li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230831152241.png"></li>
<li>  二叉树的顺序存储中，一定要把二叉树的节点编号和完全二叉树一一对应起来</li>
</ol>
<h2 id="链式存储"><a href="#链式存储" class="headerlink" title="链式存储"></a>链式存储</h2><h3 id="二叉链表"><a href="#二叉链表" class="headerlink" title="二叉链表"></a>二叉链表</h3><ol>
<li>  找到节点p的左右孩子节点时间复杂度低</li>
<li>  但是找某个节点的父节点，只能从根节点开始遍历</li>
</ol>
 <pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">struct ElemType &#123;
    int value;
&#125;
typedef struct BiTNode &#123;
    ElemType data; &#x2F;&#x2F;数据域
    struct BiTNode *lchild,*rchild; &#x2F;&#x2F;指针域
&#125;BiTNode,*BiTree; &#x2F;&#x2F;节点和树根节点的指针
&#x2F;&#x2F;BiTNode* 和 BiTree等价，但是侧重方面不同

&#x2F;&#x2F;定义一棵空树
&#x2F;&#x2F;声明一个指向根节点的指针，初始为NULL
BiTree root &#x3D; NULL;

&#x2F;&#x2F;插入根节点
root &#x3D; (BiTree)malloc(sizeof(BiTNode));
root -&gt; data &#x3D; &#123;1&#125;;
root -&gt; lchild &#x3D; NULL;
root -&gt; rchild &#x3D; NULL;

&#x2F;&#x2F;插入新节点
BiTNode *p &#x3D; (BiTNode*)malloc(sizeof(BiTNode));
p -&gt; data &#x3D; &#123;2&#125;;
p -&gt; lchild &#x3D; NULL;
p -&gt; rchild &#x3D; NULL;
root -&gt; lchild &#x3D; p; &#x2F;&#x2F;作为根节点的左孩子节点
&#x2F;&#x2F;插入新节点：分配一个节点大小的内存空间，给数据域赋值，并修改左右孩子和父指针<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h3 id="三叉链表"><a href="#三叉链表" class="headerlink" title="三叉链表"></a>三叉链表</h3><ol>
<li>  包含左右孩子节点和父节点指针</li>
<li>  三叉链表的目的是为了方便寻找父节点</li>
</ol>
<pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">typedef struct BiTNode &#123;
    ElemType data;
    struct BiTNode *lchild,*rchild;
    struct BiTNode *parent;
&#125;BiTNode,*BiTree;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="求树的深度"><a href="#求树的深度" class="headerlink" title="求树的深度"></a>求树的深度</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int treeDepth(BiTree T) &#123; &#x2F;&#x2F;接收二叉树的节点作为参数，通常是根节点
	if(T &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F;如果传入的节点是NULL，则返回0，因为空树的高度为0
		return 0;
	&#125;
    &#x2F;&#x2F;if T &#x3D;&#x3D; NULL 一个是判断这棵树是否为空树，另一个是当递归到叶子节点时，可以返回0+1&#x3D;1
	else &#123;
		int l &#x3D; treeDepth(T-&gt;lchild);
         int r &#x3D; treeDepth(T-&gt;rchild);
        &#x2F;&#x2F;是根据左右子树高度的最大值，应该包含根节点，所以应该+1
         if(l &gt; r) return l+1;
         else return r+1;
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>  递归左右子树高度：treeDepth(T -&gt; lchild); treeDepth(T -&gt; rchild);</li>
</ol>
<h2 id="判断节点总数"><a href="#判断节点总数" class="headerlink" title="判断节点总数"></a>判断节点总数</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">int count &#x3D; 0;
void Count(BiTree T) &#123;
    if(T &#x3D;&#x3D; NULL) &#123;
        return 0;
    &#125;
    else &#123;
       count++;
        Count(T-&gt;lchild);
        Count(T-&gt;rchild);
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>  判断节点总数，递归左右子树，并在递归左右子树之前要count++</li>
<li>  二叉树判断左右子树高度和统计节点总数，都要递归实现，并递归返回的条件是传入的节点为空</li>
</ol>
<h2 id="设计算法按前序次序打印二叉树中的叶子结点"><a href="#设计算法按前序次序打印二叉树中的叶子结点" class="headerlink" title="设计算法按前序次序打印二叉树中的叶子结点"></a>设计算法按前序次序打印二叉树中的叶子结点</h2><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void PrintLeaves(BiTree T) &#123;
    if(T &#x3D;&#x3D; NULL) &#123;
        return;
    &#125;
    if(T -&gt; lchild &#x3D;&#x3D; NULL &amp;&amp; T -&gt; rchild &#x3D;&#x3D; NULL) &#123; &#x2F;&#x2F;判断是否为叶子节点
        printf(&quot;%d&quot;,T-&gt;data); &#x2F;&#x2F; 只打印叶子节点
    &#125;
    PrintLeaves(T -&gt; lchild); &#x2F;&#x2F;递归处理左子树
    PrintLeaves(T -&gt; rchild); &#x2F;&#x2F;递归处理右子树
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="前序序列打印所有节点"><a href="#前序序列打印所有节点" class="headerlink" title="前序序列打印所有节点"></a>前序序列打印所有节点</h2><ol>
<li><p>  和只打印叶子节点相比，少了一个对是否为叶子节点的判断，即</p>
</li>
<li><p>```c++<br>  if(T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL) {}</p>
<p>  if(T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL){}<br>  //叶子节点有一个判断，即左右孩子是否为空<br>  if(T -&gt; lchild == NULL &amp;&amp; T -&gt; rchild == NULL){}<br>  if(T -&gt; lchild – NULL &amp;&amp; T -&gt; rchild == NULL){}</p>
  <pre class="line-numbers language-none"><code class="language-none">     
3.   &#96;&#96;&#96;c++
     void PrintPreorder(BiTree T) &#123;
     	if(T &#x3D;&#x3D; NULL) &#123;
             return;
         &#125;
         else &#123;
             printf(&quot;%d&quot;,T -&gt; data);
             PrintPreorder(T -&gt; lchild);
             PrintPreorder(T -&gt; rchild);
         &#125;
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h1 id="已知数组A-n-中的元素为整型，设计算法将其调整为左右两部分，左边所有元素为偶数，右边所有元素为奇数，并要求算法的时间复杂度为O-n"><a href="#已知数组A-n-中的元素为整型，设计算法将其调整为左右两部分，左边所有元素为偶数，右边所有元素为奇数，并要求算法的时间复杂度为O-n" class="headerlink" title="已知数组A[n]中的元素为整型，设计算法将其调整为左右两部分，左边所有元素为偶数，右边所有元素为奇数，并要求算法的时间复杂度为Ｏ(n)"></a>已知数组A[n]中的元素为整型，设计算法将其调整为左右两部分，左边所有元素为偶数，右边所有元素为奇数，并要求算法的时间复杂度为Ｏ(n)</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void Array_reverse() &#123;
	int i &#x3D; 0,j &#x3D; n-1;
	while(i &lt; j) &#123; &#x2F;&#x2F;i是左侧，j是右侧，只有当i指针在j指针的左侧时，才继续进行交换操作
		while(a[i] % 2 &#x3D;&#x3D; 0) i++; &#x2F;&#x2F;a[i]满足要求，i指针后移,直到遇到一个奇数 
		while(a[j] % 2 !&#x3D; 0) j--; &#x2F;&#x2F;a[j]满足要求，j指针前移，直到遇到一个偶数停止 
		if(i &lt; j) swap(a[i],a[j]);  
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>  从数组的两端向中间比较，设置两个变量i和j，初始时i=0，j=n-1，若A[i]为偶数并且A[j]为奇数，则将A[i]与A[j]交换。</li>
</ol>
<h1 id="试写出带头节点的单链表逆置算法，请写出结点结构"><a href="#试写出带头节点的单链表逆置算法，请写出结点结构" class="headerlink" title="试写出带头节点的单链表逆置算法，请写出结点结构???"></a>试写出带头节点的单链表逆置算法，请写出结点结构???</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">LinkList Reverse(LinkList L) &#123;
	LNode *p,*r; &#x2F;&#x2F;前指针和后指针
	p &#x3D; L -&gt; next;
	L -&gt; next &#x3D; NULL;
	
	while(p !&#x3D; NULL) &#123;
		r &#x3D; p -&gt; next;
		p -&gt; next &#x3D; L -&gt; next;
		L -&gt; next &#x3D; p;
		p &#x3D; r;
	&#125; 
	return L;
&#125;
&#x2F;&#x2F;第一步，设置前后指针
&#x2F;&#x2F;第二步，p为第一个元素位置，断开头节点的下一个位置，断链
&#x2F;&#x2F;第三步，判断p是否为空
&#x2F;&#x2F;第四步，r指针后移
&#x2F;&#x2F;第五步，p-&gt;next &#x3D; L-&gt;next;
&#x2F;&#x2F;第六步，L-&gt;next &#x3D; p;
&#x2F;&#x2F;第七步，p指针后移指向r
&#x2F;&#x2F;zui&#39;ho<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="关键路径每次都取最大值"><a href="#关键路径每次都取最大值" class="headerlink" title="关键路径每次都取最大值"></a>关键路径每次都取最大值</h1><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901205604.png"></p>
<h1 id="插入排序"><a href="#插入排序" class="headerlink" title="插入排序"></a>插入排序</h1><pre class="line-numbers language-c++" data-language="c++"><code class="language-c++">void InsertSort(int a[],int len) &#123;
    for(int j &#x3D; 1;j &lt; len;j++) &#123; &#x2F;&#x2F;外部循环，从数组的第二个位置遍历到最后一个位置，外部循环控制我们要将哪个元素插入到已经排序的子数组中
        int key &#x3D; a[j];
        int i &#x3D; j - 1; &#x2F;&#x2F;i从当前元素的前一个元素开始
        while(i &gt;&#x3D; 0 &amp;&amp; a[i] &gt; key) &#123;
            a[i+1] &#x3D; a[i];
            i--;
        &#125;
        a[i+1] &#x3D; key;
    &#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h1 id="堆排序"><a href="#堆排序" class="headerlink" title="堆排序"></a>堆排序</h1><ol>
<li>  堆必须是一颗完全二叉树</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901213309.png"></li>
<li>  在小根堆中，每个父节点都必须小于子节点元素</li>
<li>  在大根堆中，每个父节点都必须大于子节点元素</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901213432.png"></li>
<li>  按照层序遍历的顺序来给节点编号</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901213803.png"></li>
</ol>
<h2 id="上滤"><a href="#上滤" class="headerlink" title="上滤"></a>上滤</h2><ol>
<li>  当叶子节点破坏了堆序性，让他和他的父元素比较,若大于父节点则交换，直到无法上移为止，</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901214131.png"></li>
</ol>
<h2 id="下滤"><a href="#下滤" class="headerlink" title="下滤"></a>下滤</h2><ol>
<li>  将破坏堆序性的元素跟他的<strong>最大</strong>的子节点比较，如果小于他的最大子节点，则交换</li>
<li>  持续比较，直到该元素大于他的子节点位置，或者移动到底部为止</li>
</ol>
<h2 id="总之，上滤是和父节点比较，下滤是和子节点比较，只能父子之间交换"><a href="#总之，上滤是和父节点比较，下滤是和子节点比较，只能父子之间交换" class="headerlink" title="总之，上滤是和父节点比较，下滤是和子节点比较，只能父子之间交换"></a>总之，上滤是和父节点比较，下滤是和子节点比较，只能父子之间交换</h2><h2 id="建堆"><a href="#建堆" class="headerlink" title="建堆"></a>建堆</h2><ol>
<li>  自顶向下建堆法</li>
<li>  将元素一个一个插入到堆内，将新元素放到堆的最后一位，然后对其进行上滤操作</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901214950.png"></li>
</ol>
<h2 id="取最值调整"><a href="#取最值调整" class="headerlink" title="取最值调整"></a>取最值调整</h2><ol>
<li>  在大根堆中，如果父节点比两个子节点都要小，则选最大的往上走</li>
<li>  在小根堆中，如果父节点比两个子节点都要大，则选最小的往上走</li>
</ol>
<h2 id="排序顺序：从最后一个父节点开始往上找"><a href="#排序顺序：从最后一个父节点开始往上找" class="headerlink" title="排序顺序：从最后一个父节点开始往上找"></a>排序顺序：从最后一个父节点开始往上找</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230901221115.png"></p>
<h1 id="错题"><a href="#错题" class="headerlink" title="错题"></a>错题</h1><h2 id="1"><a href="#1" class="headerlink" title="1"></a>1</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135244.png"></li>
</ol>
<h2 id="2"><a href="#2" class="headerlink" title="2"></a>2</h2><ol start="2">
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135322.png"></li>
</ol>
<h2 id="3"><a href="#3" class="headerlink" title="3"></a>3</h2><ol start="3">
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135343.png"></li>
<li>  对角矩阵：在非对角线上的元素均为0的方阵，只有主对角线（左上右下）上有非零元素</li>
<li>  三角矩阵：某个对角线以上/以下所有元素均为0的方针</li>
<li>  稀疏矩阵：具有大量0元素的矩阵</li>
<li>  对称矩阵：矩阵的转置与自身相等，a[‘i’] [‘j’] = a[j] [i]</li>
<li>  稀疏矩阵不属于特殊矩阵</li>
</ol>
<h2 id="4"><a href="#4" class="headerlink" title="4"></a>4</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135411.png"></li>
<li>  左斜树/右斜树的前序序列和后续序列正好相反</li>
<li>  如果先序序列和后序序列正好相反，那么先序序列的第一个节点就是根节点，后序序列最后一个节点就是根节点</li>
<li>  由于二叉树的深度==节点数，每个节点都对应一次进入根节点的位置</li>
</ol>
<h2 id="5"><a href="#5" class="headerlink" title="5"></a>5</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135430.png"></li>
</ol>
<h2 id="6"><a href="#6" class="headerlink" title="6"></a>6</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135500.png"></li>
</ol>
<h2 id="7"><a href="#7" class="headerlink" title="7"></a>7</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135523.png"></li>
</ol>
<h2 id="8"><a href="#8" class="headerlink" title="8"></a>8</h2><ol>
<li><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135540.png"><ol>
<li>  顺序查找平均长度==1+len/2 就是最好和最坏两个情况的平均值</li>
</ol>
</li>
</ol>
<h2 id="9"><a href="#9" class="headerlink" title="9"></a>9</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135559.png"></li>
</ol>
<h2 id="10"><a href="#10" class="headerlink" title="10"></a>10</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135609.png"></li>
<li>  插帽龟稳定</li>
<li>  选堆龟时间复杂度相同</li>
<li>  插入、冒泡、选择三个最简单的时间复杂度n方</li>
<li>  堆、快排、归并三个熟悉的n*logn</li>
<li>  希尔是二者之间</li>
</ol>
<h2 id="11"><a href="#11" class="headerlink" title="11"></a>11</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135624.png"></li>
<li>  循环队列也存在空间溢出问题</li>
<li>  循环队列中有一个判断队列空、满的位置，如果被占用，则无法判断空还是满，继续添加会溢出</li>
</ol>
<h2 id="12"><a href="#12" class="headerlink" title="12"></a>12</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20230914135651.png"></li>
<li>  什么是AOV网和AOE网</li>
</ol>

    </div>

    

    
        <div class="post-tags">
            <i class="fa fa-tags" aria-hidden="true"></i>
            <a href="/tags/数据结构/">#数据结构</a>
        </div>
    

    <!-- Comments -->
    
    <div class="comments">
        
<div id="disqus_thread">
    <noscript>Please enable JavaScript to view the <a target="_blank" rel="noopener" href="//disqus.com/?ref_noscript">comments powered by Disqus.</a></noscript>
</div>



    </div>
    

</div>
        </section>

    </div>
</div>


</div>

<!-- Footer -->
<div class="push"></div>

<footer class="footer-content">
    <div class="container">
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-6 col-lg-6 footer-about">
                <h2>About</h2>
                <p>
                    拒绝划水，拒绝摸鱼
                </p>
            </div>
            
    <div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 recent-posts">
        <h2>Recent Posts</h2>
        <ul>
            
            <li>
                <a class="footer-post" href="/2023%E5%A4%8D%E7%9B%98/">2023复盘</a>
            </li>
            
            <li>
                <a class="footer-post" href="/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/">侧信道攻击</a>
            </li>
            
            <li>
                <a class="footer-post" href="/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B_%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/">蓝帽杯半决赛wp_电子取证部分</a>
            </li>
            
            <li>
                <a class="footer-post" href="/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B_web/">蓝帽杯半决赛wp_web部分</a>
            </li>
            
        </ul>
    </div>



            
<div class="col-xs-6 col-sm-6 col-md-3 col-lg-3 footer-categories">
    <h2>Categories</h2>
    <ul>
        
        <li>
            <a class="footer-post" href="/categories/CSS/">CSS</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/CSS/ing/">ing</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/Hadoop/">Hadoop</a>
        </li>
        
        <li>
            <a class="footer-post" href="/categories/ing/">ing</a>
        </li>
        
    </ul>
</div>

        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <ul class="list-inline footer-social-icons">
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao/blog6">
                            <span class="footer-icon-container">
                                <i class="fa fa-github"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao/blog6">
                            <span class="footer-icon-container">
                                <i class="fa fa-twitter"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao/blog6">
                            <span class="footer-icon-container">
                                <i class="fa fa-facebook"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao/blog6">
                            <span class="footer-icon-container">
                                <i class="fa fa-instagram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao/blog6">
                            <span class="footer-icon-container">
                                <i class="fa fa-dribbble"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="http://dezhoutorizhao.github.io/blog6/">
                            <span class="footer-icon-container">
                                <i class="fa fa-telegram"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="http://dezhoutorizhao.github.io/blog6/">
                            <span class="footer-icon-container">
                                <i class="fa fa-behance"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="http://dezhoutorizhao.github.io/blog6/">
                            <span class="footer-icon-container">
                                <i class="fa fa-500px"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="mailto:a18888200398@163.com/">
                            <span class="footer-icon-container">
                                <i class="fa fa-envelope-o"></i>
                            </span>
                        </a>
                    </li>
                    
                    
                    <li class="list-inline-item">
                        <a href="\#">
                            <span class="footer-icon-container">
                                <i class="fa fa-rss"></i>
                            </span>
                        </a>
                    </li>
                    
                </ul>
            </div>
        </div>
        <div class="row">
            <div class="col-xs-12 col-sm-12 col-md-12 col-lg-12">
                <div class="footer-copyright">
                    @Untitled. All right reserved | Design & Hexo <a target="_blank" rel="noopener" href="http://www.codeblocq.com/">Jonathan Klughertz</a>
                </div>
            </div>
        </div>
    </div>
</footer>

<!-- After footer scripts -->

<!-- jQuery -->
<script src="//code.jquery.com/jquery-2.1.4.min.js"></script>

<!-- Tween Max -->
<script src="//cdnjs.cloudflare.com/ajax/libs/gsap/1.18.5/TweenMax.min.js"></script>

<!-- Gallery -->
<script src="//cdnjs.cloudflare.com/ajax/libs/featherlight/1.3.5/featherlight.min.js" type="text/javascript" charset="utf-8"></script>

<!-- Custom JavaScript -->

<script src="/js/main.js"></script>


<!-- Disqus Comments -->

<script type="text/javascript">
    var disqus_shortname = 'klugjotest';

    (function(){
        var dsq = document.createElement('script');
        dsq.type = 'text/javascript';
        dsq.async = true;
        dsq.src = '//' + disqus_shortname + '.disqus.com/embed.js';
        (document.getElementsByTagName('head')[0] || document.getElementsByTagName('body')[0]).appendChild(dsq);
    }());
</script>



</body>

</html>