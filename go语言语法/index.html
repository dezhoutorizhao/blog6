<!DOCTYPE html><html lang="zh-CN" data-theme="light"><head><meta charset="UTF-8"><meta http-equiv="X-UA-Compatible" content="IE=edge"><meta name="viewport" content="width=device-width, initial-scale=1.0,viewport-fit=cover"><title>go语言语法 | h3110w0r1d's Blog</title><meta name="author" content="h3110w0r1d"><meta name="copyright" content="h3110w0r1d"><meta name="format-detection" content="telephone=no"><meta name="theme-color" content="#ffffff"><meta name="description" content="go语言特点     第一个go语言package main  import &quot;fmt&quot;  func main() &amp;#123; 	fmt.Println(&quot;Hello world&quot;) &amp;#125;   go语言基础组成   包声明   引入包   函数   函数   变量   语句&amp;表达式   注释  各个部分      第一行代码 package main 定义了包名。你必须在源文件中">
<meta property="og:type" content="article">
<meta property="og:title" content="go语言语法">
<meta property="og:url" content="https://strongwill.top/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/index.html">
<meta property="og:site_name" content="h3110w0r1d&#39;s Blog">
<meta property="og:description" content="go语言特点     第一个go语言package main  import &quot;fmt&quot;  func main() &amp;#123; 	fmt.Println(&quot;Hello world&quot;) &amp;#125;   go语言基础组成   包声明   引入包   函数   函数   变量   语句&amp;表达式   注释  各个部分      第一行代码 package main 定义了包名。你必须在源文件中">
<meta property="og:locale" content="zh_CN">
<meta property="og:image" content="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/QQ图片20240111033823.jpg">
<meta property="article:published_time" content="2022-09-21T07:51:44.733Z">
<meta property="article:modified_time" content="2024-01-10T10:15:13.985Z">
<meta property="article:author" content="h3110w0r1d">
<meta property="article:tag" content="go">
<meta name="twitter:card" content="summary">
<meta name="twitter:image" content="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/QQ图片20240111033823.jpg"><link rel="shortcut icon" href="/img/favicon.png"><link rel="canonical" href="https://strongwill.top/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/index.html"><link rel="preconnect" href="//cdn.jsdelivr.net"/><link rel="preconnect" href="//busuanzi.ibruce.info"/><link rel="stylesheet" href="/css/index.css?v=4.12.0"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@6.5.1/css/all.min.css"><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.min.css" media="print" onload="this.media='all'"><script>const GLOBAL_CONFIG = {
  root: '/',
  algolia: undefined,
  localSearch: undefined,
  translate: undefined,
  noticeOutdate: undefined,
  highlight: {"plugin":"highlight.js","highlightCopy":true,"highlightLang":true,"highlightHeightLimit":false},
  copy: {
    success: '复制成功',
    error: '复制错误',
    noSupport: '浏览器不支持'
  },
  relativeDate: {
    homepage: false,
    post: false
  },
  runtime: '',
  dateSuffix: {
    just: '刚刚',
    min: '分钟前',
    hour: '小时前',
    day: '天前',
    month: '个月前'
  },
  copyright: undefined,
  lightbox: 'fancybox',
  Snackbar: undefined,
  infinitegrid: {
    js: 'https://cdn.jsdelivr.net/npm/@egjs/infinitegrid@4.11.0/dist/infinitegrid.min.js',
    buttonText: '加载更多'
  },
  isPhotoFigcaption: false,
  islazyload: false,
  isAnchor: false,
  percent: {
    toc: true,
    rightside: false,
  },
  autoDarkmode: false
}</script><script id="config-diff">var GLOBAL_CONFIG_SITE = {
  title: 'go语言语法',
  isPost: true,
  isHome: false,
  isHighlightShrink: false,
  isToc: true,
  postUpdate: '2024-01-10 18:15:13'
}</script><script>(win=>{
      win.saveToLocal = {
        set: (key, value, ttl) => {
          if (ttl === 0) return
          const now = Date.now()
          const expiry = now + ttl * 86400000
          const item = {
            value,
            expiry
          }
          localStorage.setItem(key, JSON.stringify(item))
        },
      
        get: key => {
          const itemStr = localStorage.getItem(key)
      
          if (!itemStr) {
            return undefined
          }
          const item = JSON.parse(itemStr)
          const now = Date.now()
      
          if (now > item.expiry) {
            localStorage.removeItem(key)
            return undefined
          }
          return item.value
        }
      }
    
      win.getScript = (url, attr = {}) => new Promise((resolve, reject) => {
        const script = document.createElement('script')
        script.src = url
        script.async = true
        script.onerror = reject
        script.onload = script.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          script.onload = script.onreadystatechange = null
          resolve()
        }

        Object.keys(attr).forEach(key => {
          script.setAttribute(key, attr[key])
        })

        document.head.appendChild(script)
      })
    
      win.getCSS = (url, id = false) => new Promise((resolve, reject) => {
        const link = document.createElement('link')
        link.rel = 'stylesheet'
        link.href = url
        if (id) link.id = id
        link.onerror = reject
        link.onload = link.onreadystatechange = function() {
          const loadState = this.readyState
          if (loadState && loadState !== 'loaded' && loadState !== 'complete') return
          link.onload = link.onreadystatechange = null
          resolve()
        }
        document.head.appendChild(link)
      })
    
      win.activateDarkMode = () => {
        document.documentElement.setAttribute('data-theme', 'dark')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#0d0d0d')
        }
      }
      win.activateLightMode = () => {
        document.documentElement.setAttribute('data-theme', 'light')
        if (document.querySelector('meta[name="theme-color"]') !== null) {
          document.querySelector('meta[name="theme-color"]').setAttribute('content', '#ffffff')
        }
      }
      const t = saveToLocal.get('theme')
    
        if (t === 'dark') activateDarkMode()
        else if (t === 'light') activateLightMode()
      
      const asideStatus = saveToLocal.get('aside-status')
      if (asideStatus !== undefined) {
        if (asideStatus === 'hide') {
          document.documentElement.classList.add('hide-aside')
        } else {
          document.documentElement.classList.remove('hide-aside')
        }
      }
    
      const detectApple = () => {
        if(/iPad|iPhone|iPod|Macintosh/.test(navigator.userAgent)){
          document.documentElement.classList.add('apple')
        }
      }
      detectApple()
    })(window)</script><meta name="generator" content="Hexo 5.4.0"></head><body><div id="web_bg"></div><div id="sidebar"><div id="menu-mask"></div><div id="sidebar-menus"><div class="avatar-img is-center"><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/QQ图片20240111033823.jpg" onerror="onerror=null;src='/img/friend_404.gif'" alt="avatar"/></div><div class="sidebar-site-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">70</div></a></div><hr class="custom-hr"/></div></div><div class="post" id="body-wrap"><header class="post-bg" id="page-header"><nav id="nav"><span id="blog-info"><a href="/" title="h3110w0r1d's Blog"><span class="site-name">h3110w0r1d's Blog</span></a></span><div id="menus"><div id="toggle-menu"><a class="site-page" href="javascript:void(0);"><i class="fas fa-bars fa-fw"></i></a></div></div></nav><div id="post-info"><h1 class="post-title">go语言语法</h1><div id="post-meta"><div class="meta-firstline"><span class="post-meta-date"><i class="far fa-calendar-alt fa-fw post-meta-icon"></i><span class="post-meta-label">发表于</span><time class="post-meta-date-created" datetime="2022-09-21T07:51:44.733Z" title="发表于 2022-09-21 15:51:44">2022-09-21</time><span class="post-meta-separator">|</span><i class="fas fa-history fa-fw post-meta-icon"></i><span class="post-meta-label">更新于</span><time class="post-meta-date-updated" datetime="2024-01-10T10:15:13.985Z" title="更新于 2024-01-10 18:15:13">2024-01-10</time></span><span class="post-meta-categories"><span class="post-meta-separator">|</span><i class="fas fa-inbox fa-fw post-meta-icon"></i><a class="post-meta-categories" href="/categories/go/">go</a></span></div><div class="meta-secondline"><span class="post-meta-separator">|</span><span class="post-meta-pv-cv" id="" data-flag-title="go语言语法"><i class="far fa-eye fa-fw post-meta-icon"></i><span class="post-meta-label">阅读量:</span><span id="busuanzi_value_page_pv"><i class="fa-solid fa-spinner fa-spin"></i></span></span></div></div></div></header><main class="layout" id="content-inner"><div id="post"><article class="post-content" id="article-container"><h1 id="go语言"><a href="#go语言" class="headerlink" title="go语言"></a>go语言</h1><h2 id="特点"><a href="#特点" class="headerlink" title="特点"></a>特点</h2><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921171704.png"></li>
</ol>
<h2 id="第一个go语言"><a href="#第一个go语言" class="headerlink" title="第一个go语言"></a>第一个go语言</h2><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span><span class="token string">"Hello world"</span><span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>
<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<h2 id="go语言基础组成"><a href="#go语言基础组成" class="headerlink" title="go语言基础组成"></a>go语言基础组成</h2><ol>
<li>  包声明</li>
<li>  引入包</li>
<li>  函数</li>
<li>  函数</li>
<li>  变量</li>
<li>  语句&amp;表达式</li>
<li>  注释</li>
</ol>
<h3 id="各个部分"><a href="#各个部分" class="headerlink" title="各个部分"></a>各个部分</h3><ol>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921171944.png"></li>
<li>  第一行代码 <em>package main</em> 定义了包名。你必须在源文件中非注释的第一行指明这个文件属于哪个包，如：package main。package main表示一个可独立执行的程序，每个 Go 应用程序都包含一个名为 main 的包。</li>
<li>  下一行 <em>import “fmt”</em> 告诉 Go 编译器这个程序需要使用 fmt 包（的函数，或其他元素），fmt 包实现了格式化 IO（输入/输出）的函数  fmt包：format</li>
<li>  下一行 <em>func main()</em> 是程序开始执行的函数。main 函数是每一个可执行程序所必须包含的，一般来说都是在启动后第一个执行的函数（如果有 init() 函数则会先执行该函数）。</li>
<li>  下一行 /<em>…</em>/ 是注释，在程序执行时将被忽略。单行注释是最常见的注释形式，你可以在任何地方使用以 // 开头的单行注释。多行注释也叫块注释，均已以 /* 开头，并以 */ 结尾，且不可以嵌套使用，多行注释一般用于包的文档描述或注释成块的代码片段。 </li>
<li>下一行 <em>fmt.Println(…)</em> 可以将字符串输出到控制台，并在最后自动增加换行字符 \n。<br>  使用 fmt.Print(“hello, world\n”) 可以得到相同的结果。<br>   Print 和 Println 这两个函数也支持使用变量，如：fmt.Println(arr)。如果没有特别指定，它们会以默认的打印格式将变量 arr 输出到控制台。</li>
<li>  当标识符（包括常量、变量、类型、函数名、结构字段等等）以一个大写字母开头，如：Group1，那么使用这种形式的标识符的对象就可以被外部包的代码所使用（客户端程序需要先导入这个包），这被称为导出（像面向对象语言中的 public）；标识符如果以小写字母开头，则对包外是不可见的，但是他们在整个包的内部是可见并且可用的（像面向对象语言中的 protected  ）。</li>
<li>  <strong>即大写字母开头为public , 小写字母开头为protected</strong></li>
</ol>
<h2 id="执行go"><a href="#执行go" class="headerlink" title="执行go"></a>执行go</h2><ol>
<li><p>```go<br>  go run hello.go //编译并执行代码</p>
  <pre class="line-numbers language-none"><code class="language-none">
2.   &#96;&#96;&#96;go
     go build hello.go &#x2F;&#x2F;go build命令来生成二进制文件<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>  生成的二进制文件没有.go后缀，直接 <strong>./文件名</strong> 即可运行程序</p>
</li>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921173130.png"></p>
</li>
</ol>
<h2 id="自动编译脚本"><a href="#自动编译脚本" class="headerlink" title="自动编译脚本"></a>自动编译脚本</h2><ol>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921173327.png"></p>
</li>
<li><p>```go<br>  #!/usr/bin/env bash</p>
<p>  CURRENT_DIR=<code>pwd</code><br>  OLD_GO_PATH=”$GOPATH”  #例如: /usr/local/go<br>  OLD_GO_BIN=”$GOBIN”    #例如: /usr/local/go/bin</p>
<p>  export GOPATH=”$CURRENT_DIR”<br>  export GOBIN=”$CURRENT_DIR/bin”</p>
<p>  #指定并整理当前的源码路径<br>  gofmt -w src</p>
<p>  go install test_hello</p>
<p>  export GOPATH=”$OLD_GO_PATH”<br>  export GOBIN=”$OLD_GO_BIN”</p>
  <pre class="line-numbers language-none"><code class="language-none">


## 关于包

1.   ![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20220921173409.png)
2.   同一个文件夹下的文件只能有一个包名，否则会编译报错

## 行分隔符

1.   在 Go 程序中，一行代表一个语句结束。每个语句不需要像 C 家族中的其它语言一样以分号 ; 结尾，因为这些工作都将由 Go 编译器自动完成。

     如果你打算将多个语句写在同一行，它们则必须使用 ; 人为区分，但在实际开发中我们并不鼓励这种做法。

2.   &#96;&#96;&#96;go
     fmt.Println(&quot;Hello, World!&quot;)
     fmt.Println(&quot;菜鸟教程：runoob.com&quot;)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="Go-语言的空格"><a href="#Go-语言的空格" class="headerlink" title="Go 语言的空格"></a>Go 语言的空格</h2><ol>
<li><p>  Go 语言中变量的声明必须使用空格隔开</p>
</li>
<li><p>```go<br>  var age int;</p>
  <pre class="line-numbers language-none"><code class="language-none">
## 格式化字符串

1.   &#96;&#96;&#96;
     fmt.Sprintf<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  使用fmt.Sprintf格式化字符串并赋值给新串</p>
</li>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921175725.png"></p>
</li>
</ol>
<h2 id="go语言变量"><a href="#go语言变量" class="headerlink" title="go语言变量"></a>go语言变量</h2><ol>
<li><p>  声明变量的一般形式是使用<strong>var关键字</strong></p>
</li>
<li><p>```go<br>  var identifier type</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   也可以一次声明多个变量

4.   &#96;&#96;&#96;go
     var identifier1,identifier2 type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>```go<br>  package main<br>  import “fmt”<br>  func main(){</p>
<pre><code>  var a string = &quot;Runoob&quot;
  fmt.Println(a)
  var b,c int = 1,2
  fmt.Println(b,c)
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
## 变量声明

1.   第一种，指定变量类型，如果没有初始值，则变量默认为0值

2.   &#96;&#96;&#96;go
     var v_name v_type
     v_name &#x3D; v_type<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  零值就是变量没有做初始化时系统默认设置的值</p>
</li>
<li><p>```go<br>  package main<br>  import “fmt”<br>  func main(){</p>
<pre><code>  var a = &quot;Runoob&quot;    
  fmt.Println(a)
  
  var a int
  fmt.Println(b) //int值默认为0
  
  var c bool
  fmt.Println(c) //bool值默认是false
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   第二种，根据值自行判定变量类型

6.   &#96;&#96;&#96;go
     var v_name &#x3D; value<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  第三种，如果变量已经使用var声明过了，再使用 := 声明变量，就产生编译错误</p>
</li>
<li><p>```go<br>  var intVal int<br>  //下面不能使用 intVal := 1,因为intVal 已经声明，不需要重新声明</p>
  <pre class="line-numbers language-none"><code class="language-none">
9.   第四种，直接使用 :&#x3D; 来声明即可

10.   &#96;&#96;&#96;go
      intVal :&#x3D; 1 &#x2F;&#x2F;此时不会产生编译错误，因为有声明新的变量，因为:&#x3D;是一个声明语句<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>```go<br>  var intVal int<br>  intVal = 1<br>  //和上面:=声明赋值相同</p>
  <pre class="line-numbers language-none"><code class="language-none">


### 多变量声明

1.   &#96;&#96;&#96;go
     &#x2F;&#x2F;类型相同的多个变量，而非全局变量
     var vname1,vname2,vname3 type
     vname1,vname2,vname3 &#x3D; v1,v2,v3
     var vname1,vname2,vname3 &#x3D; v1,v2,v3
     vname1,vname2,vname3 :&#x3D; v1,v2,v3 &#x2F;&#x2F;出现在:&#x3D;左侧的变量不应该是已经被声明过的，否则会导致编译错误<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  我的理解：</p>
</li>
<li><p>```go<br>  // var关键字用来声明<br>  // :=用来在赋值之前进行声明<br>  // 使用 := 不带var关键字声明格式的只能在函数体中出现，不能和全局变量一样放到</p>
  <pre class="line-numbers language-none"><code class="language-none">
4.   声明全局变量的隐式分解的写法

5.   &#96;&#96;&#96;go
     var(
     	vname1 v_type1
     	vname2 v_type2
     )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="值类型"><a href="#值类型" class="headerlink" title="值类型"></a>值类型</h3><ol>
<li>  所有像int,float,bool,string这些基本类型都属于值类型，使用这些类型的变量都直接指向存在内存中的值</li>
<li>  当使用等号 <code>=</code> 将一个变量的值赋值给另一个变量时，如：<code>j = i</code>，实际上是在内存中将 i 的值进行了拷贝：</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921210003.png"></li>
<li>  <strong>值类型变量的值都存储在堆中</strong></li>
</ol>
<h3 id="引用类型"><a href="#引用类型" class="headerlink" title="引用类型"></a>引用类型</h3><ol>
<li>  一个引用类型的变量存储的是这个变量所在的内存地址，或者内存地址中第一个字所在的位置</li>
<li>  并不是去直接存值</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220921210544.png"></li>
<li>  当使用赋值语句r2 = r1时，只有引用地址被复制</li>
<li>  <strong>如果r1的值改变了，那么这个值的所有引用都会指向被修改后的内容</strong>，在这个例子中，r2也会受到影响</li>
</ol>
<h3 id="注意"><a href="#注意" class="headerlink" title="注意"></a>注意</h3><ol>
<li>  如果在相同的代码块中，我们<strong>不可以再次对于相同名称的变量使用初始化声明</strong></li>
<li>  在函数中单纯地给 a 赋值（将a定义为非全局变量）也是不够的，这个值必须被使用（就是声明定义的变量必须使用）</li>
<li>  但是全局变量是允许声明但是不使用的，同一个类型的多个变量可以声明在同一行</li>
<li>  交换两个变量的值：a,b=b,a  两个变量的类型必须相同</li>
<li>  空白标识符也被用于抛弃值， _,b = 5,7 ,将得到结果为a没有值，b的值为7</li>
</ol>
<h3 id="简短形式"><a href="#简短形式" class="headerlink" title="简短形式"></a>简短形式</h3><ol>
<li>  使用 := 赋值操作符</li>
<li>  声明语句写var显得有些多余了，如果不是定义全局变量，则不需要写var</li>
<li>  变量的首选是用 := ，但是只能被用于函数体内，而不可以用于全局变量的声明与赋值</li>
</ol>
<h2 id="go语言常量"><a href="#go语言常量" class="headerlink" title="go语言常量"></a>go语言常量</h2><ol>
<li><p>```go<br>  const identifier [type] = value</p>
  <pre class="line-numbers language-none"><code class="language-none">
2.   可以省略类型说明符，因为编译器可以根据变量的值来推断其类型

3.   &#96;&#96;&#96;go
     const b string &#x3D; &quot;abc&quot; &#x2F;&#x2F;显示声明
     const b &#x3D; &quot;abc&quot; &#x2F;&#x2F;隐式声明<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  常量可以用作枚举</p>
</li>
<li><p>```go<br>  const (</p>
<pre><code>  Unknown = 0
  Female = 1
  Male = 2
</code></pre>
<p>  )</p>
  <pre class="line-numbers language-none"><code class="language-none">
6.   常量表达式中，函数必须是内置函数，否则编译不过

7.   &#96;&#96;&#96;go
     const (
     	a &#x3D; &quot;abc&quot;
     	b &#x3D; len(a)
     	c &#x3D; unsafe.Sizeof(a)
     )<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="特殊常量-iota"><a href="#特殊常量-iota" class="headerlink" title="特殊常量 iota"></a>特殊常量 iota</h3><ol>
<li><p>  iota，特殊常量，可以认为是一个可以被编译器修改的常量。</p>
</li>
<li><p>  iota 在 const关键字出现时将被重置为 0(const 内部的第一行之前)，const 中每新增一行常量声明将使 iota 计数一次(iota 可理解为 const 语句块中的行索引)。</p>
</li>
<li><p>  第一个 iota 等于 0，每当 iota 在新的一行被使用时，它的值都会自动加 1</p>
</li>
<li><p>```go<br>  package main</p>
<p>  import “fmt”</p>
<p>  func main() {</p>
<pre><code>  const (
          a = iota   //0
          b          //1
          c          //2
          d = &quot;ha&quot;   //独立值，iota += 1
          e          //&quot;ha&quot;   iota += 1
          f = 100    //iota +=1
          g          //100  iota +=1
          h = iota   //7,恢复计数
          i          //8
  )
  fmt.Println(a,b,c,d,e,f,g,h,i)
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   我的理解：**第一个iota为0，每更新一行时，iota会自动+1,如果遇到了String类型的数据，String的值不会改变**，在const中枚举，如果重新给某个变量进行了赋值，则会自动摒弃iota

## 左右移

1.   ![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20220924104333.png)
2.   左移为 * 2的n次方
3.   右移为 &#x2F; 2的n次方

## go语言条件语句

1.   go没有三目运算符，所以不支持 **?:** 形式的条件判断
2.   go所有的二目运算符都是从左向右执行的
3.   select语句，如果有多个case都可以执行，select会随机公平地选出一个执行，其它的不会执行
4.   如果有default子句，则执行该语句
5.   如果没有default子句，select将阻塞，直到某个通信可以运行；go不会重新对channel或值进行求值

## 循环

1.   for-each循环的**第一个元素肯定是下标，第二个元素才是值**

2.   &#96;&#96;&#96;go
     for i,s :&#x3D; range strings<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  <strong>使用range关键字</strong></p>
</li>
</ol>
<h2 id="循环中的goto语句"><a href="#循环中的goto语句" class="headerlink" title="循环中的goto语句"></a>循环中的goto语句</h2><ol>
<li>  goto语句可以无条件地转移到过程中指定的行</li>
<li>  goto语句通常与条件语句配合使用，可用来实现条件转移， 构成循环，跳出循环体等功能</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220924110303.png"></li>
<li>  goto loop</li>
</ol>
<h2 id="go语言数组"><a href="#go语言数组" class="headerlink" title="go语言数组"></a>go语言数组</h2><ol>
<li><p>  等号右边先定义维度，然后定义类型，最后来个大括号</p>
</li>
<li><p>  全看：var 数组名 = [size] type {}</p>
</li>
<li><p>```go<br>  var variable_name [SIZE] variable_type</p>
  <pre class="line-numbers language-none"><code class="language-none">
2.   &#96;&#96;&#96;go
     var balance [10] float32 &#x2F;&#x2F;var 数组名 [size] 类型<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span></span></code></pre></li>
<li><p>  初始化，等号，大括号</p>
</li>
<li><p>```go<br>  var balance = [5]float{1,2,3,4,5}</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   也可以通过字面量在声明数组的同时快速初始化数组

6.   &#96;&#96;&#96;go
     var balance :&#x3D; [5]float&#123;1,2,3,4,5&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  在初始化数组时，如果长度不确定，可以使用 <strong>…</strong> 来代替数组的长度，编译器会根据元素的个数自动推断数组的个数</p>
</li>
<li><p>```go<br>  var balance = […]float{1,2,3,4}<br>  balance := […]float{1,2,3,4,5}</p>
  <pre class="line-numbers language-none"><code class="language-none">
9.   注意，变量的类型一定在变量名的后面

### 多维数组

&#96;&#96;&#96;gp
var variable_name [1][2][3] variable_type
var threedim [1][2][3]int<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  初始化二维数组</p>
</li>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20220924194448.png"></p>
</li>
<li><p>  如果最后一个元素和结尾的 <strong>}</strong> 不位于同一行，则需要最后元素后添加一个逗号</p>
</li>
<li><p>  如果位于同一行，则可以不带逗号</p>
</li>
<li><p>  总之，最后一行的 <strong>}</strong> 不能单独一行</p>
</li>
</ol>
<h2 id="go指针"><a href="#go指针" class="headerlink" title="go指针"></a>go指针</h2><ol>
<li>  当一个指针被定义后没有分配到任何变量时，它的值为 <strong>nil</strong></li>
<li>  nil指针也被称为空指针</li>
<li>  指针数组存地址，令每一个元素都指向一个值</li>
</ol>
<h2 id="结构体"><a href="#结构体" class="headerlink" title="结构体"></a>结构体</h2><ol>
<li><p>  type和struct关键字，type语句设定了结构体的名称</p>
</li>
<li><p>```go<br>  type name struct {</p>
<pre><code>  member definition
  member
  member
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   变量的声明

4.   &#96;&#96;&#96;go
     variable_name :&#x3D; structure_variable_name &#123;value1,value2,value3&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  当定义结构体时，不一定需要使用某个结构体中的所有属性，即可以有几个属性不带</p>
</li>
</ol>
<h2 id="go语言切片"><a href="#go语言切片" class="headerlink" title="go语言切片"></a>go语言切片</h2><ol>
<li><p>  数组长度不可改变，但是切片的长度是可以改变的，而已追加元素，在追加时可能使切片的容量增大</p>
</li>
<li><p>```go<br>  var identifier []type //声明一个未指定大小的数组来定义切片，不建议使用<br>  //或者使用make()函数来创建切片<br>  var slice1 []type = make([]type,len)<br>  slice1 := make([]type,len)<br>  //也可以指定容量，其中capacity为可选参数<br>  make([]T,length,capacity)</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   切片就是没有指定长度的数组

### 获取数组中的值

&#96;&#96;&#96;go 
b :&#x3D; a[:] &#x2F;&#x2F;获取数组中的所有值，这也是基于数组的切片定义，此时b是一个切片而不是数组，b没有长度限制<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  获取切片的值是前包后不包的，即 <strong>[1:4]</strong> 的取值实际上是1~3</p>
</li>
</ol>
<h3 id="获取切片的长度和容量"><a href="#获取切片的长度和容量" class="headerlink" title="获取切片的长度和容量"></a>获取切片的长度和容量</h3><ol>
<li>  len()函数来获取切片的长度</li>
<li>  cap()函数来获取切片的容量</li>
<li>  <strong>切片容量是从它的第一个元素开始数，到其底层数组元素末尾的个数，如果是基于数组的，就是到其数组的最后一个位置，即使限定了最后的下标[,end]</strong></li>
<li>  <strong>切片的长度就是它所包含的元素个数</strong></li>
</ol>
<h3 id="用make函数创建切片"><a href="#用make函数创建切片" class="headerlink" title="用make函数创建切片"></a>用make函数创建切片</h3><ol>
<li><p>```go<br>  make([]T,len,cap)</p>
  <pre class="line-numbers language-none"><code class="language-none">
2.   第一个参数是类型，第二个参数是长度，第三个长度是容量



### 切片扩容

1.   使用go语言内置函数，append()可以为切片动态添加元素，每个切片会指向一个底层数组
2.   append()等号前写用哪个变量去接收，append()的第一个参数写地址，第二个参数是添加的值

### 切片合并

1.   append(sliceA,sliceB...)

2.   第一个参数是加到哪里，第二个参数是用什么加，第二个参数后面会自动加上 **...**

3.   &#96;&#96;&#96;go
     	sliceA :&#x3D; []string&#123;&quot;php&quot;,&quot;java&quot;&#125;
     	sliceB :&#x3D; []string&#123;&quot;nodejs&quot;,&quot;go&quot;&#125;
     
  sliceA &#x3D; append(sliceA,sliceB...) &#x2F;&#x2F;注意这个地方是重新赋值，而不需要声明，因此不用 :&#x3D; ,用 &#x3D; ，另外，要在用于扩容的数组后面加上三个点
     	fmt.Println(sliceA)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  上面这个例子是将sliceB合并到sliceA的后面，然后重新赋值给sliceA</p>
</li>
</ol>
<h3 id="切片是一种引用类型，如果想要不同时改变，则使用copy-函数"><a href="#切片是一种引用类型，如果想要不同时改变，则使用copy-函数" class="headerlink" title="切片是一种引用类型，如果想要不同时改变，则使用copy()函数"></a>切片是一种引用类型，如果想要不同时改变，则使用copy()函数</h3><ol>
<li><p>  copy()函数是赋值，而不会发生引用</p>
</li>
<li><p>  即使用copy()函数不会同时修改sliceA和sliceB</p>
</li>
<li><p>```go<br>  package main</p>
<p>  import “fmt”</p>
<p>  func main() {</p>
<pre><code>  sliceA := []int&#123;1,2,3,4,5&#125;
  sliceB := make([]int,5,6) //第一个参数是被赋值，第二个参数是用什么去赋值，copy(被赋值，用什么去赋值);
  copy(sliceB,sliceA)

  fmt.Println(sliceA)
  fmt.Println(sliceB)
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
### 删除切片中的元素

&#96;&#96;&#96;go
a :&#x3D; []int&#123;1,2,3,4,5&#125;
a &#x3D; append(a[:2],a[3:]...)
&#x2F;&#x2F;和链表的删除操作思路相同，将一个切片分成两段，前一段和后一段之间是要shan&#39;ch<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="指针"><a href="#指针" class="headerlink" title="指针"></a>指针</h2><h3 id="声明"><a href="#声明" class="headerlink" title="声明"></a>声明</h3><ol>
<li>```go<br>  var var_name *var_type<br>  var ip *int<br>  var fp *float32  <pre class="line-numbers language-none"><code class="language-none">
### 指针数组

&#96;&#96;&#96;go
package main

import &quot;fmt&quot;

const MAX int &#x3D; 4

func main() &#123;
	a :&#x3D; []int&#123;0,1,2,3&#125;
	var i int
	var ptr [MAX]*int

	for i &#x3D; 0;i &lt; MAX;i++ &#123;
		ptr[i] &#x3D; &amp;a[i]
	&#125;

	for i &#x3D; 0;i &lt; MAX; i++ &#123;
		fmt.Printf(&quot;a[%d] &#x3D; %d&quot;,i,*ptr[i])
	&#125;
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="指针作为函数的参数"><a href="#指针作为函数的参数" class="headerlink" title="指针作为函数的参数"></a>指针作为函数的参数</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> a <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">100</span>
	<span class="token keyword">var</span> b <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">200</span>

	<span class="token function">swap</span><span class="token punctuation">(</span><span class="token operator">&amp;</span>a<span class="token punctuation">,</span><span class="token operator">&amp;</span>b<span class="token punctuation">)</span>

	fmt<span class="token punctuation">.</span><span class="token function">Println</span><span class="token punctuation">(</span>a<span class="token punctuation">,</span>b<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span>

<span class="token keyword">func</span> <span class="token function">swap</span><span class="token punctuation">(</span>x <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">,</span>y <span class="token operator">*</span><span class="token builtin">int</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token operator">*</span>x<span class="token punctuation">,</span><span class="token operator">*</span>y <span class="token operator">=</span> <span class="token operator">*</span>y<span class="token punctuation">,</span><span class="token operator">*</span>x
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h2 id="结构体-1"><a href="#结构体-1" class="headerlink" title="结构体"></a>结构体</h2><h3 id="定义结构体"><a href="#定义结构体" class="headerlink" title="定义结构体"></a>定义结构体</h3><ol>
<li>```go<br>  type struct_variable_type struct {<pre><code>  member definition
  member definition
</code></pre>
  }  <pre class="line-numbers language-none"><code class="language-none">
2.   忽略的字段将为0或者为空

3.   也可以使用 key&#x3D;&gt;value 的形式,使用键值对的形式可以不用按照顺序去定义

4.   &#96;&#96;&#96;go
     Books&#123;title: &quot;&quot;,author: &quot;&quot;,subject: &quot;&quot;,book_id: &quot;&quot;&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="结构体作为函数的参数"><a href="#结构体作为函数的参数" class="headerlink" title="结构体作为函数的参数"></a>结构体作为函数的参数</h3><pre class="line-numbers language-none"><code class="language-none">func printBook(book Books) &#123;
	fmt.Printf(book.title)
&#125;

func name(var_name var_type) &#123;
	fmt.Printf(var_name.value)
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>



<h3 id="结构体指针"><a href="#结构体指针" class="headerlink" title="结构体指针"></a>结构体指针</h3><ol>
<li><p>```go<br>  var struct_pointer *Books<br>  //使用指针变量存储结构体变量的地址<br>  struct_pointer = &amp;Book1<br>  //使用结构体指针访问结构体成员<br>  struct_pointer.title</p>
  <pre class="line-numbers language-none"><code class="language-none">


## 范围range

1.   range用于for循环中迭代数组，切片，通道，集合元素

2.   数组和切片中它返回元素的索引和对应的值，在集合中返回key-value对

3.   &#96;&#96;&#96;go
     for key,value :&#x3D; range oldMap &#123;
     	newMap[key] &#x3D; value
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  for循环的range可以省略key和value</p>
</li>
<li><p>```go<br>  package main</p>
<p>  import “fmt”</p>
<p>  func main() {</p>
<pre><code>  map1 := make(map[int]float32)
  map1[1] = 1.0
  map1[2] = 2.0
  
  for key,value := range map1 &#123;
      fmt.Printf(&quot;key: %d,value %f&quot;,key,value)
  &#125;
  
  for key := range map1 &#123;
      fmt.Printf(&quot;key is: %d&quot;,key)
  &#125;
  
  for _,value := range map1 &#123;
      fmt.Printf(&quot;value is: %f&quot;,value)
  &#125;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
## map集合

1.   无序的键值对的集合

2.   可以通过key来快速地检索数据，类似于索引，指向数据的值

3.   map是一种集合，可以进行迭代，但是是无序的，无法决定它的返回顺序，因为map是通过hash来实现的

4.   &#96;&#96;&#96;go
     package main
     
     import &quot;fmt&quot;
     
     func main() &#123;
         var countryCapitalMap map[string]string &#x2F;&#x2F;map的声明: map[键的类型]值的类型
     	countryCapitalMap &#x3D; make(map[string]string)
     
     	countryCapitalMap [&quot;france&quot;] &#x3D; &quot;巴黎&quot;
     	countryCapitalMap [ &quot;Italy&quot; ] &#x3D; &quot;罗马&quot;
         countryCapitalMap [ &quot;Japan&quot; ] &#x3D; &quot;东京&quot;
         countryCapitalMap [ &quot;India &quot; ] &#x3D; &quot;新德里&quot;
     
     	for country :&#x3D; range countryCapitalMap &#123;
     		fmt.Println(country)
     	&#125;
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="delete函数"><a href="#delete函数" class="headerlink" title="delete函数"></a>delete函数</h3><ol>
<li><p>  delete函数用于删除集合的元素，参数为map和其对应的key</p>
</li>
<li><p>```go<br>  delete(map_name,key)<br>  delete(map_name,key)</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   &#96;&#96;&#96;go
     package main
     
     import &quot;fmt&quot;
     
     func main() &#123;
     	countryCapitalMap :&#x3D; map[string]string&#123;&quot;France&quot;: &quot;Paris&quot;, &quot;Italy&quot;: &quot;Rome&quot;, &quot;Japan&quot;: &quot;Tokyo&quot;, &quot;India&quot;: &quot;New delhi&quot;&#125;
     	fmt.Println(&quot;原始地图&quot;)
     
     	for country :&#x3D; range countryCapitalMap &#123;
     		fmt.Println(country,&quot;首都是&quot;,countryCapitalMap[country])
     	&#125;
     
     	delete(countryCapitalMap,&quot;France&quot;)
     
     	fmt.Println()
     
     	for country :&#x3D; range countryCapitalMap &#123;
     		fmt.Println(country,&quot;首都是&quot;,countryCapitalMap[country])
     	&#125;
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="go语言递归"><a href="#go语言递归" class="headerlink" title="go语言递归"></a>go语言递归</h3><ol>
<li><p>  递归，在运行的过程中调用自己</p>
</li>
<li><p>```go<br>  func recursion() {</p>
<pre><code>  recursion()
</code></pre>
<p>  }<br>  func main() {</p>
<pre><code>  recursion()
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   &#96;&#96;&#96;go
     package main
     
     import &quot;fmt&quot;
     
     func fib(n int) int&#123;
     	if n &lt; 2 &#123;
     		return n
     	&#125;
     	return fib(n-2)*(n-1)
     &#125;
     
     func main() &#123;
     	var i int
     	for i &#x3D; 0;i &lt; 10;i++ &#123;
     		fmt.Printf(&quot;%d\t&quot;,fib(i))
     	&#125;
     &#125;
     &#x2F;&#x2F;斐波那契数列<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="go语言类型转换"><a href="#go语言类型转换" class="headerlink" title="go语言类型转换"></a>go语言类型转换</h3><pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token function">type_name</span><span class="token punctuation">(</span>expression<span class="token punctuation">)</span>
<span class="token comment">//expression中填变量的名字</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span></span></code></pre>

<pre class="line-numbers language-go" data-language="go"><code class="language-go"><span class="token keyword">package</span> main

<span class="token keyword">import</span> <span class="token string">"fmt"</span>

<span class="token keyword">func</span> <span class="token function">main</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">&#123;</span>
	<span class="token keyword">var</span> sum <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">17</span>
	<span class="token keyword">var</span> count <span class="token builtin">int</span> <span class="token operator">=</span> <span class="token number">5</span>
	<span class="token keyword">var</span> mean <span class="token builtin">float32</span>

	mean <span class="token operator">=</span> <span class="token function">float32</span><span class="token punctuation">(</span>sum<span class="token punctuation">)</span><span class="token operator">/</span><span class="token function">float32</span><span class="token punctuation">(</span>count<span class="token punctuation">)</span>
	fmt<span class="token punctuation">.</span><span class="token function">Printf</span><span class="token punctuation">(</span><span class="token string">"mean的值为 %f"</span><span class="token punctuation">,</span>mean<span class="token punctuation">)</span>
<span class="token punctuation">&#125;</span><span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre>

<ol>
<li>  <strong>go不支持隐式类型转换</strong>，必须进行显示类型转换，否则会报错</li>
<li>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20221006211522.png"></li>
</ol>
<h2 id="go语言接口"><a href="#go语言接口" class="headerlink" title="go语言接口"></a>go语言接口</h2><ol>
<li><p>  将所有具有共性的方法定义在一起，任何其它类型只要实现了这些（全部）方法就是实现了这个接口</p>
</li>
<li><p>```go<br>  type interface_name interface {</p>
<pre><code>  method_name1 [return_type]
  method_name2 [return_type]
</code></pre>
<p>  }</p>
<p>  func (struct_name_variable struct_name) method_name1() [return_type]}{</p>
<pre><code>  //方法实现
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   &#96;&#96;&#96;go
     package main
     
     import &quot;fmt&quot;
     
     type Phone interface &#123;
     	call()
     &#125;
     
     type NokiaPhone struct &#123;
     &#125;
     
     func (nokiaPhone NokiaPhone) call() &#123;
     	fmt.Println(&quot;abc&quot;)
     &#125;
     
     type IPhone struct &#123;
     &#125;
     
     func (iphone IPhone) call() &#123;
     	fmt.Println(&quot;def&quot;)
     &#125;
     
     func main() &#123;
     	var phone Phone
     
     	phone &#x3D; new(NokiaPhone)
     	phone.call()
     
     	phone &#x3D; new(IPhone)
     	phone.call()
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="go并发"><a href="#go并发" class="headerlink" title="go并发"></a>go并发</h2><ol>
<li><p>  go语言支持并发，只需要通过关键字go来开启goroutine即可</p>
</li>
<li><p>  goroutine是轻量级线程，goroutine的调度是由golang运行时进行管理的</p>
</li>
<li><p>```go<br>  go 函数名(参数列表)<br>  go f(x,y,z)</p>
  <pre class="line-numbers language-none"><code class="language-none">
4.   go允许使用go语句开启一个新的运行期线程，即goroutine,以一个不同的，新创建的goroutine来执行一个函数

5.   同一个程序中所有的goroutine共享同一个地址空间

6.   &#96;&#96;&#96;go
     package main
     
     import (
     	&quot;fmt&quot;
     	&quot;time&quot;
     )
     
     func say(s string) &#123;
     	for i :&#x3D; 0;i &lt; 5;i++ &#123;
     		time.Sleep(100 * time.Millisecond)
     		fmt.Println(s)
     	&#125;
     &#125;
     
     func main() &#123;
     	go say(&quot;world&quot;)
     	say(&quot;hello&quot;)
     &#125;
     &#x2F;&#x2F;这个程序中输出的hello和world没有固定的顺序，因为是两个goroutine在执行<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h3 id="通道"><a href="#通道" class="headerlink" title="通道"></a>通道</h3><ol>
<li><p>  channel是用来传输数据的一个数据结构</p>
</li>
<li><p>  通道可以用于两个goroutine之间通过传递一个指定类型的值来同步运行和通讯</p>
</li>
<li><p>  操作符 <strong>&lt;-</strong> 用于指定通道的方向，发送或接收，如果没有指定方向，则为双向通道</p>
</li>
<li><p>```<br>  ch &lt;- v //把v发送到通道ch<br>  v := &lt;- ch //从ch接收数据，并把值赋给v</p>
  <pre class="line-numbers language-none"><code class="language-none">
### 通道的声明

&#96;&#96;&#96;go
ch :&#x3D; make(chan int)
&#x2F;&#x2F;通道的声明使用chan关键字，在声明之前必须先创建<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  默认情况下，<strong>通道是不带缓冲区的</strong>，发送端发送数据，同时<strong>必须有接收端相应的接收数据</strong></p>
</li>
<li><p>```go<br>  package main</p>
<p>  import “fmt”</p>
<p>  func sum(s []int,c chan int) {</p>
<pre><code>  sum := 0
  for _,v := range s &#123;
      sum += v
  &#125;
  c &lt;- sum //将sum发送到通道c
</code></pre>
<p>  }</p>
<p>  func main() {</p>
<pre><code>  s := []int&#123;7, 2, 8, -9, 4, 0&#125;
  
  c := make(chan int)
  go sum(s[:len(s)/2],c)
  go sum(s[len(s)/2:],c)
  x , y := &lt;-c,&lt;-c

  fmt.Println(x,y,x+y)
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
### 通道缓冲区

1.   &#96;&#96;&#96;go
     ch :&#x3D; make(chan int,100)
     &#x2F;&#x2F;通道可以设置缓冲区，通过make的第二个参数指定缓冲区的大小<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  带缓冲区的通道允许发送端的数据发送和接收端的数据获取处于异步状态，就是说发送端发送的数据可以放在缓冲区中，可以等待接收端去获取数据，而不是立刻需要接收端去获取数据</p>
</li>
<li><p>  不过由于缓冲区的大小是有限的，还是需要有接收端来接收数据，否则缓冲区一满，数据发送端就无法再发送数据了</p>
</li>
</ol>
<h2 id="const和iota"><a href="#const和iota" class="headerlink" title="const和iota"></a>const和iota</h2><ol>
<li><p>  和定义变量类似，就是<strong>将定义变量时的var关键字替换为const关键字</strong></p>
</li>
<li><p>```<br>   package main</p>
<p>   import “fmt”</p>
<p>   func main() {</p>
<pre><code>   const length int = 10
   fmt.Println(&quot;length = &quot;,length)
   
</code></pre>
<p>   }</p>
   <pre class="line-numbers language-none"><code class="language-none">
## 一个函数有多个返回值

&#96;&#96;&#96;go
package main

import &quot;fmt&quot;

&#x2F;&#x2F;返回多个返回值，匿名的
func foo(a string,b int) (string , int) &#123;
	fmt.Println(&quot;a&#x3D;&quot;,a)
	fmt.Println(&quot;b&#x3D;&quot;,b)

	return a,b
&#125;

&#x2F;&#x2F;返回多个返回值，有形参名称的
func foo3(a string,b int) (r1 int,r2 int) &#123;
	fmt.Println(&quot;-----foo3-----&quot;)
	fmt.Println(&quot;a&#x3D; &quot;,a)
	fmt.Println(&quot;b&#x3D; &quot;,b)

	&#x2F;&#x2F;给有名称的返回值变量赋值
	r1 &#x3D; 1000
	r2 &#x3D; 2000

	return r1,r2
&#125;

func foo4(a string,b int) (r1,r2 int) &#123;
	fmt.Println(&quot;-----foo4------&quot;)
	fmt.Println(&quot;a&#x3D; &quot;,a)
	fmt.Println(&quot;b&#x3D; &quot;,b)

	&#x2F;&#x2F;给有名称的返回值变量赋值
	r1&#x3D;1000
	r2&#x3D;2000
	return r1,r2
&#125;

func main() &#123;
	ret1 ,ret2 :&#x3D; foo(&quot;abc&quot;,100);
	fmt.Println(&quot;ret1:&quot;,ret1,&quot;ret2:&quot;,ret2)

	ret3 , ret4 :&#x3D; foo3(&quot;foo3&quot;,333)
	fmt.Println(&quot;ret3 &#x3D; &quot;,ret3,&quot;ret4 &#x3D; &quot;,ret4)

	ret5,ret6 :&#x3D; foo
&#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="导包的路径问题和init方法调用"><a href="#导包的路径问题和init方法调用" class="headerlink" title="导包的路径问题和init方法调用"></a>导包的路径问题和init方法调用</h2><p><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20221008100203.png"></p>
<h2 id="import匿名及别名导包方式"><a href="#import匿名及别名导包方式" class="headerlink" title="import匿名及别名导包方式"></a>import匿名及别名导包方式</h2><h3 id="匿名导包"><a href="#匿名导包" class="headerlink" title="匿名导包"></a>匿名导包</h3><ol>
<li><p>  想<strong>调用这个包的init()函数</strong>，但是<strong>不想使用这个包的接口的需求</strong></p>
</li>
<li><p>  这种需求就可以使用匿名导入方式**(这种方法类似于起别名)**</p>
</li>
<li><p>  就可以在<strong>导入的包的前面加上下划线，空格</strong></p>
</li>
<li><p>```<br>  import _ “GolangStudy/S-init/lib1”</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   **此时无法使用当前包的方法，但是会执行当前包内部的init方法**

### 别名导包

1.   在包的名字前面加上包的别名，即可使用别名，不使用包原来的名字

2.   &#96;&#96;&#96;go
     mylib2 &quot;GolangStudy&#x2F;S-init&#x2F;lib2&quot;
     &#x2F;&#x2F;在main函数中可以使用别名进行调用
     mylib2.Lib2Test();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  在包的名字前面加上点，空格，就可以不使用包的名字，直接使用包内部的函数</p>
</li>
<li><p>```go<br>  . “GolangStudy/S-init/lib2”<br>  Lib2Test();</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   这种点的导入方式尽量不要使用，可能会有同名函数起冲突

6.   ![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20221008103242.png)

## go语言的析构函数

1.   go语言的析构函数关键字是defer

2.   &#96;&#96;&#96;go
     defer fmt.Println(&quot;一个函数体中允许有多个析构函数，调用顺序是从上到下&quot;); &#x2F;&#x2F;这样会在函数体的结束调用这个析构函数
     defer fmt.Println();<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  在函数的前面添加defer关键字即为析构函数</p>
</li>
</ol>
<h3 id="defer和return的调用先后问题"><a href="#defer和return的调用先后问题" class="headerlink" title="defer和return的调用先后问题"></a>defer和return的调用先后问题</h3><ol>
<li>  defer是当前函数的生命周期全部结束之后才会被调用，才会出栈</li>
<li>  调用顺序是先调用return,在函数的生命周期结束之后才会调用defer</li>
<li>  书写顺序是先书写defer，然后再书写return,类似于c++</li>
</ol>
<h2 id="给一个结构体绑定方法"><a href="#给一个结构体绑定方法" class="headerlink" title="给一个结构体绑定方法"></a>给一个结构体绑定方法</h2><ol>
<li><p>  给一个结构体绑定方法，一定要用指针</p>
</li>
<li><p>```go<br>  func (this *Hero) Show(){}</p>
  <pre class="line-numbers language-none"><code class="language-none">
3.   ![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20221008171748.png)

## go语言方法

![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20221015100204.png)

1.   方法是**作用在指定的数据类型上**的，**和指定的数据类型绑定**，因此**自定义类型都可以拥有方法**

2.   &#96;&#96;&#96;go
     type A struct &#123;
     	Num int;
     &#125;
     func (a A) test()&#123; &#x2F;&#x2F;中间的(a A)表示这个方法是绑定到A结构体上的，类似于成员方法（A这个类的成员方法）
     	fmt.Println(a.Num);
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  这个方法是和某个对象绑定的，所以通过某个对象来调用</p>
</li>
<li><p>```go<br>  package main</p>
<p>  import (</p>
<pre><code>  &quot;fmt&quot;
</code></pre>
<p>  )</p>
<p>  type Person struct {</p>
<pre><code>  Name string
</code></pre>
<p>  }</p>
<p>  func (p Person) test() { //这个方法是绑定到Person类的</p>
<pre><code>  fmt.Printf(&quot;test() name=%s&quot;,p.Name)
</code></pre>
<p>  }</p>
<p>  func main() {</p>
<pre><code>  var p Person
  p.Name = &quot;tom&quot;
  p.test() //所以要通过Person类的实例进行调用,不能直接test()直接调用，也不能使用其它类型的变量来调用
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
5.   func (p Person) test()&#123;&#125; ...p表示哪个Person变量调用，这个p就是它的副本，这点和函数传参（引用）非常相似

6.   p这个名字，由程序员指定，不是固定

## go语言错误处理

1.   通过内置的错误接口提供了简单的错误处理机制

2.   error类型是一个接口类型

3.   &#96;&#96;&#96;go
     type error interface &#123;
     	Error() string
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  可以在编码中通过实现error接口类型来生成错误信息</p>
</li>
<li><p>  函数通常在最后的返回值中返回错误信息，使用errors.New可以返回一个错误信息</p>
</li>
<li><p>```go<br>  func Sqrt(f float64) (float64,error) {</p>
<pre><code>  if f &lt; 0 &#123;
      return 0,errors.New(&quot;math:square root of negative number&quot;)
  &#125;
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
## go语言创建对象的方式

1.   使用T&#123;...&#125;方式，结果为值类型

2.   使用new的方式，结果为指针类型

3.   使用&amp;方式，结果为指针类型

4.   &#96;&#96;&#96;go
     c3 :&#x3D; &amp;Car&#123;
     	color:&quot;红色&quot;
     	length:&quot;10&quot;
     &#125;&#x2F;&#x2F;使用&amp;进行对象的创建，使用冒号进行赋值<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
</ol>
<h2 id="go语言高并发"><a href="#go语言高并发" class="headerlink" title="go语言高并发"></a>go语言高并发</h2><h3 id="通道-1"><a href="#通道-1" class="headerlink" title="通道"></a>通道</h3><ol>
<li><p>  通道channel是用来传递数据的一个数据结构</p>
</li>
<li><p>  可以用于两个goroutine之间通过传递一个指定类型的值来实现同步运行和通讯，&lt;-用来指定通道的方向，发送或接受数据，如果没有指定方向，则为双向通道</p>
</li>
<li><p>  声明一个通道使用chan关键字，通道在使用前必须先创建</p>
</li>
<li><p>```go<br>  ch := make(chan int)</p>
  <pre class="line-numbers language-none"><code class="language-none">
## 复习

### channel定义

1.   channel : make(chan 类型，容量)

2.   &#96;&#96;&#96;
     ch :&#x3D; make(chan string)<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  写端：ch &lt;- “hehe” ,写端写数据，读端不再读，写端阻塞</p>
</li>
<li><p>  读端：str := &lt;- ch , 读端读数据，同时写端不在写，读端阻塞</p>
</li>
<li><p>  通道中的数据只能读取一次，不能多次重复读取，读完就消失</p>
</li>
</ol>
<h3 id="有缓冲通道：同步通信"><a href="#有缓冲通道：同步通信" class="headerlink" title="有缓冲通道：同步通信"></a>有缓冲通道：同步通信</h3><h3 id="无缓冲通道：异步通信"><a href="#无缓冲通道：异步通信" class="headerlink" title="无缓冲通道：异步通信"></a>无缓冲通道：异步通信</h3><pre class="line-numbers language-none"><code class="language-none">ch :&#x3D; make(chan int,5)<span aria-hidden="true" class="line-numbers-rows"><span></span></span></code></pre>

<ol>
<li>  len(ch):channel中<strong>剩余未读取数据</strong>的个数</li>
<li>  cap(ch):<strong>通道的容量</strong></li>
</ol>
<h3 id="关闭channel"><a href="#关闭channel" class="headerlink" title="关闭channel"></a>关闭channel</h3><ol>
<li><p>  写和读是两个不同的goroutine,当确定不再继续向对端发送数据时，关闭channel,使用close(ch)关闭channel</p>
</li>
<li><p>  如果写端关闭，读端再去读，就会读到一个0/nil，类似于EOF，此时就需要去关闭channel</p>
</li>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20221108211902.png"></p>
</li>
<li><p>  对端可以判断channel是否关闭</p>
</li>
<li><p>```go<br>  if num,ok := &lt;- ch;ok == true{</p>
<pre><code>  //如果对端已经关闭，ok==false，num无数据
  //如果对端没有关闭，ok==true，num保存读到的数据
</code></pre>
<p>  }</p>
  <pre class="line-numbers language-none"><code class="language-none">
6.   可以使用range来替代ok

7.   &#96;&#96;&#96;go
     for num :&#x3D; range ch &#123;
     &#x2F;&#x2F;和循环遍历类似，ch不能替换为&lt;-
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20221108212359.png"></p>
</li>
<li><p>  关闭的channel不能再向其中写数据，但是可以从中读取数据</p>
</li>
</ol>
<h3 id="生产者消费者模型"><a href="#生产者消费者模型" class="headerlink" title="生产者消费者模型"></a>生产者消费者模型</h3><ol>
<li><p>  <img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/20221108213838.png"></p>
</li>
<li><p>```go<br>  package main</p>
<p>  import “fmt”</p>
<p>  func producer(out chan &lt;- int,a int) {</p>
<pre><code>  out &lt;- a
  fmt.Println(&quot;生产者提供数据&quot;,a)
  close(out)
</code></pre>
<p>  }</p>
<p>  func consumer(in &lt;- chan int){</p>
<pre><code>  for data := range in&#123;
      fmt.Println(&quot;消费者得到数据&quot;,data)
  &#125;
</code></pre>
<p>  }</p>
<p>  func main() {</p>
<pre><code>  ch := make(chan int,5)

  go producer(ch,5)
  consumer(ch)
</code></pre>
<p>  }<br>  //双向channel var ch chan int 没有箭头<br>  //单向写channel var sendCh chan &lt;- int  sendCh = make(chan &lt;- int) 可以理解为chan为写入对象或读出对象，写入channel chan &lt;- 读出channel &lt;- chan<br>  //单向读channel var recvCh &lt;- chan int   recvCh = make(&lt;- chan int)<br>  //双向channel可以任意转换为一种单向channel<br>  //单向channel不能转换为双向</p>
  <pre class="line-numbers language-none"><code class="language-none">
### 定时器

![](https:&#x2F;&#x2F;strongwillpro.oss-cn-beijing.aliyuncs.com&#x2F;img&#x2F;20221108214033.png)

1.   &#96;&#96;&#96;go
     type Timer struct &#123;
         
     &#125;<span aria-hidden="true" class="line-numbers-rows"><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span><span></span></span></code></pre></li>
<li></li>
</ol>
</article><div class="post-copyright"><div class="post-copyright__author"><span class="post-copyright-meta"><i class="fas fa-circle-user fa-fw"></i>文章作者: </span><span class="post-copyright-info"><a href="https://strongwill.top">h3110w0r1d</a></span></div><div class="post-copyright__type"><span class="post-copyright-meta"><i class="fas fa-square-arrow-up-right fa-fw"></i>文章链接: </span><span class="post-copyright-info"><a href="https://strongwill.top/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/">https://strongwill.top/go%E8%AF%AD%E8%A8%80%E8%AF%AD%E6%B3%95/</a></span></div><div class="post-copyright__notice"><span class="post-copyright-meta"><i class="fas fa-circle-exclamation fa-fw"></i>版权声明: </span><span class="post-copyright-info">本博客所有文章除特别声明外，均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/" target="_blank">CC BY-NC-SA 4.0</a> 许可协议。转载请注明来自 <a href="https://strongwill.top" target="_blank">h3110w0r1d's Blog</a>！</span></div></div><div class="tag_share"><div class="post-meta__tag-list"><a class="post-meta__tags" href="/tags/go/">go</a></div><div class="post_share"><div class="social-share" data-image="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/QQ图片20240111033823.jpg" data-sites="facebook,twitter,wechat,weibo,qq"></div><link rel="stylesheet" href="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/css/share.min.css" media="print" onload="this.media='all'"><script src="https://cdn.jsdelivr.net/npm/butterfly-extsrc@1.1.3/sharejs/dist/js/social-share.min.js" defer></script></div></div><nav class="pagination-post" id="pagination"><div class="prev-post pull-left"><a href="/%E8%BF%8E%E6%96%B0%E8%B5%9B%E9%A2%98%E8%A7%A3/" title="迎新赛题解"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">上一篇</div><div class="prev_info">迎新赛题解</div></div></a></div><div class="next-post pull-right"><a href="/%E5%8F%96%E6%B6%88%E8%BA%AB%E4%BB%BD%E8%AE%A4%E8%AF%81%E6%94%BB%E5%87%BB/" title="取消身份认证攻击"><div class="cover" style="background: var(--default-bg-color)"></div><div class="pagination-info"><div class="label">下一篇</div><div class="next_info">取消身份认证攻击</div></div></a></div></nav><div class="relatedPosts"><div class="headline"><i class="fas fa-thumbs-up fa-fw"></i><span>相关推荐</span></div><div class="relatedPosts-list"><div><a href="/go_downloader/" title="go_downloader"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-28</div><div class="title">go_downloader</div></div></a></div><div><a href="/go%E7%88%AC%E8%99%AB%E9%A1%B9%E7%9B%AE/" title="go爬虫项目"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-11-04</div><div class="title">go爬虫项目</div></div></a></div><div><a href="/go%E8%AF%AD%E8%A8%80%E9%A1%B9%E7%9B%AE%E5%8F%8A%E5%85%B6%E9%85%8D%E7%BD%AE/" title="go语言项目及其配置"><div class="cover" style="background: var(--default-bg-color)"></div><div class="content is-center"><div class="date"><i class="far fa-calendar-alt fa-fw"></i> 2022-10-08</div><div class="title">go语言项目及其配置</div></div></a></div></div></div></div><div class="aside-content" id="aside-content"><div class="card-widget card-info"><div class="is-center"><div class="avatar-img"><img src="https://strongwillpro.oss-cn-beijing.aliyuncs.com/img/QQ图片20240111033823.jpg" onerror="this.onerror=null;this.src='/img/friend_404.gif'" alt="avatar"/></div><div class="author-info__name">h3110w0r1d</div><div class="author-info__description">CTF web手、Golang后端开发工程师 研究多线程高并发、渗透测试      Web安全</div></div><div class="card-info-data site-data is-center"><a href="/archives/"><div class="headline">文章</div><div class="length-num">106</div></a><a href="/tags/"><div class="headline">标签</div><div class="length-num">50</div></a><a href="/categories/"><div class="headline">分类</div><div class="length-num">70</div></a></div><a id="card-info-btn" target="_blank" rel="noopener" href="https://github.com/dezhoutorizhao?tab=repositories"><i class="fab fa-github"></i><span>Follow Me</span></a></div><div class="card-widget card-announcement"><div class="item-headline"><i class="fas fa-bullhorn fa-shake"></i><span>公告</span></div><div class="announcement_content">h3110w0r1d师傅又发布了新博客了，快去看看吧</div></div><div class="sticky_layout"><div class="card-widget" id="card-toc"><div class="item-headline"><i class="fas fa-stream"></i><span>目录</span><span class="toc-percentage"></span></div><div class="toc-content"><ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80"><span class="toc-number">1.</span> <span class="toc-text">go语言</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%89%B9%E7%82%B9"><span class="toc-number">1.1.</span> <span class="toc-text">特点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%AC%AC%E4%B8%80%E4%B8%AAgo%E8%AF%AD%E8%A8%80"><span class="toc-number">1.2.</span> <span class="toc-text">第一个go语言</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E5%9F%BA%E7%A1%80%E7%BB%84%E6%88%90"><span class="toc-number">1.3.</span> <span class="toc-text">go语言基础组成</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%90%84%E4%B8%AA%E9%83%A8%E5%88%86"><span class="toc-number">1.3.1.</span> <span class="toc-text">各个部分</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%89%A7%E8%A1%8Cgo"><span class="toc-number">1.4.</span> <span class="toc-text">执行go</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E8%87%AA%E5%8A%A8%E7%BC%96%E8%AF%91%E8%84%9A%E6%9C%AC"><span class="toc-number">1.5.</span> <span class="toc-text">自动编译脚本</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#Go-%E8%AF%AD%E8%A8%80%E7%9A%84%E7%A9%BA%E6%A0%BC"><span class="toc-number">1.6.</span> <span class="toc-text">Go 语言的空格</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E5%8F%98%E9%87%8F"><span class="toc-number">1.7.</span> <span class="toc-text">go语言变量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%80%BC%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.1.</span> <span class="toc-text">值类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B"><span class="toc-number">1.7.2.</span> <span class="toc-text">引用类型</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%B3%A8%E6%84%8F"><span class="toc-number">1.7.3.</span> <span class="toc-text">注意</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%AE%80%E7%9F%AD%E5%BD%A2%E5%BC%8F"><span class="toc-number">1.7.4.</span> <span class="toc-text">简短形式</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E5%B8%B8%E9%87%8F"><span class="toc-number">1.8.</span> <span class="toc-text">go语言常量</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%89%B9%E6%AE%8A%E5%B8%B8%E9%87%8F-iota"><span class="toc-number">1.8.1.</span> <span class="toc-text">特殊常量 iota</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%BE%AA%E7%8E%AF%E4%B8%AD%E7%9A%84goto%E8%AF%AD%E5%8F%A5"><span class="toc-number">1.9.</span> <span class="toc-text">循环中的goto语句</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E6%95%B0%E7%BB%84"><span class="toc-number">1.10.</span> <span class="toc-text">go语言数组</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E6%8C%87%E9%92%88"><span class="toc-number">1.11.</span> <span class="toc-text">go指针</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.12.</span> <span class="toc-text">结构体</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E5%88%87%E7%89%87"><span class="toc-number">1.13.</span> <span class="toc-text">go语言切片</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E8%8E%B7%E5%8F%96%E5%88%87%E7%89%87%E7%9A%84%E9%95%BF%E5%BA%A6%E5%92%8C%E5%AE%B9%E9%87%8F"><span class="toc-number">1.13.1.</span> <span class="toc-text">获取切片的长度和容量</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%A8make%E5%87%BD%E6%95%B0%E5%88%9B%E5%BB%BA%E5%88%87%E7%89%87"><span class="toc-number">1.13.2.</span> <span class="toc-text">用make函数创建切片</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%88%87%E7%89%87%E6%98%AF%E4%B8%80%E7%A7%8D%E5%BC%95%E7%94%A8%E7%B1%BB%E5%9E%8B%EF%BC%8C%E5%A6%82%E6%9E%9C%E6%83%B3%E8%A6%81%E4%B8%8D%E5%90%8C%E6%97%B6%E6%94%B9%E5%8F%98%EF%BC%8C%E5%88%99%E4%BD%BF%E7%94%A8copy-%E5%87%BD%E6%95%B0"><span class="toc-number">1.13.3.</span> <span class="toc-text">切片是一种引用类型，如果想要不同时改变，则使用copy()函数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E6%8C%87%E9%92%88"><span class="toc-number">1.14.</span> <span class="toc-text">指针</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%A3%B0%E6%98%8E"><span class="toc-number">1.14.1.</span> <span class="toc-text">声明</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%8C%87%E9%92%88%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.14.2.</span> <span class="toc-text">指针作为函数的参数</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93-1"><span class="toc-number">1.15.</span> <span class="toc-text">结构体</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%AE%9A%E4%B9%89%E7%BB%93%E6%9E%84%E4%BD%93"><span class="toc-number">1.15.1.</span> <span class="toc-text">定义结构体</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E4%BD%9C%E4%B8%BA%E5%87%BD%E6%95%B0%E7%9A%84%E5%8F%82%E6%95%B0"><span class="toc-number">1.15.2.</span> <span class="toc-text">结构体作为函数的参数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%BB%93%E6%9E%84%E4%BD%93%E6%8C%87%E9%92%88"><span class="toc-number">1.15.3.</span> <span class="toc-text">结构体指针</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#delete%E5%87%BD%E6%95%B0"><span class="toc-number">1.15.4.</span> <span class="toc-text">delete函数</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E9%80%92%E5%BD%92"><span class="toc-number">1.15.5.</span> <span class="toc-text">go语言递归</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E7%B1%BB%E5%9E%8B%E8%BD%AC%E6%8D%A2"><span class="toc-number">1.15.6.</span> <span class="toc-text">go语言类型转换</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E6%8E%A5%E5%8F%A3"><span class="toc-number">1.16.</span> <span class="toc-text">go语言接口</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E5%B9%B6%E5%8F%91"><span class="toc-number">1.17.</span> <span class="toc-text">go并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93"><span class="toc-number">1.17.1.</span> <span class="toc-text">通道</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#const%E5%92%8Ciota"><span class="toc-number">1.18.</span> <span class="toc-text">const和iota</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E5%AF%BC%E5%8C%85%E7%9A%84%E8%B7%AF%E5%BE%84%E9%97%AE%E9%A2%98%E5%92%8Cinit%E6%96%B9%E6%B3%95%E8%B0%83%E7%94%A8"><span class="toc-number">1.19.</span> <span class="toc-text">导包的路径问题和init方法调用</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#import%E5%8C%BF%E5%90%8D%E5%8F%8A%E5%88%AB%E5%90%8D%E5%AF%BC%E5%8C%85%E6%96%B9%E5%BC%8F"><span class="toc-number">1.20.</span> <span class="toc-text">import匿名及别名导包方式</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%8C%BF%E5%90%8D%E5%AF%BC%E5%8C%85"><span class="toc-number">1.20.1.</span> <span class="toc-text">匿名导包</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#defer%E5%92%8Creturn%E7%9A%84%E8%B0%83%E7%94%A8%E5%85%88%E5%90%8E%E9%97%AE%E9%A2%98"><span class="toc-number">1.20.2.</span> <span class="toc-text">defer和return的调用先后问题</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#%E7%BB%99%E4%B8%80%E4%B8%AA%E7%BB%93%E6%9E%84%E4%BD%93%E7%BB%91%E5%AE%9A%E6%96%B9%E6%B3%95"><span class="toc-number">1.21.</span> <span class="toc-text">给一个结构体绑定方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#go%E8%AF%AD%E8%A8%80%E9%AB%98%E5%B9%B6%E5%8F%91"><span class="toc-number">1.22.</span> <span class="toc-text">go语言高并发</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#%E9%80%9A%E9%81%93-1"><span class="toc-number">1.22.1.</span> <span class="toc-text">通道</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%9C%89%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%EF%BC%9A%E5%90%8C%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.22.2.</span> <span class="toc-text">有缓冲通道：同步通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E6%97%A0%E7%BC%93%E5%86%B2%E9%80%9A%E9%81%93%EF%BC%9A%E5%BC%82%E6%AD%A5%E9%80%9A%E4%BF%A1"><span class="toc-number">1.22.3.</span> <span class="toc-text">无缓冲通道：异步通信</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E5%85%B3%E9%97%ADchannel"><span class="toc-number">1.22.4.</span> <span class="toc-text">关闭channel</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#%E7%94%9F%E4%BA%A7%E8%80%85%E6%B6%88%E8%B4%B9%E8%80%85%E6%A8%A1%E5%9E%8B"><span class="toc-number">1.22.5.</span> <span class="toc-text">生产者消费者模型</span></a></li></ol></li></ol></li></ol></div></div><div class="card-widget card-recent-post"><div class="item-headline"><i class="fas fa-history"></i><span>最新文章</span></div><div class="aside-list"><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/2023%E5%A4%8D%E7%9B%98/" title="2023复盘">2023复盘</a><time datetime="2024-01-10T16:41:46.332Z" title="发表于 2024-01-11 00:41:46">2024-01-11</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E4%BE%A7%E4%BF%A1%E9%81%93%E6%94%BB%E5%87%BB/" title="侧信道攻击">侧信道攻击</a><time datetime="2023-09-26T09:03:09.760Z" title="发表于 2023-09-26 17:03:09">2023-09-26</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B_%E7%94%B5%E5%AD%90%E5%8F%96%E8%AF%81/" title="蓝帽杯半决赛wp_电子取证部分">蓝帽杯半决赛wp_电子取证部分</a><time datetime="2023-09-16T13:26:55.732Z" title="发表于 2023-09-16 21:26:55">2023-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E8%93%9D%E5%B8%BD%E6%9D%AF%E5%8D%8A%E5%86%B3%E8%B5%9B_web/" title="蓝帽杯半决赛wp_web部分">蓝帽杯半决赛wp_web部分</a><time datetime="2023-09-16T13:18:03.466Z" title="发表于 2023-09-16 21:18:03">2023-09-16</time></div></div><div class="aside-list-item no-cover"><div class="content"><a class="title" href="/%E6%95%B0%E6%8D%AE%E7%BB%93%E6%9E%84/" title="数据结构">数据结构</a><time datetime="2023-08-30T08:37:08.678Z" title="发表于 2023-08-30 16:37:08">2023-08-30</time></div></div></div></div></div></div></main><footer id="footer" style="background: transparent"><div id="footer-wrap"><div class="copyright">&copy;2020 - 2024 By h3110w0r1d</div><div class="framework-info"><span>框架 </span><a target="_blank" rel="noopener" href="https://hexo.io">Hexo</a><span class="footer-separator">|</span><span>主题 </span><a target="_blank" rel="noopener" href="https://github.com/jerryc127/hexo-theme-butterfly">Butterfly</a></div></div></footer></div><div id="rightside"><div id="rightside-config-hide"><button id="readmode" type="button" title="阅读模式"><i class="fas fa-book-open"></i></button><button id="darkmode" type="button" title="浅色和深色模式转换"><i class="fas fa-adjust"></i></button><button id="hide-aside-btn" type="button" title="单栏和双栏切换"><i class="fas fa-arrows-alt-h"></i></button></div><div id="rightside-config-show"><button id="rightside-config" type="button" title="设置"><i class="fas fa-cog fa-spin"></i></button><button class="close" id="mobile-toc-button" type="button" title="目录"><i class="fas fa-list-ul"></i></button><button id="go-up" type="button" title="回到顶部"><span class="scroll-percent"></span><i class="fas fa-arrow-up"></i></button></div></div><div><script src="/js/utils.js?v=4.12.0"></script><script src="/js/main.js?v=4.12.0"></script><script src="https://cdn.jsdelivr.net/npm/@fancyapps/ui@5.0.32/dist/fancybox/fancybox.umd.min.js"></script><div class="js-pjax"></div><script async data-pjax src="//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js"></script></div></body></html>